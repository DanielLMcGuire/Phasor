This is a .txt file representing an entire directory's contents.
Each file is separated by a line with its path.


--- .\cmake\AssemblyConfig.cmake ---
if(WIN32)
    if(ASSEMBLY)
        enable_language(ASM_MASM)
    endif()
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM64|aarch64")
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/crt.c)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/crt.c)
    else()
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/windows_x86_64.asm)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/windows_x86_64.asm)
    endif()
elseif(APPLE OR CMAKE_SYSTEM_NAME MATCHES "FreeBSD")
    if(ASSEMBLY)
        enable_language(ASM)
    endif()
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM64|aarch64")
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/crt.c)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/crt.c)
    else()
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/bsd_x86_64.s)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/bsd_x86_64.s)
    endif()
elseif(UNIX)
    if(ASSEMBLY)
        enable_language(ASM)
    endif()
    if(CMAKE_SYSTEM_PROCESSOR MATCHES "ARM64|aarch64")
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/crt.c)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/crt.c)
    else()
        set(ARITHMETIC_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/arithmetic/linux_x86_64.s)
        set(LOGICAL_ASM ${CMAKE_SOURCE_DIR}/src/Runtime/VM/core/logical/linux_x86_64.s)
    endif()
endif()

--- .\cmake\CompilerFlags.cmake ---
if(MSVC)
    set(CMAKE_C_FLAGS_RELEASE
        "/O2 /Oi /Ot /GL /Gy /MT /fp:precise /arch:AVX2 /Qspectre-"
    )
    set(CMAKE_CXX_FLAGS_RELEASE
        "/O2 /Oi /Ot /GL /Gy /MT /fp:precise /arch:AVX2 /EHsc /permissive- /DNOMINMAX"
    )
    set(CMAKE_EXE_LINKER_FLAGS_RELEASE
        "/LTCG /OPT:REF /OPT:ICF"
    )
    set(CMAKE_SHARED_LINKER_FLAGS_RELEASE
        "/LTCG /OPT:REF /OPT:ICF"
    )
    set(CMAKE_C_FLAGS_DEBUG "/Od /MTd /Zi /fp:strict")
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /MTd /Zi /fp:strict /EHsc /DNOMINMAX")
    set(CMAKE_EXE_LINKER_FLAGS_DEBUG "/DEBUG")
    set(CMAKE_SHARED_LINKER_FLAGS_DEBUG "/DEBUG")
else()
    set(COMMON_OPT
        "-O3 -flto -funroll-loops -fomit-frame-pointer -Wno-missing-field-initializers"
    )
    set(COMMON_FP
        "-ffast-math"
    )
    set(COMMON_WARN
        "-Wall -Wextra -pedantic"
    )
    set(COMMON_CXX_LANG
        "-fexceptions -frtti"
    )
    
    set(CMAKE_C_FLAGS_RELEASE
        "${COMMON_OPT} ${COMMON_FP} -march=native"
    )

    set(CMAKE_CXX_FLAGS_RELEASE
        "${COMMON_OPT} ${COMMON_FP} ${COMMON_CXX_LANG} ${COMMON_WARN} -march=native"
    )
    
    if(APPLE)
        set(CMAKE_EXE_LINKER_FLAGS_RELEASE "-Wl,-dead_strip")
        set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "-Wl,-dead_strip")
    elseif(WIN32)
        set(CMAKE_EXE_LINKER_FLAGS_RELEASE "")
        set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "")
    else()
        set(CMAKE_EXE_LINKER_FLAGS_RELEASE "-Wl,--gc-sections")
        set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "-Wl,--gc-sections")
    endif()
    
    set(CMAKE_C_FLAGS_DEBUG
        "-O0 -g -fno-omit-frame-pointer"
    )
    set(CMAKE_CXX_FLAGS_DEBUG
        "-O0 -g -fno-omit-frame-pointer -fexceptions -frtti"
    )
endif()

--- .\cmake\InstallConfig.cmake ---
if(WIN32)
    install(TARGETS
        phasor_main
        phasor_compiler
        phasor_repl
        phasor_interpreter
        phasor_cxx_transpiler
        phasor_lsp
    
        pulsar_main
        pulsar_compiler

        phasor_disasm
        phasor_runtime_exe
        phasor_native_runtime
        phasor_native_runtime_static
        phasor_shell
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
    )
    install(FILES
        ${CMAKE_SOURCE_DIR}/include/PhasorFFI.h
        ${CMAKE_SOURCE_DIR}/include/PhasorRT.h
        DESTINATION include
    )
elseif(APPLE)
    install(TARGETS
        phasor_main
        phasor_compiler
        phasor_repl
        phasor_interpreter
        phasor_cxx_transpiler
        phasor_lsp
    
        pulsar_main
        pulsar_compiler

        phasor_disasm
        phasor_runtime_exe
        phasor_native_runtime
        phasor_native_runtime_static
        phasor_shell
        RUNTIME DESTINATION usr/local/bin
        LIBRARY DESTINATION usr/local/lib
        ARCHIVE DESTINATION usr/local/lib
        FRAMEWORK DESTINATION frameworks
    )
    install(FILES
        ${CMAKE_SOURCE_DIR}/include/PhasorFFI.h
        ${CMAKE_SOURCE_DIR}/include/PhasorRT.h
        DESTINATION usr/local/include
    )
else()
    install(TARGETS
        phasor_main
        phasor_compiler
        phasor_repl
        phasor_interpreter
        phasor_cxx_transpiler
        phasor_lsp
    
        pulsar_main
        pulsar_compiler

        phasor_disasm
        phasor_runtime_exe
        phasor_native_runtime
        phasor_native_runtime_static
        phasor_shell
        RUNTIME DESTINATION usr/bin
        LIBRARY DESTINATION usr/lib
        ARCHIVE DESTINATION usr/lib
    )
    install(FILES
        ${CMAKE_SOURCE_DIR}/include/PhasorFFI.h
        ${CMAKE_SOURCE_DIR}/include/PhasorRT.h
        DESTINATION usr/include
    )
endif()

--- .\CMakeLists.txt ---
cmake_minimum_required(VERSION 3.10)
project(Phasor VERSION 3.0.0 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
    set(CMAKE_INSTALL_PREFIX "/" CACHE PATH "Default install prefix" FORCE)
endif()

if(WIN32)
    set(PLUGIN_INSTALL_DIR "bin/plugins")
elseif(APPLE)
    set(PLUGIN_INSTALL_DIR "Library/Application Support/org.Phasor.Phasor/plugins")
else()
    set(PLUGIN_INSTALL_DIR "opt/Phasor/plugins")
endif()

include_directories(${CMAKE_CURRENT_SOURCE_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR}/src ${CMAKE_CURRENT_BINARY_DIR}/include ${CMAKE_CURRENT_SOURCE_DIR}/src/include)

option(ASSEMBLY "Enable assembly for core code" ON)

if(WIN32 AND ASSEMBLY)
    enable_language(RC)
endif()

configure_file(
    "${CMAKE_CURRENT_SOURCE_DIR}/src/include/version.h.in"
    "${CMAKE_CURRENT_BINARY_DIR}/include/version.h"
    @ONLY
)

# Configure
include(cmake/CompilerFlags.cmake)
include(cmake/AssemblyConfig.cmake)

# Build
add_subdirectory(src)

add_subdirectory(thirdparty)

# Install
include(cmake/InstallConfig.cmake)

--- .\CMakePresets.json ---
{
    "version": 6,
    "configurePresets": [
        {
            "name": "base",
            "hidden": true,
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/out/build/${presetName}",
            "cacheVariables": {
                "CMAKE_EXPORT_COMPILE_COMMANDS": "ON"
            }
        },

        {
            "name": "macos-arm-dbg",
            "displayName": "macOS (arm64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Darwin"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Debug",
                "CMAKE_APPLE_SILICON_PROCESSOR": "arm64"
            }
        },
        {
            "name": "macos-arm-rel",
            "displayName": "macOS (arm64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Darwin"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Release",
                "CMAKE_APPLE_SILICON_PROCESSOR": "arm64"
            }
        },

        {
            "name": "macos-x64-dbg",
            "displayName": "macOS (x64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Darwin"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "macos-x64-rel",
            "displayName": "macOS (x64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Darwin"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "windows-64-dbg",
            "displayName": "Windows (x64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "windows-64-rel",
            "displayName": "Windows (x64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "windows-32-dbg",
            "displayName": "Windows (x86 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "windows-32-rel",
            "displayName": "Windows (x86 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "windows-arm64-dbg",
            "displayName": "Windows (arm64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "arm64",
                "strategy": "external"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "windows-arm64-rel",
            "displayName": "Windows (arm64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Windows"
            },
            "architecture": {
                "value": "arm64",
                "strategy": "external"
            },
            "cacheVariables": {
				"ASSEMBLY": "OFF",
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "linux-64-dbg",
            "displayName": "Linux (x64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "linux-64-rel",
            "displayName": "Linux (x64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "x64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "linux-32-dbg",
            "displayName": "Linux (x86 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "linux-32-rel",
            "displayName": "Linux (x86 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "x86",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        },

        {
            "name": "linux-arm64-dbg",
            "displayName": "Linux (arm64 Debug)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "arm64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug"
            }
        },
        {
            "name": "linux-arm64-rel",
            "displayName": "Linux (arm64 Release)",
            "inherits": "base",
            "condition": {
                "type": "equals",
                "lhs": "${hostSystemName}",
                "rhs": "Linux"
            },
            "architecture": {
                "value": "arm64",
                "strategy": "external"
            },
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Release"
            }
        }
    ]
}


--- .\CODE_OF_CONDUCT.md ---
# Contributor Covenant Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, religion, or sexual identity
and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the
  overall community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or
  advances of any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email
  address, without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at
danielmcguire23@icloud.com.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series
of actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or
permanent ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior,  harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within
the community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.0, available at
https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.

Community Impact Guidelines were inspired by [Mozilla's code of conduct
enforcement ladder](https://github.com/mozilla/diversity).

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see the FAQ at
https://www.contributor-covenant.org/faq. Translations are available at
https://www.contributor-covenant.org/translations.


--- .\docs\man\man1\man2pdf.sh ---
#!/bin/bash

files=(./*.1)
total=${#files[@]}
cpus=$(nproc)

# Progress file
progress_file=$(mktemp)
trap 'rm -f "$progress_file"' EXIT

process_file() {
    local file="$1"
    local output="${file}.pdf"
    local md5_file="${file}.md5"

    current_md5=$(md5sum "$file" | awk '{print $1}')
    prev_md5=""
    [[ -f "$md5_file" ]] && prev_md5=$(<"$md5_file")

    if [[ "$current_md5" != "$prev_md5" ]]; then
        man -l -Tpdf "$file" > "$output"
        echo "$current_md5" > "$md5_file"
        msg="Built $(basename "$output")"
    else
        msg="Skipped $(basename "$output")"
    fi

    # record completion
    echo "$msg" >> "$progress_file"
}

export -f process_file
export progress_file

# Zenity progress loop
(
    while :; do
        completed=$(wc -l < "$progress_file")
        percent=$((completed * 100 / total))

        if (( completed >= total )); then
            echo "100"
            echo "# Done"
            break
        fi

        last=$(tail -n1 "$progress_file")
        [[ -z "$last" ]] && last="Starting…"
        echo "$percent"
        echo "# $last"

        sleep 0.2
    done
) | zenity --progress \
          --title="Building PDFs" \
          --text="Starting…" \
          --percentage=0 \
          --auto-close \
          --width=450 &


# Start jobs with a simple job slot limiter
active=0
for file in "${files[@]}"; do
    process_file "$file" &
    active=$((active+1))
    if (( active >= cpus )); then
        wait -n
        active=$((active-1))
    fi
done

# wait for all jobs
wait


--- .\docs\man\man1\phasorcompiler.1 ---
.TH PHASORCOMPILER 1 "January 2026" "Phasor 3.0.0" "Phasor Manual"
.SH NAME
phasorcompiler \- Phasor source code compiler
.SH SYNOPSIS
.B phasorcompiler
[\fIOPTIONS\fR]
.I file.phs
.SH DESCRIPTION
.B phasorcompiler
compiles Phasor source files (.phs) into bytecode (.phsb) or intermediate representation (.phir) format. The bytecode can be executed by the Phasor VM, while IR files can be used for analysis.
.PP
The compiler performs lexical analysis, parsing, and code generation to transform high-level Phasor source code into executable bytecode or a human-readable intermediate representation.
.SH OPTIONS
.TP
.BR \-o ", " \-\-output " " \fIFILE\fR
Specify the output file path. If not provided, the output file will have the same base name as the input file with the appropriate extension (.phsb for bytecode, .phir for IR).
.TP
.BR \-i ", " \-\-ir
Compile to intermediate representation (IR) format instead of bytecode. The output file will have a .phir extension.
.TP
.BR \-v ", " \-\-verbose
Enable verbose output during compilation. Shows detailed information about the compilation process.
.TP
.BR \-h ", " \-\-help
Display help information and exit.
.SH FILES
.TP
.I *.phs
Phasor source files \fBPHS(5)\fR
.TP
.I *.phsb
Phasor bytecode files (compiled output) \fBPHSB(5)\fR
.TP
.I *.phir
Phasor intermediate representation files \fBPHIR(5)\fR
.SH EXAMPLES
Compile a source file to bytecode:
.PP
.nf
.RS
phasorcompiler program.phs
.RE
.fi
.PP
Compile with a specific output file:
.PP
.nf
.RS
phasorcompiler program.phs -o output.phsb
.RE
.fi
.PP
Compile to IR format:
.PP
.nf
.RS
phasorcompiler --ir program.phs -o program.phir
.RE
.fi
.PP
Compile with verbose output:
.PP
.nf
.RS
phasorcompiler -v program.phs
.RE
.fi
.SH EXIT STATUS
.TP
.B 0
Successful compilation
.TP
.B 1
Compilation error or invalid arguments
.SH DIAGNOSTICS
Compilation errors are reported to standard error with detailed information about syntax errors, semantic errors, or invalid input files.
.SH NOTES
The compiler will refuse to compile bytecode (.phsb) files or IR (.phir) files, as these are already compiled formats.
.SH SEE ALSO
.BR PHS (5),
.BR PHSB (5),
.BR PHIR (5),
.BR Compiler (3),
.BR phasorrepl (1),
.BR phasorvm (1),
.BR phasorjit (1),
.BR phasornative (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man1\phasorjit.1 ---
.TH PHASORJIT 1 "January 2026" "Phasor 3.0.0" "Phasor Manual"
.SH NAME
phasorjit \- Phasor Just-In-Time scripting runtime
.SH SYNOPSIS
.B phasorjit
[\fIOPTIONS\fR]
[\fIfile.phs\fR]
[\fISCRIPT_ARGS\fR...]
.SH DESCRIPTION
.B phasorjit
is the Phasor Just-In-Time (JIT) scripting runtime that executes Phasor source files directly without requiring pre-compilation. It performs lexical analysis, parsing, and code generation on-the-fly, then immediately executes the resulting bytecode in the Phasor virtual machine.
.PP
The JIT runtime is ideal for rapid development, scripting tasks, and scenarios where compilation overhead is acceptable in exchange for development convenience. Unlike the VM, the JIT runtime fully supports import statements and dynamic module loading.
.SH OPTIONS
.TP
.BR \-v ", " \-\-verbose
Enable verbose output. Prints the Abstract Syntax Tree (AST) before execution, useful for debugging and understanding program structure.
.TP
.BR \-h ", " \-\-help
Display help information and exit.
.SH ARGUMENTS
.TP
.I file.phs
Optional Phasor source file to execute. If omitted, the runtime exits immediately. Use
.BR phasorrepl (1)
for interactive execution.
.TP
.I SCRIPT_ARGS
Arguments passed to the Phasor script. These are accessible within the script through the standard library's argument handling functions (argc, argv).
.SH FEATURES
The JIT runtime provides:
.RS
.IP \(bu 2
Direct execution of Phasor source files
.IP \(bu 2
Full support for import statements and module loading
.IP \(bu 2
Access to command-line arguments through the standard library
.IP \(bu 2
Access to environment variables
.IP \(bu 2
Complete standard library functionality
.IP \(bu 2
AST visualization in verbose mode for debugging
.RE
.SH FILES
.TP
.I *.phs
Phasor source files \fBPHS(5)\fR
.SH ENVIRONMENT
The runtime provides access to all environment variables from the parent process through the standard library. Scripts can query and use environment variables as needed.
.SH EXAMPLES
Execute a Phasor script:
.PP
.nf
.RS
phasorjit program.phs
.RE
.fi
.PP
Execute a script with arguments:
.PP
.nf
.RS
phasorjit script.phs arg1 arg2 arg3
.RE
.fi
.PP
Execute with verbose output to see the AST:
.PP
.nf
.RS
phasorjit -v program.phs
.RE
.fi
.PP
Execute a script that uses imports:
.PP
.nf
.RS
phasorjit main.phs
.RE
.fi
.SH EXIT STATUS
.TP
.B 0
Successful execution
.TP
.B 1
Runtime error, parse error, or file not found
.SH DIAGNOSTICS
Error messages are printed to standard error on Unix-like systems. On Windows, critical errors are displayed in a message box dialog.
.PP
In verbose mode, the complete Abstract Syntax Tree is printed to standard output before execution begins, allowing developers to visualize the parsed structure of their program.
.SH IMPORT HANDLING
The JIT runtime fully supports import statements. When a script imports another module:
.RS
.IP 1. 3
The runtime locates the imported file based on the import path
.IP 2. 3
The imported file is read and parsed
.IP 3. 3
Bytecode is generated for the imported module
.IP 4. 3
The imported module's code is executed in the same VM context
.IP 5. 3
Definitions from the imported module become available to the importing script
.RE
.SH PERFORMANCE CONSIDERATIONS
The JIT runtime includes the overhead of:
.RS
.IP \(bu 2
Lexical analysis (tokenization)
.IP \(bu 2
Syntax parsing and AST construction
.IP \(bu 2
Bytecode generation
.RE
.PP
For production environments where startup time is critical, consider using
.BR phasorcompiler (1)
to pre-compile source files and
.BR phasorvm (1)
to execute them, or
.BR phasornative (1)
to create native executables.
.SH NOTES
Unlike
.BR phasorvm (1),
the JIT runtime can execute source files directly and supports the full import system. This makes it the most flexible runtime option for development and scripting.
.SH SEE ALSO
.BR PHS (5),
.BR ScriptingRuntime (3),
.BR Frontend (3),
.BR phasorcompiler (1),
.BR phasorvm (1),
.BR phasorrepl (1),
.BR phasornative (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man1\phasornative.1 ---
.TH PHASORNATIVE 1 "January 2026" "Phasor 3.0.0" "Phasor Manual"
.SH NAME
phasornative \- Phasor C++ code generator and native compiler
.SH SYNOPSIS
.B phasornative
[\fIOPTIONS\fR]
.I input.phs
.SH DESCRIPTION
.B phasornative
generates C++ code from Phasor source files or intermediate representation and compiles it into native executables. It can generate header files containing embedded bytecode, compile them with a C++ compiler, and link them against the Phasor runtime library.
.PP
This tool enables the creation of standalone native executables from Phasor programs, offering maximum performance and simplified distribution without requiring the Phasor runtime to be separately installed.
.SH OPTIONS
.TP
.BR \-o ", " \-\-output " " \fIFILE\fR
Specify the output file path. Default is the module name with platform-specific executable extension (.exe on Windows).
.TP
.BR \-m ", " \-\-module " " \fINAME\fR
Set the module name for generated code. Default is the input filename stem.
.TP
.BR \-c ", " \-\-compiler " " \fICOMPILER\fR
Specify the C++ compiler to use. Supported values: g++, clang++, cl. Default is g++. The linker is automatically selected based on the compiler unless explicitly specified.
.TP
.BR \-l ", " \-\-linker " " \fILINKER\fR
Specify the linker to use. Supported values: gcc, clang, ld, link. Default is determined by the compiler choice.
.TP
.BR \-s ", " \-\-source " " \fIFILE\fR
Specify the main source file to compile with. Default locations:
.RS
.IP \(bu 2
Windows: C:\\Program Files\\Phasor VM\\Development\\nativestub.cpp
.IP \(bu 2
Unix: /usr/local/share/phasor/dev/nativestub.cpp
.RE
.TP
.BR \-H ", " \-\-header\-only
Generate only the header file containing embedded bytecode. Does not compile or link.
.TP
.BR \-g ", " \-\-generate\-only
Generate both header and source files but do not compile or link.
.TP
.BR \-O ", " \-\-object\-only
Generate, compile to object file, but do not link. Useful for creating libraries or linking later.
.TP
.BR \-v ", " \-\-verbose
Enable verbose output showing detailed compilation steps and statistics.
.TP
.BR \-n ", " \-\-nologo
Suppress the banner and copyright information.
.TP
.BR \-h ", " \-\-help
Display help information and exit.
.SH INPUT FILES
.TP
.I *.phs
Phasor source files \fBPHS(5)\fR
.TP
.I *.phir
Phasor intermediate representation files \fBPHIR(5)\fR
.SH GENERATED FILES
.TP
.I <module>.h
Generated header file containing embedded bytecode and runtime interface
.TP
.I <module>.cpp
Generated C++ source file including the header and runtime stub
.TP
.I <module>.obj
Compiled object file (on Windows or with -O option)
.TP
.I <module>.exe
Final executable (Windows)
.TP
.I <module>
Final executable (Unix-like systems)
.SH COMPILATION PROCESS
The native compilation process consists of four stages:
.PP
.B 1. Header Generation
.RS
Reads the Phasor source or IR file, generates bytecode if necessary, and creates a C++ header file with embedded bytecode arrays and runtime interface declarations.
.RE
.PP
.B 2. Source Generation
.RS
Creates a C++ source file that includes the generated header and the native runtime stub, which initializes the VM and executes the embedded bytecode.
.RE
.PP
.B 3. Compilation
.RS
Invokes the selected C++ compiler with optimization flags to compile the source file into an object file.
.RE
.PP
.B 4. Linking
.RS
Links the object file against the Phasor runtime library to create the final executable.
.RE
.SH COMPILER FLAGS
The tool automatically applies appropriate optimization flags for each compiler:
.PP
.B g++/clang++:
.RS
-std=c++20 -O3 -DNDEBUG -fPIC -flto -fno-function-sections -fno-stack-protector -fwhole-program
.RE
.PP
.B cl (MSVC):
.RS
/std:c++20 /Ox /DNDEBUG /MD /GL /Gy- /GS- /Gw /EHsc
.RE
.SH EXAMPLES
Compile a Phasor program to native executable:
.PP
.nf
.RS
phasornative program.phs
.RE
.fi
.PP
Use Clang compiler with LLD linker:
.PP
.nf
.RS
phasornative program.phs -c clang++ -l lld -o program
.RE
.fi
.PP
Generate only the header file:
.PP
.nf
.RS
phasornative -H program.phs -o program.hpp
.RE
.fi
.PP
Generate header and source without compiling:
.PP
.nf
.RS
phasornative -g program.phs -m mymodule
.RE
.fi
.PP
Compile to object file only:
.PP
.nf
.RS
phasornative -O program.phs -o program.obj -c clang++
.RE
.fi
.SH EXIT STATUS
.TP
.B 0
Successful generation, compilation, and linking
.TP
.B 1
Error in any stage of the process
.SH DIAGNOSTICS
Each stage of compilation is clearly labeled in the output. Compiler and linker output is displayed directly, allowing for easy identification of build errors.
.SH NOTES
The native compiler requires a working C++20-compatible compiler toolchain and the Phasor runtime library to be installed on the system.
.PP
Generated executables are statically linked against the Phasor runtime where possible, reducing deployment dependencies.
.SH SEE ALSO
.BR PHS (5),
.BR CppCompiler (3),
.BR phasorcompiler (1),
.BR phasorjit (1),
.BR phasorvm (1),
.BR phasorrepl (1),
.BR g++ (1),
.BR clang++ (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man1\phasorrepl.1 ---
.TH PHASORREPL 1 "January 2026" "Phasor 3.0.0" "Phasor Manual"
.SH NAME
phasorrepl \- Phasor interactive Read-Eval-Print Loop
.SH SYNOPSIS
.B phasorrepl
.SH DESCRIPTION
.B phasorrepl
provides an interactive Read-Eval-Print Loop (REPL) environment for the Phasor programming language. It allows users to execute Phasor code interactively, experiment with language features, test code snippets, and explore the standard library in real-time.
.PP
The REPL lexes, parses, generates bytecode, and executes each line or expression immediately, displaying results and maintaining state across multiple inputs. This makes it ideal for learning, prototyping, and rapid development.
.SH FEATURES
The REPL provides:
.RS
.IP \(bu 2
Line-by-line code execution with immediate feedback
.IP \(bu 2
Expression evaluation and result display
.IP \(bu 2
Persistent state across multiple inputs
.IP \(bu 2
Variable and function definitions that remain in scope
.IP \(bu 2
Access to all standard library functions
.IP \(bu 2
Import statement support for loading modules
.IP \(bu 2
Full access to environment variables
.RE
.SH USAGE
Simply invoke
.B phasorrepl
without any arguments to start the interactive session. The REPL will display a prompt where you can enter Phasor expressions, statements, or function definitions.
.PP
To exit the REPL, use the appropriate exit command or keyboard interrupt (typically Ctrl+C or Ctrl+D).
.SH EXAMPLES
Start the REPL:
.PP
.nf
.RS
phasorrepl
.RE
.SH ENVIRONMENT
The REPL has access to all environment variables from the parent process through the standard library.
.SH DIAGNOSTICS
Errors are displayed immediately after the input that caused them, allowing for quick identification and correction of issues.
.SH NOTES
Unlike the scripting runtime, the REPL does not accept a source file as input. Use
.BR phasorjit (1)
to execute source files directly.
.SH SEE ALSO
.BR Repl (3),
.BR Frontend (3),
.BR phasorcompiler (1),
.BR phasorjit (1),
.BR phasorvm (1),
.BR phasornative (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man1\phasorvm.1 ---
.TH PHASORVM 1 "January 2026" "Phasor 3.0.0" "Phasor Manual"
.SH NAME
phasorvm \- Phasor virtual machine for executing compiled bytecode
.SH SYNOPSIS
.B phasorvm
[\fIOPTIONS\fR]
.I file.phsb
[\fISCRIPT_ARGS\fR...]
.SH DESCRIPTION
.B phasorvm
is the Phasor virtual machine that executes pre-compiled Phasor bytecode files. Unlike the JIT runtime, it does not perform lexing, parsing, or code generation, making it significantly faster for production deployments.
.PP
The VM loads serialized bytecode directly and begins execution immediately. This makes it the preferred choice for performance-critical applications and production environments where compilation overhead is undesirable.
.SH OPTIONS
.TP
.BR \-v ", " \-\-verbose
Enable verbose output. Displays debugging information including bytecode statistics and execution details.
.TP
.BR \-h ", " \-\-help
Display help information and exit.
.SH ARGUMENTS
.TP
.I file.phsb
Required Phasor bytecode file to execute. Must be a valid compiled bytecode file created by phasorcompiler.
.TP
.I SCRIPT_ARGS
Arguments passed to the bytecode program. These are accessible within the program through the standard library's argument handling functions.
.SH FILES
.TP
.I *.phsb
Phasor bytecode files (compiled by phasorcompiler)
.SH VERBOSE OUTPUT
When verbose mode is enabled, the following information is displayed:
.RS
.IP \(bu 2
Bytecode loading status and file path
.IP \(bu 2
Number of instructions in the bytecode
.IP \(bu 2
Number of constants defined
.IP \(bu 2
Number of variables allocated
.IP \(bu 2
Execution start and completion notifications
.RE
.SH EXAMPLES
Execute a compiled bytecode file:
.PP
.nf
.RS
phasorvm program.phsb
.RE
.fi
.PP
Execute with script arguments:
.PP
.nf
.RS
phasorvm program.phsb arg1 arg2 arg3
.RE
.fi
.PP
Execute with verbose output:
.PP
.nf
.RS
phasorvm --verbose program.phsb
.RE
.fi
.SH EXIT STATUS
.TP
.B 0
Successful execution
.TP
.B 1
Runtime error, invalid bytecode, or file not found
.SH DIAGNOSTICS
Error messages are printed to standard error on Unix-like systems. On Windows, critical errors are displayed in a message box dialog for better visibility.
.PP
In verbose mode, detailed debugging information is printed to standard error throughout the execution process.
.SH LIMITATIONS
The current implementation does not support import statements in the VM runtime. Programs that require multiple modules should be linked together during compilation (not yet supported) or use the JIT runtime.
.SH PERFORMANCE
The VM provides the fastest execution for Phasor programs because it:
.RS
.IP \(bu 2
Skips lexical analysis and parsing
.IP \(bu 2
Avoids code generation overhead
.IP \(bu 2
Loads optimized bytecode directly
.IP \(bu 2
Starts execution immediately
.RE
.PP
For production deployments, compile with phasorcompiler and execute with phasorvm for optimal performance.
.SH NOTES
Bytecode files are platform-independent and can be executed on any system with a compatible Phasor VM installation.
.SH SEE ALSO
.BR PHSB (5),
.BR BinaryRuntime (3),
.BR phasorcompiler (1),
.BR phasorjit (1),
.BR phasorrepl (1),
.BR phasornative (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\man2pdf.sh ---
#!/bin/bash

files=(./*.3)
total=${#files[@]}
cpus=$(nproc)

# Progress file
progress_file=$(mktemp)
trap 'rm -f "$progress_file"' EXIT

process_file() {
    local file="$1"
    local output="${file}.pdf"
    local md5_file="${file}.md5"

    current_md5=$(md5sum "$file" | awk '{print $1}')
    prev_md5=""
    [[ -f "$md5_file" ]] && prev_md5=$(<"$md5_file")

    if [[ "$current_md5" != "$prev_md5" ]]; then
        man -l -Tpdf "$file" > "$output"
        echo "$current_md5" > "$md5_file"
        msg="Built $(basename "$output")"
    else
        msg="Skipped $(basename "$output")"
    fi

    # record completion
    echo "$msg" >> "$progress_file"
}

export -f process_file
export progress_file

# Zenity progress loop
(
    while :; do
        completed=$(wc -l < "$progress_file")
        percent=$((completed * 100 / total))

        if (( completed >= total )); then
            echo "100"
            echo "# Done"
            break
        fi

        last=$(tail -n1 "$progress_file")
        [[ -z "$last" ]] && last="Starting…"
        echo "$percent"
        echo "# $last"

        sleep 0.2
    done
) | zenity --progress \
          --title="Building PDFs" \
          --text="Starting…" \
          --percentage=0 \
          --auto-close \
          --width=450 &

zenity_pid=$!

# Start jobs with a simple job slot limiter
active=0
for file in "${files[@]}"; do
    process_file "$file" &
    active=$((active+1))
    if (( active >= cpus )); then
        wait -n
        active=$((active-1))
    fi
done

# wait for all jobs
wait

# wait for Zenity to finish
wait "$zenity_pid"


--- .\docs\man\man3\phasorstd_file.3 ---
.TH PHASORSTD_FILE 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_file \- Phasor file system functions
.SH SYNOPSIS
.nf
.B using("stdfile");
.PP
.B fabsolute(path)
.B fread(path)
.B fwrite(path, content)
.B fexists(path)
.B freadln(path, line_number)
.B fwriteln(path, line_number, content)
.B fappend(path, content)
.B frm(path)
.B frn(old_path, new_path)
.B fcd([path])
.B fcp(source, dest[, overwrite])
.B fmv(source, dest)
.B fpropset(path, property, value)
.B fpropget(path, property)
.B fmk(path)
.B fmkdir(path)
.B frmdir(path, recurse)
.B freaddir(path)
.B fstat(path)
.fi
.SH FILE I/O FUNCTIONS
.TP
.BR fread (path)
Read the entire contents of a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.RE
.PP
.B Returns:
String containing file contents, or null if file cannot be opened
.RE
.PP
.TP
.BR fabsolute (path)
Get the absolute path of a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.RE
.PP
.B Returns:
Absolute path
.RE
.PP
.TP
.BR fwrite (path, content)
Write content to a file, overwriting existing content.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.IP \fBcontent\fR 12
String to write
.RE
.PP
.B Returns:
Boolean true on success
.PP
.B Throws:
Runtime error if file cannot be opened
.RE
.PP
.TP
.BR fappend (path, content)
Append content to the end of a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.IP \fBcontent\fR 12
String to append
.RE
.PP
.B Returns:
Boolean true on success
.PP
.B Throws:
Runtime error if file cannot be opened
.RE
.PP
.TP
.BR freadln (path, line_number)
Read a specific line from a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.IP \fBline_number\fR 12
Zero-based line index
.RE
.PP
.B Returns:
String containing the line content
.PP
.B Throws:
Runtime error if file cannot be opened
.RE
.PP
.TP
.BR fwriteln (path, line_number, content)
Write content to a specific line in a file, expanding the file if necessary.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Path to the file
.IP \fBline_number\fR 12
Zero-based line index
.IP \fBcontent\fR 12
New line content
.RE
.PP
.B Returns:
Boolean true on success
.PP
.B Throws:
Runtime error if file cannot be opened
.RE
.SH FILE OPERATIONS
.TP
.BR fexists (path)
Check if a file or directory exists.
.RS
.PP
.B Returns:
Boolean true if path exists, false otherwise
.RE
.PP
.TP
.BR fmk (path)
Create a new empty file.
.RS
.PP
.B Returns:
Boolean true on success
.PP
.B Throws:
Runtime error if file cannot be created
.RE
.PP
.TP
.BR frm (path)
Remove (delete) a file.
.RS
.PP
.B Returns:
Boolean true if file was deleted, false if file didn't exist
.RE
.PP
.TP
.BR frn (old_path, new_path)
Rename a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBold_path\fR 12
Current file path
.IP \fBnew_path\fR 12
New file path
.RE
.PP
.B Returns:
Boolean true if renamed, false if source didn't exist
.RE
.PP
.TP
.BR fcp (source, dest[, overwrite])
Copy a file.
.RS
.PP
.B Arguments:
.RS
.IP \fBsource\fR 12
Source file path
.IP \fBdest\fR 12
Destination file path
.IP \fBoverwrite\fR 12
Boolean to allow overwriting (optional, default false)
.RE
.PP
.B Returns:
Boolean true on success, false on failure
.RE
.PP
.TP
.BR fmv (source, dest)
Move a file (copy then delete source).
.RS
.PP
.B Arguments:
.RS
.IP \fBsource\fR 12
Source file path
.IP \fBdest\fR 12
Destination file path
.RE
.PP
.B Returns:
Null value
.RE
.SH DIRECTORY OPERATIONS
.TP
.BR fcd ([path])
Get or set the current working directory.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
New working directory (optional)
.RE
.PP
.B Returns:
Current working directory path. If path argument provided, changes to that directory first
.RE
.PP
.TP
.BR fmkdir (path)
Create a new directory.
.RS
.PP
.B Returns:
Boolean true if created, false if directory already exists
.RE
.PP
.TP
.BR frmdir (path, recurse)
Remove an empty directory.
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
Directory path
.IP \fBrecurse\fR 12
Boolean to remove subdirectories (optional, default false)
.RE
.RS
.PP
.B Returns:
Boolean true on success
.RE
.PP
.TP
.BR freaddir (path)
List contents of a directory.
.RS
.PP
.B Returns:
String with filenames separated by newlines, or error message on failure
.RE
.SH FILE METADATA
.TP
.BR fpropset (path, property, value)
Set a file property (timestamp).
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
File path
.IP \fBproperty\fR 12
Property character ('a'=access, 'm'=modify)
.IP \fBvalue\fR 12
Unix timestamp (epoch seconds)
.RE
.PP
.B Returns:
Result of property set operation
.PP
.B Throws:
Runtime error if epoch is negative
.RE
.PP
.TP
.BR fpropget (path, property)
Get a file property (timestamp).
.RS
.PP
.B Arguments:
.RS
.IP \fBpath\fR 12
File path
.IP \fBproperty\fR 12
Property character ('a'=access, 'm'=modify)
.RE
.PP
.B Returns:
Property value
.RE
.PP
.TP
.BR fstat (path)
Get detailed file statistics.
.RS
.PP
.B Returns:
Struct containing:
.RS
.IP \fBmode\fR 12
File mode and permissions
.IP \fBnlink\fR 12
Number of hard links
.IP \fBuid\fR 12
User ID of owner
.IP \fBgid\fR 12
Group ID of owner
.IP \fBsize\fR 12
File size in bytes
.RE
.PP
Returns null on error
.RE
.SH EXAMPLES
.B Basic File I/O
.PP
.nf
.RS
include_stdfile();

// Write to file
fwrite("data.txt", "Hello, World!");

// Read from file
var content = fread("data.txt");
puts(content);

// Append to file
fappend("data.txt", "\\nNew line");
.RE
.fi
.PP
.B Line-Based Operations
.PP
.nf
.RS
// Read specific line
var line = freadln("config.txt", 0);

// Update specific line
fwriteln("config.txt", 2, "new_setting=value");
.RE
.fi
.PP
.B File Management
.PP
.nf
.RS
// Check existence
if (fexists("old.txt")) {
    // Rename file
    frn("old.txt", "new.txt");
}

// Copy with overwrite
fcp("source.txt", "backup.txt", true);

// Move file
fmv("temp.txt", "archive/temp.txt");

// Delete file
frm("unwanted.txt");
.RE
.fi
.PP
.B Directory Operations
.PP
.nf
.RS
// Get current directory
var cwd = fcd();
puts(cwd);

// Change directory
fcd("/home/user/projects");

// Create directory
fmkdir("new_folder");

// List directory
var files = freaddir(".");
puts(files);

// Remove directory
frmdir("empty_folder");
.RE
.fi
.PP
.B File Statistics
.PP
.nf
.RS
var stat = fstat("document.txt");
if (stat != null) {
    putf("Size: %d bytes", stat.size);
    putf("Owner UID: %d", stat.uid);
    putf("Permissions: %d", stat.mode);
    putf("Hard links: %d", stat.nlink);
}
.RE
.fi
.PP
.B File Properties
.PP
.nf
.RS
// Get modification time
var mtime = fpropget("file.txt", 'm');
puts(mtime);

// Set access time
var now = time();
fpropset("file.txt", 'a', now);
.RE
.fi
.SH NOTES
.IP \(bu 2
File paths can be relative or absolute
.IP \(bu 2
Line numbers in
.B freadln()
and
.B fwriteln()
are zero-based
.IP \(bu 2
.B fwriteln()
expands the file with empty lines if necessary
.IP \(bu 2
.B fmv()
is implemented as copy + delete, not an atomic move
.IP \(bu 2
Directory removal only works on empty directories
.IP \(bu 2
File statistics struct uses Unix-style permissions
.IP \(bu 2
Property characters: 'a' for access time, 'm' for modification time
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_io.3 ---
.TH PHASORSTD_IO 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_io \- Phasor standard I/O functions
.SH SYNOPSIS
.nf
.B using("stdio");
.PP
.B c_fmt(format, ...)
.B prints(string)
.B printf(format, ...)
.B puts(string)
.B putf(format, ...)
.B gets()
.B puts_error(string)
.B putf_error(format, ...)
.fi
.SH FUNCTIONS
.TP
.BR c_fmt (format, ...)
Format a string using C-style format specifiers. Returns the formatted string without printing.
.RS
.PP
.B Format Specifiers:
.RS
.IP \fB%s\fR 8
String
.IP \fB%d\fR 8
Integer (decimal)
.IP \fB%f\fR 8
Float
.IP \fB%%\fR 8
Literal percent sign
.IP \fB%c\fR 8
Character
.IP \fB%x\fR 8
Hexadecimal (lowercase)
.RE
.PP
.B Arguments:
.RS
.IP \fBformat\fR 12
Format string with specifiers
.IP \fB...\fR 12
Values to format (variadic)
.RE
.PP
.B Returns:
Formatted string
.RE
.PP
.TP
.BR prints (string)
Print a string to stdout without adding a newline.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
String to print
.RE
.PP
.B Returns:
Empty string
.RE
.PP
.TP
.BR printf (format, ...)
Print a formatted string to stdout without adding a newline. Equivalent to
.B c_fmt()
followed by
.BR prints() .
.RS
.PP
.B Arguments:
.RS
.IP \fBformat\fR 12
Format string with specifiers
.IP \fB...\fR 12
Values to format (variadic)
.RE
.PP
.B Returns:
Empty string
.RE
.PP
.TP
.BR puts (string)
Print a string to stdout followed by a newline character.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
String to print
.RE
.PP
.B Returns:
Empty string
.RE
.PP
.TP
.BR putf (format, ...)
Print a formatted string to stdout followed by a newline. Equivalent to
.B c_fmt()
followed by
.BR puts() .
.RS
.PP
.B Arguments:
.RS
.IP \fBformat\fR 12
Format string with specifiers
.IP \fB...\fR 12
Values to format (variadic)
.RE
.PP
.B Returns:
Empty string
.RE
.PP
.TP
.BR gets ()
Read a line of input from stdin.
.RS
.PP
.B Arguments:
None
.PP
.B Returns:
String containing the input line
.RE
.PP
.TP
.BR puts_error (string)
Print a string to stderr followed by a newline character.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
String to print to stderr
.RE
.PP
.B Returns:
Empty string or error value
.RE
.PP
.TP
.BR putf_error (format, ...)
Print a formatted string to stderr followed by a newline.
.RS
.PP
.B Arguments:
.RS
.IP \fBformat\fR 12
Format string with specifiers
.IP \fB...\fR 12
Values to format (variadic)
.RE
.PP
.B Returns:
Empty string or error value
.RE
.SH EXAMPLES
.B Basic Output
.PP
.nf
.RS
include_stdio();

puts("Hello, World!");
prints("No newline");
.RE
.fi
.PP
.B Formatted Output
.PP
.nf
.RS
var name = "Alice";
var age = 30;
var score = 95.5;

putf("Name: %s", name);
putf("Age: %d", age);
putf("Score: %f", score);
printf("Result: %s got %f%%", name, score);
.RE
.fi
.PP
.B User Input
.PP
.nf
.RS
puts("Enter your name:");
var name = gets();
putf("Hello, %s!", name);
.RE
.fi
.PP
.B Error Output
.PP
.nf
.RS
if (error_condition) {
    puts_error("An error occurred!");
    putf_error("Error code: %d", error_code);
}
.RE
.fi
.PP
.B String Formatting
.PP
.nf
.RS
var message = c_fmt("User %s (ID: %d)", username, user_id);
puts(message);
.RE
.fi
.SH NOTES
.IP \(bu 2
All print functions flush output immediately
.IP \(bu 2
The
.B gets()
function reads until a newline character is encountered
.IP \(bu 2
Format strings are processed at runtime, not compile time
.IP \(bu 2
Unknown format specifiers are included literally in the output
.IP \(bu 2
The
.B c_fmt()
function is useful for building strings without immediate output
.SH SEE ALSO
.BR phasorstd_str (3),
.BR phasorstd_file (3),
.BR phasorstd_sys (3),
.BR phasorjit (1)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_math.3 ---
.TH PHASORSTD_MATH 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_math \- Phasor mathematical functions
.SH SYNOPSIS
.nf
.B using("stdmath");
.PP
.B math_sqrt(x)
.B math_pow(base, exponent)
.B math_abs(x)
.B math_floor(x)
.B math_ceil(x)
.B math_round(x)
.B math_min(a, b)
.B math_max(a, b)
.B math_log(x)
.B math_exp(x)
.B math_sin(x)
.B math_cos(x)
.B math_tan(x)
.fi
.SH FUNCTIONS
.SS Basic Functions
.TP
.BR math_sqrt (x)
Calculate the square root of a number.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (converted to float)
.RE
.PP
.B Returns:
Square root as a float
.RE
.PP
.TP
.BR math_pow (base, exponent)
Raise a number to a power.
.RS
.PP
.B Arguments:
.RS
.IP \fBbase\fR 12
Base number (converted to float)
.IP \fBexponent\fR 12
Exponent (converted to float)
.RE
.PP
.B Returns:
base^exponent as a float
.RE
.PP
.TP
.BR math_abs (x)
Calculate the absolute value of a number.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (int or float)
.RE
.PP
.B Returns:
Absolute value (preserves type: int returns int, float returns float)
.RE
.PP
.SS Rounding Functions
.TP
.BR math_floor (x)
Round down to the nearest integer.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (converted to float)
.RE
.PP
.B Returns:
Largest integer less than or equal to x (as int64)
.RE
.PP
.TP
.BR math_ceil (x)
Round up to the nearest integer.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (converted to float)
.RE
.PP
.B Returns:
Smallest integer greater than or equal to x (as int64)
.RE
.PP
.TP
.BR math_round (x)
Round to the nearest integer.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (converted to float)
.RE
.PP
.B Returns:
Nearest integer to x (as int64)
.RE
.PP
.SS Comparison Functions
.TP
.BR math_min (a, b)
Return the smaller of two numbers.
.RS
.PP
.B Arguments:
.RS
.IP \fBa\fR 12
First number
.IP \fBb\fR 12
Second number
.RE
.PP
.B Returns:
The smaller value (preserves type when both are same type)
.RE
.PP
.TP
.BR math_max (a, b)
Return the larger of two numbers.
.RS
.PP
.B Arguments:
.RS
.IP \fBa\fR 12
First number
.IP \fBb\fR 12
Second number
.RE
.PP
.B Returns:
The larger value (preserves type when both are same type)
.RE
.PP
.SS Exponential and Logarithmic Functions
.TP
.BR math_log (x)
Calculate the natural logarithm (base e).
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Number (converted to float, must be positive)
.RE
.PP
.B Returns:
Natural logarithm of x as a float
.RE
.PP
.TP
.BR math_exp (x)
Calculate e raised to a power.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Exponent (converted to float)
.RE
.PP
.B Returns:
e^x as a float
.RE
.PP
.SS Trigonometric Functions
.TP
.BR math_sin (x)
Calculate the sine of an angle.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Angle in radians (converted to float)
.RE
.PP
.B Returns:
Sine of x as a float
.RE
.PP
.TP
.BR math_cos (x)
Calculate the cosine of an angle.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Angle in radians (converted to float)
.RE
.PP
.B Returns:
Cosine of x as a float
.RE
.PP
.TP
.BR math_tan (x)
Calculate the tangent of an angle.
.RS
.PP
.B Arguments:
.RS
.IP \fBx\fR 12
Angle in radians (converted to float)
.RE
.PP
.B Returns:
Tangent of x as a float
.RE
.SH EXAMPLES
.B Basic Arithmetic
.PP
.nf
.RS
include_stdmath();

var x = 16.0;
puts(math_sqrt(x));        // 4.0
puts(math_pow(2, 8));      // 256.0
puts(math_abs(-42));       // 42
.RE
.fi
.PP
.B Rounding Operations
.PP
.nf
.RS
var pi = 3.14159;

puts(math_floor(pi));      // 3
puts(math_ceil(pi));       // 4
puts(math_round(pi));      // 3

puts(math_round(2.5));     // 2 or 3 (banker's rounding)
.RE
.fi
.PP
.B Min/Max Operations
.PP
.nf
.RS
var a = 10;
var b = 20;

puts(math_min(a, b));      // 10
puts(math_max(a, b));      // 20

// Works with floats too
puts(math_min(3.14, 2.71)); // 2.71
.RE
.fi
.PP
.B Exponential and Logarithmic
.PP
.nf
.RS
puts(math_exp(1));         // e ≈ 2.71828
puts(math_log(math_exp(1))); // 1.0

var x = 100;
puts(math_log(x));         // Natural log of 100
.RE
.fi
.PP
.B Trigonometry
.PP
.nf
.RS
var pi = 3.14159265;

puts(math_sin(0));         // 0.0
puts(math_cos(0));         // 1.0
puts(math_tan(pi / 4));    // ≈ 1.0 (45 degrees)

// Convert degrees to radians
fn deg_to_rad(degrees) {
    return degrees * pi / 180;
}

puts(math_sin(deg_to_rad(90))); // ≈ 1.0
.RE
.fi
.PP
.B Distance Calculation
.PP
.nf
.RS
fn distance(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    return math_sqrt(dx * dx + dy * dy);
}

var dist = distance(0, 0, 3, 4);
puts(dist);  // 5.0
.RE
.fi
.PP
.B Circle Calculations
.PP
.nf
.RS
fn circle_area(radius) {
    var pi = 3.14159265;
    return pi * math_pow(radius, 2);
}

fn circle_circumference(radius) {
    var pi = 3.14159265;
    return 2 * pi * radius;
}

puts(circle_area(5));           // ≈ 78.54
puts(circle_circumference(5));  // ≈ 31.42
.RE
.fi
.SH NOTES
.IP \(bu 2
All trigonometric functions use radians, not degrees
.IP \(bu 2
Math functions are implemented using optimized assembly routines where available
.IP \(bu 2
.B math_log()
calculates the natural logarithm (base e), not base 10
.IP \(bu 2
Division by zero or invalid operations may result in infinity or NaN
.IP \(bu 2
Type preservation: integer operations return integers when possible
.IP \(bu 2
Most functions convert arguments to float for calculation
.SH CONSTANTS
Phasor does not provide built-in mathematical constants. Define them as needed:
.PP
.nf
.RS
var PI = 3.14159265358979323846;
var E = 2.71828182845904523536;
var SQRT2 = 1.41421356237309504880;
.RE
.fi
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_regex.3 ---
.TH PHASORSTD_REGEX 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_regex \- Phasor regular expression functions
.SH SYNOPSIS
.nf
.B using("stdregex");
.PP
.B regex_match(pattern, text)
.B regex_search(pattern, text[, start[, end]])
.B regex_findall(pattern, text)
.B regex_split(pattern, text[, max_split])
.B regex_replace(pattern, text, replacement[, flags])
.fi
.SH FUNCTIONS
.TP
.BR regex_match (pattern, text)
Check if the entire text matches a regular expression pattern.
.RS
.PP
.B Arguments:
.RS
.IP \fBpattern\fR 12
Regular expression pattern string
.IP \fBtext\fR 12
Text to match against
.RE
.PP
.B Returns:
Boolean true if entire text matches pattern, false otherwise
.PP
.B Throws:
Runtime error on invalid regex pattern
.RE
.PP
.TP
.BR regex_search (pattern, text[, start[, end]])
Search for a pattern within text and return the first match.
.RS
.PP
.B Arguments:
.RS
.IP \fBpattern\fR 12
Regular expression pattern string
.IP \fBtext\fR 12
Text to search
.IP \fBstart\fR 12
Starting position (optional, default 0)
.IP \fBend\fR 12
Ending position (optional, default end of text)
.RE
.PP
.B Returns:
String containing the first match, or empty string if no match
.PP
.B Throws:
Runtime error on invalid regex or out-of-range positions
.RE
.PP
.TP
.BR regex_findall (pattern, text)
Find all occurrences of a pattern in text.
.RS
.PP
.B Arguments:
.RS
.IP \fBpattern\fR 12
Regular expression pattern string
.IP \fBtext\fR 12
Text to search
.RE
.PP
.B Returns:
Struct containing:
.RS
.IP \fBcount\fR 12
Number of matches
.IP \fB0, 1, 2...\fR 12
Match structs with fields:
.RS
.IP \(bu 2
.B text
- Matched text
.IP \(bu 2
.B position
- Match position in original text
.RE
.RE
.PP
.B Throws:
Runtime error on invalid regex pattern
.RE
.PP
.TP
.BR regex_split (pattern, text[, max_split])
Split text by regex pattern matches.
.RS
.PP
.B Arguments:
.RS
.IP \fBpattern\fR 12
Regular expression pattern for splitting
.IP \fBtext\fR 12
Text to split
.IP \fBmax_split\fR 12
Maximum number of splits (optional, -1 for unlimited)
.RE
.PP
.B Returns:
Struct containing:
.RS
.IP \fBcount\fR 12
Number of parts
.IP \fB0, 1, 2...\fR 12
String parts
.RE
.PP
.B Throws:
Runtime error on invalid regex pattern
.RE
.PP
.TP
.BR regex_replace (pattern, text, replacement[, flags])
Replace pattern matches with replacement text.
.RS
.PP
.B Arguments:
.RS
.IP \fBpattern\fR 12
Regular expression pattern
.IP \fBtext\fR 12
Text to process
.IP \fBreplacement\fR 12
Replacement string
.IP \fBflags\fR 12
Optional flags string:
.RS
.IP \fBi\fR 8
Case-insensitive
.IP \fBm\fR 8
Multiline mode
.IP \fBe\fR 8
ECMAScript syntax (default)
.IP \fBa\fR 8
AWK syntax
.IP \fBg\fR 8
grep syntax
.IP \fBp\fR 8
egrep syntax
.IP \fBn\fR 8
No submatch
.IP \fBo\fR 8
Optimize
.IP \fBc\fR 8
Collate
.IP \fBf\fR 8
sed format
.IP \fBr\fR 8
No copy (only replacements)
.IP \fBd\fR 8
First only
.RE
.RE
.PP
.B Returns:
String with replacements applied
.PP
.B Throws:
Runtime error on invalid regex pattern
.RE
.SH EXAMPLES
.B Pattern Matching
.PP
.nf
.RS
include_stdregex();

var text = "Hello123";
var is_alphanumeric = regex_match(null, "[A-Za-z0-9]+", text);
puts(is_alphanumeric);  // true

var is_numeric = regex_match(null, "[0-9]+", text);
puts(is_numeric);  // false
.RE
.fi
.PP
.B Searching
.PP
.nf
.RS
var text = "The year 2026 is here";
var year = regex_search(null, "[0-9]{4}", text);
puts(year);  // "2026"

// Search in range
var partial = regex_search(null, "[0-9]+", text, 10, 15);
puts(partial);  // "20"
.RE
.fi
.PP
.B Finding All Matches
.PP
.nf
.RS
var text = "Emails: alice@example.com, bob@test.org";
var pattern = "[a-z]+@[a-z]+\\.[a-z]+";
var matches = regex_findall(null, pattern, text);

putf("Found %d emails:", matches.count);
for (var i = 0; i < matches.count; i++) {
    var match = matches.(to_string(i));
    putf("  %s at position %d", match.text, match.position);
}
.RE
.fi
.PP
.B Splitting Text
.PP
.nf
.RS
var csv = "apple,banana,cherry,date";
var parts = regex_split(null, ",", csv);

putf("Parts: %d", parts.count);
for (var i = 0; i < parts.count; i++) {
    puts(parts.(to_string(i)));
}

// Limited split
var limited = regex_split(null, ",", csv, 2);
// Results in: ["apple", "banana", "cherry,date"]
.RE
.fi
.PP
.B Text Replacement
.PP
.nf
.RS
var text = "Hello World! Hello Universe!";

// Replace all "Hello"
var result = regex_replace(null, "Hello", text, "Hi");
puts(result);  // "Hi World! Hi Universe!"

// Case-insensitive replacement
var text2 = "hello HELLO Hello";
var result2 = regex_replace(null, "hello", text2, "hi", "i");
puts(result2);  // "hi hi hi"

// Replace first only
var result3 = regex_replace(null, "Hello", text, "Hi", "d");
puts(result3);  // "Hi World! Hello Universe!"
.RE
.fi
.PP
.B Email Validation
.PP
.nf
.RS
fn is_valid_email(email) {
    var pattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
    return regex_match(null, pattern, email);
}

puts(is_valid_email("user@example.com"));  // true
puts(is_valid_email("invalid.email"));     // false
.RE
.fi
.PP
.B Phone Number Extraction
.PP
.nf
.RS
var text = "Call us at 555-1234 or 555-5678";
var pattern = "[0-9]{3}-[0-9]{4}";
var phones = regex_findall(null, pattern, text);

putf("Found %d phone numbers", phones.count);
.RE
.fi
.PP
.B HTML Tag Removal
.PP
.nf
.RS
var html = "<p>Hello <b>World</b>!</p>";
var clean = regex_replace(null, "<[^>]+>", html, "");
puts(clean);  // "Hello World!"
.RE
.fi
.PP
.B Whitespace Normalization
.PP
.nf
.RS
var text = "Too    many     spaces";
var normalized = regex_replace(null, " +", text, " ");
puts(normalized);  // "Too many spaces"
.RE
.fi
.SH REGEX SYNTAX
Phasor uses ECMAScript regex syntax by default. Common patterns:
.PP
.B Character Classes
.RS
.IP \fB.\fR 8
Any character except newline
.IP \fB\\d\fR 8
Digit [0-9]
.IP \fB\\w\fR 8
Word character [A-Za-z0-9_]
.IP \fB\\s\fR 8
Whitespace
.IP \fB[abc]\fR 8
Character set
.IP \fB[^abc]\fR 8
Negated set
.RE
.PP
.B Quantifiers
.RS
.IP \fB*\fR 8
0 or more
.IP \fB+\fR 8
1 or more
.IP \fB?\fR 8
0 or 1
.IP \fB{n}\fR 8
Exactly n
.IP \fB{n,}\fR 8
n or more
.IP \fB{n,m}\fR 8
Between n and m
.RE
.PP
.B Anchors
.RS
.IP \fB^\fR 8
Start of string
.IP \fB$\fR 8
End of string
.IP \fB\\b\fR 8
Word boundary
.RE
.SH NOTES
.IP \(bu 2
Patterns must be valid ECMAScript regular expressions
.IP \(bu 2
First argument to functions is typically null (reserved for future use)
.IP \(bu 2
Backslashes in patterns must be escaped in strings: "\\\\d" for \\d
.IP \(bu 2
Case-sensitive by default unless 'i' flag is used
.IP \(bu 2
Complex patterns may impact performance
.IP \(bu 2
Result structs use numeric string keys ("0", "1", etc.)
.SH ERROR HANDLING
All regex functions throw runtime errors on:
.IP \(bu 2
Invalid regex syntax
.IP \(bu 2
Out-of-range positions in regex_search
.IP \(bu 2
Invalid flags in regex_replace
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_str.3 ---
.TH PHASORSTD_STR 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_str \- Phasor string manipulation functions
.SH SYNOPSIS
.nf
.B using("stdstr");
.PP
.B find(string, substr[, start[, end]])
.B len(string)
.B char_at(string, index)
.B substr(string, start[, length])
.B concat(string1, string2, ...)
.B to_upper(string)
.B to_lower(string)
.B starts_with(string, prefix)
.B ends_with(string, suffix)
.PP
.B sb_new()
.B sb_append(handle, string)
.B sb_to_string(handle)
.B sb_clear(handle)
.B sb_free(handle)
.fi
.SH STRING FUNCTIONS
.TP
.BR find (string, substr[, start[, end]])
Find the first occurrence of a substring in a string.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
Input string
.IP \fBsubstr\fR 12
Substring to search for
.IP \fBstart\fR 12
Starting index (optional, defaults to 0)
.IP \fBend\fR 12
Ending index (optional, defaults to string length)
.RE
.PP
.B Returns:
Index of the first occurrence of the substring, or -1 if not found
.RE
.PP
.TP
.BR len (string)
Get the length of a string in characters.
.RS
.PP
.B Returns:
Integer length of the string
.RE
.PP
.TP
.BR char_at (string, index)
Get the character at a specific index in a string.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
Input string
.IP \fBindex\fR 12
Zero-based character index
.RE
.PP
.B Returns:
Single-character string, or empty string if index is out of bounds
.RE
.PP
.TP
.BR substr (string, start[, length])
Extract a substring from a string.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
Input string
.IP \fBstart\fR 12
Starting index (zero-based)
.IP \fBlength\fR 12
Number of characters to extract (optional, defaults to end of string)
.RE
.PP
.B Returns:
Extracted substring, or empty string if start is out of bounds
.RE
.PP
.TP
.BR concat (string1, string2, ...)
Concatenate multiple strings together.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring...\fR 12
Two or more strings to concatenate (variadic)
.RE
.PP
.B Returns:
Concatenated string
.RE
.PP
.TP
.BR to_upper (string)
Convert a string to uppercase.
.RS
.PP
.B Returns:
Uppercase version of the string
.RE
.PP
.TP
.BR to_lower (string)
Convert a string to lowercase.
.RS
.PP
.B Returns:
Lowercase version of the string
.RE
.PP
.TP
.BR starts_with (string, prefix)
Check if a string starts with a given prefix.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
String to check
.IP \fBprefix\fR 12
Prefix to match
.RE
.PP
.B Returns:
Boolean true if string starts with prefix, false otherwise
.RE
.PP
.TP
.BR ends_with (string, suffix)
Check if a string ends with a given suffix.
.RS
.PP
.B Arguments:
.RS
.IP \fBstring\fR 12
String to check
.IP \fBsuffix\fR 12
Suffix to match
.RE
.PP
.B Returns:
Boolean true if string ends with suffix, false otherwise
.RE
.SH STRINGBUILDER FUNCTIONS
StringBuilder provides efficient string concatenation for building large strings incrementally.
.TP
.BR sb_new ()
Create a new StringBuilder instance.
.RS
.PP
.B Returns:
Integer handle representing the StringBuilder
.RE
.PP
.TP
.BR sb_append (handle, string)
Append a string to a StringBuilder.
.RS
.PP
.B Arguments:
.RS
.IP \fBhandle\fR 12
StringBuilder handle from sb_new()
.IP \fBstring\fR 12
String to append
.RE
.PP
.B Returns:
The handle (for method chaining)
.RE
.PP
.TP
.BR sb_to_string (handle)
Convert a StringBuilder to a string.
.RS
.PP
.B Arguments:
.RS
.IP \fBhandle\fR 12
StringBuilder handle
.RE
.PP
.B Returns:
The complete string
.RE
.PP
.TP
.BR sb_clear (handle)
Clear the contents of a StringBuilder without freeing it.
.RS
.PP
.B Arguments:
.RS
.IP \fBhandle\fR 12
StringBuilder handle
.RE
.PP
.B Returns:
The handle (for method chaining)
.RE
.PP
.TP
.BR sb_free (handle)
Free a StringBuilder and return its contents.
.RS
.PP
.B Arguments:
.RS
.IP \fBhandle\fR 12
StringBuilder handle
.RE
.PP
.B Returns:
The final string value
.RE
.SH EXAMPLES
.B Basic String Operations
.PP
.nf
.RS
include_stdstr();

var text = "Hello, World!";
puts(len(text));              // 13
puts(char_at(text, 0));        // "H"
puts(substr(text, 7, 5));      // "World"
puts(to_upper(text));          // "HELLO, WORLD!"
puts(to_lower(text));          // "hello, world!"
.RE
.fi
.PP
.B String Checking
.PP
.nf
.RS
var filename = "document.txt";

if (ends_with(filename, ".txt")) {
    puts("Text file detected");
}

if (starts_with(filename, "doc")) {
    puts("Starts with 'doc'");
}
.RE
.fi
.PP
.B String Concatenation
.PP
.nf
.RS
var first = "Hello";
var last = "World";
var result = concat(first, ", ", last, "!");
puts(result);  // "Hello, World!"
.RE
.fi
.PP
.B StringBuilder Usage
.PP
.nf
.RS
var sb = sb_new();
sb_append(sb, "Line 1\\n");
sb_append(sb, "Line 2\\n");
sb_append(sb, "Line 3\\n");

var result = sb_to_string(sb);
puts(result);
sb_free(sb);
.RE
.fi
.PP
.B StringBuilder Chaining
.PP
.nf
.RS
var sb = sb_new();
sb_append(sb_append(sb_append(sb, "A"), "B"), "C");
puts(sb_to_string(sb));  // "ABC"
sb_free(sb);
.RE
.fi
.PP
.B Building Large Strings
.PP
.nf
.RS
var sb = sb_new();
for (var i = 0; i < 1000; i++) {
    sb_append(sb, to_string(i));
    sb_append(sb, "\\n");
}
var output = sb_free(sb);
fwrite("numbers.txt", output);
.RE
.fi
.SH NOTES
.IP \(bu 2
String indices are zero-based
.IP \(bu 2
Out-of-bounds access returns empty strings rather than throwing errors
.IP \(bu 2
StringBuilder is more efficient than repeated string concatenation
.IP \(bu 2
Always free StringBuilders with
.B sb_free()
when done to avoid memory leaks
.IP \(bu 2
StringBuilder handles are integers and can be stored in variables
.IP \(bu 2
Case conversion functions use standard C locale rules
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_sys.3 ---
.TH PHASORSTD_SYS 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_sys \- Phasor system and runtime functions
.SH SYNOPSIS
.nf
.B using("stdsys");
.PP
.B time()
.B timef(format)
.B sleep(milliseconds)
.B clear()
.B sys_os()
.B sys_env(name)
.B sys_argv([index])
.B sys_argc()
.B sys_get_memory()
.B wait_for_input()
.B sys_execute(command)
.B error(message)
.B reset()
.B shutdown(exit_code)
.fi
.SH TIME FUNCTIONS
.TP
.BR time ()
Get the current time in milliseconds since an arbitrary epoch.
.RS
.PP
.B Returns:
Float representing milliseconds
.RE
.PP
.TP
.BR timef (format)
Get the current time formatted according to a format string.
.RS
.PP
.B Arguments:
.RS
.IP \fBformat\fR 12
Format string using strftime specifiers
.RE
.PP
.B Returns:
Formatted time string
.PP
.B Format Specifiers:
.RS
.IP \fB%Y\fR 8
Year (4 digits)
.IP \fB%m\fR 8
Month (01-12)
.IP \fB%d\fR 8
Day (01-31)
.IP \fB%H\fR 8
Hour (00-23)
.IP \fB%M\fR 8
Minute (00-59)
.IP \fB%S\fR 8
Second (00-59)
.IP \fB%A\fR 8
Full weekday name
.IP \fB%B\fR 8
Full month name
.RE
.RE
.PP
.TP
.BR sleep (milliseconds)
Pause execution for a specified duration.
.RS
.PP
.B Arguments:
.RS
.IP \fBmilliseconds\fR 12
Number of milliseconds to sleep
.RE
.PP
.B Returns:
Space character string
.RE
.SH SYSTEM INFORMATION
.TP
.BR sys_os ()
Get the current operating system name.
.RS
.PP
.B Returns:
String: "win32", "Linux", "Darwin", "FreeBSD", "UNIX", or "Unknown"
.RE
.PP
.TP
.BR sys_get_memory ()
Get the available system memory in bytes.
.RS
.PP
.B Returns:
Integer bytes of available memory
.RE
.SH ENVIRONMENT AND ARGUMENTS
.TP
.BR sys_env (name)
Get an environment variable value.
.RS
.PP
.B Arguments:
.RS
.IP \fBname\fR 12
Environment variable name
.RE
.PP
.B Returns:
String value of the environment variable, or empty string if not found
.RE
.PP
.TP
.BR sys_argv ([index])
Get command-line arguments.
.RS
.PP
.B Arguments:
.RS
.IP \fBindex\fR 12
Argument index (optional)
.RE
.PP
.B Returns:
If no index provided, returns a struct with fields "arg0", "arg1", etc.
If index provided, returns the argument at that index
.RE
.PP
.TP
.BR sys_argc ()
Get the number of command-line arguments.
.RS
.PP
.B Returns:
Integer count of arguments (1 being the script/program name)
.RE
.SH CONSOLE FUNCTIONS
.TP
.BR clear ()
Clear the console screen using ANSI escape codes.
.RS
.PP
.B Returns:
Empty string
.RE
.PP
.TP
.BR wait_for_input ()
Wait for user to press Enter.
.RS
.PP
.B Returns:
Empty string
.RE
.SH PROCESS CONTROL
.TP
.BR sys_execute (command)
Execute a shell command.
.RS
.PP
.B Arguments:
.RS
.IP \fBcommand\fR 12
Shell command to execute
.RE
.PP
.B Returns:
Command exit code
.RE
.PP
.TP
.BR error (message)
Throw a runtime error and reset the VM.
.RS
.PP
.B Arguments:
.RS
.IP \fBmessage\fR 12
Error message string
.RE
.PP
.B Throws:
Runtime error with the provided message
.RE
.PP
.TP
.BR reset ()
Reset the virtual machine state.
.RS
.PP
.B Returns:
Null value
.RE
.PP
.TP
.BR shutdown (exit_code)
Shutdown the VM and exit the program.
.RS
.PP
.B Arguments:
.RS
.IP \fBexit_code\fR 12
Exit code to return to the operating system
.RE
.PP
.B Returns:
Does not return (exits program)
.RE
.SH EXAMPLES
.B Time Operations
.PP
.nf
.RS
include_stdsys();

// Get timestamp
var start = time();
// ... do work ...
var elapsed = time() - start;
putf("Elapsed: %f ms", elapsed);

// Formatted time
var timestamp = timef("%Y-%m-%d %H:%M:%S");
puts(timestamp);  // "2026-01-16 14:30:45"

// Sleep
puts("Waiting...");
sleep(1000);  // Wait 1 second
puts("Done!");
.RE
.fi
.PP
.B System Information
.PP
.nf
.RS
puts(sys_os());  // "Linux" or "win32" etc.

var mem = sys_get_memory();
putf("Available memory: %d bytes", mem);
.RE
.fi
.PP
.B Environment Variables
.PP
.nf
.RS
var home = sys_env("HOME");
putf("Home directory: %s", home);

var path = sys_env("PATH");
if (len(path) > 0) {
    puts("PATH is set");
}
.RE
.fi
.PP
.B Command-Line Arguments
.PP
.nf
.RS
var argc = sys_argc();
putf("Argument count: %d", argc);

// Access all arguments
var args = sys_argv();
for (var i = 0; i < argc; i++) {
    var key = concat("arg", to_string(i));
    puts(args.(key));
}

// Access specific argument
if (argc > 1) {
    var first_arg = sys_argv(1);
    putf("First argument: %s", first_arg);
}
.RE
.fi
.PP
.B Console Control
.PP
.nf
.RS
clear();  // Clear screen
puts("Screen cleared!");

puts("Press Enter to continue...");
wait_for_input();
.RE
.fi
.PP
.B Process Control
.PP
.nf
.RS
// Execute shell command
var result = sys_execute("ls -la");
putf("Command exit code: %d", result);

// Controlled error
if (invalid_condition) {
    error("Invalid state detected!");
}

// Exit program
if (should_exit) {
    shutdown(0);  // Exit with code 0
}
.RE
.fi
.PP
.B Benchmarking
.PP
.nf
.RS
fn benchmark(name, func) {
    var start = time();
    func();
    var elapsed = time() - start;
    putf("%s took %f ms", name, elapsed);
}

benchmark("sorting", fn() {
    // ... sorting code ...
});
.RE
.fi
.SH NOTES
.IP \(bu 2
.B time()
returns milliseconds as a float for precision
.IP \(bu 2
.B timef()
uses system localtime for formatting
.IP \(bu 2
.B sleep()
is not guaranteed to be precise on all systems
.IP \(bu 2
.B clear()
uses ANSI escape codes (may not work in all terminals)
.IP \(bu 2
.B sys_execute()
runs commands through the system shell
.IP \(bu 2
.B error()
will terminate current execution and reset the VM
.IP \(bu 2
.B shutdown()
immediately exits the program
.IP \(bu 2
Command-line arguments include the program name at index 0
.SH SECURITY CONSIDERATIONS
.IP \(bu 2
.B sys_execute()
can run arbitrary shell commands - validate input carefully
.IP \(bu 2
Environment variables may contain sensitive information
.IP \(bu 2
.B error()
and
.B shutdown()
can be used for denial of service
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man3\phasorstd_type.3 ---
.TH PHASORSTD_TYPE 3 "January 2026" "Phasor 3.0.0" "Phasor Standard Library 2.0.0"
.SH NAME
phasorstd_type \- Phasor type conversion functions
.SH SYNOPSIS
.nf
.B using("stdtype");
.PP
.B to_int(value)
.B to_float(value)
.B to_string(value)
.B to_bool(value)
.fi
.SH FUNCTIONS
.TP
.BR to_int (value)
Convert a value to an integer.
.RS
.PP
.B Arguments:
.RS
.IP \fBvalue\fR 12
Value to convert (any type)
.RE
.PP
.B Conversion Rules:
.RS
.IP \(bu 2
Integer: Returns unchanged
.IP \(bu 2
Float: Truncates to integer (rounds toward zero)
.IP \(bu 2
String: Parses as integer, returns 0 if invalid
.IP \(bu 2
Boolean: true → 1, false → 0
.IP \(bu 2
Other: Returns 0
.RE
.PP
.B Returns:
64-bit signed integer (int64)
.RE
.PP
.TP
.BR to_float (value)
Convert a value to a floating-point number.
.RS
.PP
.B Arguments:
.RS
.IP \fBvalue\fR 12
Value to convert (any type)
.RE
.PP
.B Conversion Rules:
.RS
.IP \(bu 2
Float: Returns unchanged
.IP \(bu 2
Integer: Converts to float
.IP \(bu 2
String: Parses as float
.IP \(bu 2
Boolean: true → 1.0, false → 0.0
.IP \(bu 2
Other: Implementation-defined
.RE
.PP
.B Returns:
64-bit floating-point number (double)
.RE
.PP
.TP
.BR to_string (value)
Convert a value to a string representation.
.RS
.PP
.B Arguments:
.RS
.IP \fBvalue\fR 12
Value to convert (any type)
.RE
.PP
.B Conversion Rules:
.RS
.IP \(bu 2
String: Returns unchanged
.IP \(bu 2
Integer: Decimal representation
.IP \(bu 2
Float: Decimal representation with precision
.IP \(bu 2
Boolean: "true" or "false"
.IP \(bu 2
Null: "null"
.IP \(bu 2
Struct: String representation of struct
.RE
.PP
.B Returns:
String representation of the value
.RE
.PP
.TP
.BR to_bool (value)
Convert a value to a boolean.
.RS
.PP
.B Arguments:
.RS
.IP \fBvalue\fR 12
Value to convert (any type)
.RE
.PP
.B Conversion Rules:
.RS
.IP \(bu 2
Boolean: Returns unchanged
.IP \(bu 2
Integer: 0 → false, non-zero → true
.IP \(bu 2
Float: 0.0 → false, non-zero → true
.IP \(bu 2
String: empty → false, non-empty → true
.IP \(bu 2
Null: false
.IP \(bu 2
Other: Implementation-defined
.RE
.PP
.B Returns:
Boolean true or false
.RE
.SH EXAMPLES
.B Integer Conversion
.PP
.nf
.RS
include_stdtype();

puts(to_int(42));        // 42
puts(to_int(3.14));      // 3
puts(to_int(3.99));      // 3 (truncates)
puts(to_int("123"));     // 123
puts(to_int("abc"));     // 0 (invalid)
puts(to_int(true));      // 1
puts(to_int(false));     // 0
.RE
.fi
.PP
.B Float Conversion
.PP
.nf
.RS
puts(to_float(42));      // 42.0
puts(to_float(3.14));    // 3.14
puts(to_float("2.718")); // 2.718
puts(to_float(true));    // 1.0
.RE
.fi
.PP
.B String Conversion
.PP
.nf
.RS
puts(to_string(42));     // "42"
puts(to_string(3.14));   // "3.14" or "3.140000"
puts(to_string(true));   // "true"
puts(to_string(false));  // "false"
puts(to_string(null));   // "null"

var x = 100;
var msg = concat("Value: ", to_string(x));
puts(msg);  // "Value: 100"
.RE
.fi
.PP
.B Boolean Conversion
.PP
.nf
.RS
puts(to_bool(1));        // true
puts(to_bool(0));        // false
puts(to_bool(-5));       // true
puts(to_bool(0.0));      // false
puts(to_bool(0.1));      // true
puts(to_bool(""));       // false
puts(to_bool("hello"));  // true
puts(to_bool("0"));      // true (non-empty string)
.RE
.fi
.PP
.B Parsing User Input
.PP
.nf
.RS
include_stdio();
include_stdtype();

puts("Enter a number:");
var input = gets();
var number = to_int(input);

if (number == 0 && input != "0") {
    puts("Invalid number entered");
} else {
    putf("You entered: %d", number);
}
.RE
.fi
.PP
.B Type-Safe Calculations
.PP
.nf
.RS
fn safe_divide(a, b) {
    var dividend = to_float(a);
    var divisor = to_float(b);
    
    if (divisor == 0.0) {
        error("Division by zero");
    }
    
    return dividend / divisor;
}

var result = safe_divide("10", "3");
puts(result);  // 3.333...
.RE
.fi
.PP
.B Configuration Parsing
.PP
.nf
.RS
fn parse_config(config_string) {
    // Parse "key=value" format
    var parts = regex_split(null, config_string, "=");
    var key = parts.0;
    var value_str = parts.1;
    
    // Try to convert to appropriate type
    var int_val = to_int(value_str);
    if (to_string(int_val) == value_str) {
        return int_val;  // It's an integer
    }
    
    var float_val = to_float(value_str);
    if (to_string(float_val) == value_str) {
        return float_val;  // It's a float
    }
    
    if (value_str == "true" || value_str == "false") {
        return to_bool(value_str);
    }
    
    return value_str;  // Keep as string
}
.RE
.fi
.SH NOTES
.IP \(bu 2
Integer conversion truncates floating-point values (does not round)
.IP \(bu 2
String-to-number conversion returns 0 for invalid strings
.IP \(bu 2
Boolean conversion of strings only checks if empty, not content
.IP \(bu 2
Type conversion functions never throw errors
.IP \(bu 2
Float precision may vary in string conversion
.IP \(bu 2
Very large integers may lose precision when converted to float
.SH TYPE SYSTEM
Phasor supports the following types:
.RS
.IP \(bu 2
.B null
- Null/undefined value
.IP \(bu 2
.B bool
- Boolean (true/false)
.IP \(bu 2
.B int
- 64-bit signed integer
.IP \(bu 2
.B float
- 64-bit floating-point (IEEE 754 double)
.IP \(bu 2
.B string
- UTF-8 text string
.IP \(bu 2
.B struct
- User-defined composite type
.RE
.SH BEST PRACTICES
.IP \(bu 2
Always validate converted values when parsing user input
.IP \(bu 2
Use
.B to_string()
to concatenate non-string values
.IP \(bu 2
Be aware of precision loss when converting large integers to float
.IP \(bu 2
Check for zero before division when converting strings to numbers
.IP \(bu 2
Use explicit conversion rather than relying on implicit coercion
.SH SEE ALSO
.BR Phasor_StdLib (3)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man5\man2pdf.sh ---
#!/bin/bash

files=(./*.5)
total=${#files[@]}
cpus=$(nproc)

# Progress file
progress_file=$(mktemp)
trap 'rm -f "$progress_file"' EXIT

process_file() {
    local file="$1"
    local output="${file}.pdf"
    local md5_file="${file}.md5"

    current_md5=$(md5sum "$file" | awk '{print $1}')
    prev_md5=""
    [[ -f "$md5_file" ]] && prev_md5=$(<"$md5_file")

    if [[ "$current_md5" != "$prev_md5" ]]; then
        man -l -Tpdf "$file" > "$output"
        echo "$current_md5" > "$md5_file"
        msg="Built $(basename "$output")"
    else
        msg="Skipped $(basename "$output")"
    fi

    # record completion
    echo "$msg" >> "$progress_file"
}

export -f process_file
export progress_file

# Zenity progress loop
(
    while :; do
        completed=$(wc -l < "$progress_file")
        percent=$((completed * 100 / total))

        if (( completed >= total )); then
            echo "100"
            echo "# Done"
            break
        fi

        last=$(tail -n1 "$progress_file")
        [[ -z "$last" ]] && last="Starting…"
        echo "$percent"
        echo "# $last"

        sleep 0.2
    done
) | zenity --progress \
          --title="Building PDFs" \
          --text="Starting…" \
          --percentage=0 \
          --auto-close \
          --width=450 &

zenity_pid=$!

# Start jobs with a simple job slot limiter
active=0
for file in "${files[@]}"; do
    process_file "$file" &
    active=$((active+1))
    if (( active >= cpus )); then
        wait -n
        active=$((active-1))
    fi
done

# wait for all jobs
wait

# wait for Zenity to finish
wait "$zenity_pid"


--- .\docs\man\man5\PHIR.5 ---
.TH PHIR 5 "January 2026" "Phasor 3.0.0" "Phasor File Formats"
.SH NAME
phir \- Phasor Intermediate Representation format
.SH DESCRIPTION
The
.B .phir
file format is a human-readable text-based intermediate representation of compiled Phasor bytecode. It serves as a middle ground between source code and binary bytecode, allowing developers to inspect, analyze, and manually modify compiled programs.
.PP
PHIR files are structured text documents containing serialized bytecode instructions, constant pools, variable mappings, function entries, and struct definitions. The format uses a versioned header and section-based organization.
.SH FILE STRUCTURE
A PHIR file consists of the following sections in order:
.PP
.B 1. Header
.RS
The file begins with a magic identifier and version number:
.PP
.nf
.RS
\&.PHIR 3.0.0
.RE
.fi
.RE
.PP
.B 2. Constants Section
.RS
Defines all constant values used in the program:
.PP
.nf
.RS
\&.CONSTANTS <count>
NULL
BOOL true|false
INT <integer_value>
FLOAT <float_value>
STRING "<escaped_string>"
.RE
.fi
.RE
.PP
.B 3. Variables Section
.RS
Maps variable names to their indices:
.PP
.nf
.RS
\&.VARIABLES <count> <next_index>
<name> <index>
...
.RE
.fi
.RE
.PP
.B 4. Functions Section
.RS
Maps function names to their entry point addresses:
.PP
.nf
.RS
\&.FUNCTIONS <count>
<name> <address>
...
.RE
.fi
.RE
.PP
.B 5. Structs Section
.RS
Defines struct types with their fields:
.PP
.nf
.RS
\&.STRUCTS <count>
<name> <first_const_idx> <field_count> <field1> <field2> ...
...
.RE
.fi
.RE
.PP
.B 6. Instructions Section
.RS
Contains the actual bytecode instructions:
.PP
.nf
.RS
\&.INSTRUCTIONS <count>
<opcode> [operands...]  ; optional comment
...
.RE
.fi
.RE
.SH INSTRUCTION FORMAT
Instructions follow this general format:
.PP
.nf
.RS
OPCODE [operand1[, operand2[, operand3]]]  ; comment
.RE
.fi
.PP
Operands can be:
.RS
.IP \(bu 2
Plain integers for immediate values or indices
.IP \(bu 2
Registers in the form
.B rN
where N is the register number
.IP \(bu 2
Constant pool indices
.IP \(bu 2
Variable indices
.IP \(bu 2
Function addresses
.RE
.PP
Comments are automatically generated to show:
.RS
.IP \(bu 2
Constant values for constant pool references
.IP \(bu 2
Variable names for variable indices
.IP \(bu 2
Function names for function addresses
.RE
.SH OPCODES
The PHIR format supports a comprehensive instruction set including:
.PP
.B Stack Operations
.RS
PUSH_CONST, POP, PUSH_R, POP_R, PUSH2_R, POP2_R
.RE
.PP
.B Arithmetic Operations
.RS
IADD, ISUBTRACT, IMULTIPLY, IDIVIDE, IMODULO (integer)
.br
FLADD, FLSUBTRACT, FLMULTIPLY, FLDIVIDE, FLMODULO (floating-point)
.br
Register variants: IADD_R, ISUB_R, IMUL_R, IDIV_R, IMOD_R, etc.
.RE
.PP
.B Mathematical Functions
.RS
SQRT, POW, LOG, EXP, SIN, COS, TAN
.br
Register variants: SQRT_R, POW_R, LOG_R, EXP_R, SIN_R, COS_R, TAN_R
.RE
.PP
.B Logical Operations
.RS
NOT, IAND, IOR, FLAND, FLOR, NEGATE
.br
Register variants: NOT_R, NEG_R, IAND_R, IOR_R, FLAND_R, FLOR_R
.RE
.PP
.B Comparison Operations
.RS
IEQUAL, INOT_EQUAL, ILESS_THAN, IGREATER_THAN, ILESS_EQUAL, IGREATER_EQUAL
.br
FLEQUAL, FLNOT_EQUAL, FLLESS_THAN, FLGREATER_THAN, FLLESS_EQUAL, FLGREATER_EQUAL
.br
Register variants: IEQ_R, INE_R, ILT_R, IGT_R, ILE_R, IGE_R, FLEQ_R, etc.
.RE
.PP
.B Control Flow
.RS
JUMP, JUMP_IF_FALSE, JUMP_IF_TRUE, JUMP_BACK, CALL, RETURN, HALT
.RE
.PP
.B Variable Operations
.RS
STORE_VAR, LOAD_VAR, LOAD_CONST_R, LOAD_VAR_R, STORE_VAR_R, MOV
.RE
.PP
.B I/O Operations
.RS
PRINT, PRINTERROR, READLINE, PRINT_R, PRINTERROR_R, READLINE_R
.RE
.PP
.B System Operations
.RS
CALL_NATIVE, SYSTEM, SYSTEM_R, IMPORT
.RE
.PP
.B String Operations
.RS
LEN, CHAR_AT, SUBSTR
.RE
.PP
.B Struct Operations
.RS
NEW_STRUCT, GET_FIELD, SET_FIELD, NEW_STRUCT_INSTANCE_STATIC, GET_FIELD_STATIC, SET_FIELD_STATIC
.RE
.PP
.B Constants
.RS
TRUE_P, FALSE_P, NULL_VAL
.RE
.SH STRING ESCAPING
Strings in the PHIR format use C-style escape sequences:
.RS
.IP \(bu 2
.B \en
- newline
.IP \(bu 2
.B \er
- carriage return
.IP \(bu 2
.B \et
- tab
.IP \(bu 2
.B \e\e
- backslash
.IP \(bu 2
.B \e"
- double quote
.RE
.SH EXAMPLE
A simple PHIR file:
.PP
.nf
.RS
\&.PHIR 3.0.0
\&.CONSTANTS 2
STRING "Hello, World!"
INT 42
\&.VARIABLES 1 1
x 0
\&.FUNCTIONS 1
main 0
\&.STRUCTS 0
\&.INSTRUCTIONS 5
LOAD_CONST_R r0, 0                      ; const[0]="Hello, World!"
PRINT_R r0
LOAD_CONST_R r1, 1                      ; const[1]=42
STORE_VAR_R r1, 0                       ; var=x
HALT
.RE
.fi
.SH USAGE
PHIR files can be:
.RS
.IP \(bu 2
Generated by
.BR phasorcompiler (1)
using the
.B --ir
flag
.IP \(bu 2
Manually edited for optimization or analysis
.IP \(bu 2
Used as input to
.BR phasornative (1)
for native code generation
.IP \(bu 2
Converted back to bytecode format
.RE
.SH ADVANTAGES
The PHIR format provides several benefits:
.RS
.IP \(bu 2
.B Human-readable
- Easy to inspect and understand compiled code
.IP \(bu 2
.B Editable
- Can be manually modified for optimization or debugging
.IP \(bu 2
.B Portable
- Text-based format works across platforms
.IP \(bu 2
.B Educational
- Helps understand the Phasor compilation process
.IP \(bu 2
.B Debugging
- Inline comments show variable names and constant values
.IP \(bu 2
.B Analysis
- Suitable for automated analysis tools
.RE
.SH VERSION COMPATIBILITY
The current PHIR format version is 3.0.0.
.RE
.SH SEE ALSO
.BR phasorcompiler (1),
.BR phasornative (1),
.BR phsb (5),
.BR phs (5)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man5\PHS.5 ---
.TH PHS 5 "January 2026" "Phasor 3.0.0" "Phasor File Formats"
.SH NAME
phs \- Phasor source code format
.SH DESCRIPTION
The
.B .phs
file format contains Phasor programming language source code. Phasor is a dynamically-typed scripting language with C-like syntax, supporting functions, variables, control structures, and struct types.
.PP
Source files are plain text using UTF-8 encoding and can be executed directly by
.BR phasorjit (1)
or compiled to bytecode by
.BR phasorcompiler (1).
.SH LANGUAGE OVERVIEW
Phasor is a general-purpose scripting language featuring:
.RS
.IP \(bu 2
Dynamic typing with type inference
.IP \(bu 2
Functions
.IP \(bu 2
C like syntax and control flow
.IP \(bu 2
Standard library for I O, math, and system operations
.RE
.SH SYNTAX
.SS Comments
Phasor supports single line comments:
.PP
.nf
.RS
// This is a comment
.RE
.fi
.SS Variables
Variables are declared with the
.B var
keyword and are dynamically typed:
.PP
.nf
.RS
var x = 42;
var name = "Alice";
var flag = true;
var empty = null;
.RE
.fi
.SS Data Types
Phasor supports the following data types:
.RS
.IP \(bu 2
.B null
\- Null or undefined value
.IP \(bu 2
.B bool
\- Boolean values true and false
.IP \(bu 2
.B int
\- 64 bit signed integers
.IP \(bu 2
.B float
\- 64 bit floating point numbers IEEE 754 double
.IP \(bu 2
.B string
\- UTF 8 encoded text strings
.RE
.SS Functions
Functions are declared with the
.B fn
keyword:
.PP
.nf
.RS
fn add(x: int, y: int) -> int {
    return x + y;
}

fn greet(name: string) {
    print "Hello, " + name + "!";
}
.RE
.fi
.PP
Functions without a return type implicitly return null.
.SS Control Flow
.SS If Statements
.PP
.nf
.RS
if (condition) {
    // code
} else if (other) {
    // code
} else {
    // code
}
.RE
.fi
.SS While Loops
.PP
.nf
.RS
while (condition) {
    // code
}
.RE
.fi
.SS For Loops
.PP
.nf
.RS
for (var i = 0; i < 10; i++) {
    // code
}
.RE
.fi
.SS Switch Statements
.PP
.nf
.RS
switch (value) {
    case 1:
        // code
        break;
    case 2:
        // code
        break;
    default:
        // code
}
.RE
.fi
.SS Operators
.SS Arithmetic
.RS
.IP \(bu 2
+, -, *, /, % (modulo)
.RE
.SS Comparison
.RS
.IP \(bu 2
==, !=, <, >, <=, >=
.RE
.SS Logical
.RS
.IP \(bu 2
&& (and), || (or), ! (not)
.RE
.SS Assignment
.RS
.IP \(bu 2
= (basic assignment)
.RE
.SS Unary
.RS
.IP \(bu 2
- (negate), ! (logical not)
.RE
.SS Postfix
.RS
.IP \(bu 2
++ (increment), -- (decrement)
.RE
.SH SOURCE FILE CHARACTERISTICS
.RS
.IP \(bu 2
Supports international characters in strings and comments
.IP \(bu 2
Identifiers are limited to ASCII alphanumerics and underscores
.IP \(bu 2
String literals support UTF 8 characters
.RE
.SH LINE ENDINGS
Phasor accepts any standard line ending:
.RS
.IP \(bu 2
LF (\\n) Unix/Linux/macOS
.IP \(bu 2
CRLF (\\r\\n) Windows
.IP \(bu 2
CR (\\r) macOS/OSX Legacy
.RE
.SH STYLE CONVENTIONS
While not enforced, the following conventions are recommended:
.RS
.IP \(bu 2
Use 4 spaces for indentation no tabs
.IP \(bu 2
Opening braces on the same line
.IP \(bu 2
Function names in camelCase
.IP \(bu 2
Constants in UPPER_CASE
.IP \(bu 2
Variables in camelCase
.IP \(bu 2
One statement per line
.IP \(bu 2
Blank line between function definitions
.RE
.SH COMPILATION
Source files are processed through several stages:
.RS
.IP 1.
.B Lexical Analysis
\- Source text tokenized by
.BR Lexer
.IP 2.
.B Parsing
\- Tokens converted to an Abstract Syntax Tree AST
.IP 3.
.B Code Generation
\- AST compiled to bytecode instructions
.IP 4.
.B Serialization
\- Bytecode saved to .phsb or .phir format
.RE
.SH EXECUTION MODES
Phasor source files can be executed in multiple ways:
.RS
.IP \(bu 2
.B Direct execution
\- Using
.BR phasorjit (1)
for development
.IP \(bu 2
.B Compiled execution
\- Using
.BR phasorcompiler (1)
then
.BR phasorvm (1)
for production
.IP \(bu 2
.B Native compilation
\- Using
.BR phasornative (1)
for maximum performance
.IP \(bu 2
.B Interactive
\- Using
.BR phasorrepl (1)
for experimentation
.RE
.SH LIMITATIONS
Current language limitations:
.RS
.IP \(bu 2
No operator overloading
.IP \(bu 2
No macros or metaprogramming
.IP \(bu 2
No exception handling use return values
.IP \(bu 2
No garbage collection
.IP \(bu 2
Limited standard library
.RE
.SH SEE ALSO
.BR phasorjit (1),
.BR phasorcompiler (1),
.BR phasorvm (1),
.BR phasorrepl (1),
.BR phasornative (1),
.BR phsb (5),
.BR phir (5)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man5\PHSB.5 ---
.TH PHSB 5 "January 2026" "Phasor 3.0.0" "Phasor File Formats"
.SH NAME
phsb \- Phasor Binary bytecode format
.SH DESCRIPTION
The
.B .phsb
file format is a compact binary representation of compiled Phasor bytecode. It is the standard compiled format for Phasor programs, designed for efficient loading and execution by the Phasor virtual machine.
.PP
PHSB files contain serialized bytecode instructions, constant values, variable mappings, function entry points, and struct definitions, all stored in a platform-independent binary format with checksums for integrity verification.
.SH FILE STRUCTURE
A PHSB file consists of a header followed by multiple data sections. All multi-byte integers are stored in little-endian byte order.
.PP
.B File Header (16 bytes)
.RS
.TP
.B Offset 0-3: Magic Number
4-byte magic number: 0x50485342 (ASCII: "PHSB")
.TP
.B Offset 4-7: Version
4-byte version number: 0x03000000 (version 3.0.0.0)
.TP
.B Offset 8-11: Flags
4-byte flags field (reserved for future use, currently 0)
.TP
.B Offset 12-15: Checksum
4-byte CRC32 checksum of all data following the header
.RE
.PP
.B Data Sections
.RS
Following the header are four sections, each with a section identifier byte:
.IP \(bu 2
.B 0x01
- Constants section
.IP \(bu 2
.B 0x02
- Variables section
.IP \(bu 2
.B 0x04
- Functions section
.IP \(bu 2
.B 0x03
- Instructions section
.RE
.SH CONSTANTS SECTION
The constants section stores all literal values used in the program.
.PP
.B Format:
.RS
.IP \(bu 2
Section ID: 0x01 (1 byte)
.IP \(bu 2
Count: Number of constants (4 bytes, uint32)
.IP \(bu 2
For each constant:
.RS
.IP \(bu 2
Type tag (1 byte):
.RS
.IP \- 2
.B 0x00
- Null
.IP \- 2
.B 0x01
- Boolean (followed by 1 byte: 0=false, 1=true)
.IP \- 2
.B 0x02
- Integer (followed by 8 bytes, int64, little-endian)
.IP \- 2
.B 0x03
- Float (followed by 8 bytes, IEEE 754 double, little-endian)
.IP \- 2
.B 0x04
- String (followed by 2-byte length, then UTF-8 bytes)
.RE
.RE
.RE
.SH VARIABLES SECTION
The variables section maps variable names to their runtime indices.
.PP
.B Format:
.RS
.IP \(bu 2
Section ID: 0x02 (1 byte)
.IP \(bu 2
Count: Number of variables (4 bytes, uint32)
.IP \(bu 2
Next index: Next available variable index (4 bytes, int32)
.IP \(bu 2
For each variable:
.RS
.IP \(bu 2
Name: String (2-byte length + UTF-8 bytes)
.IP \(bu 2
Index: Variable index (4 bytes, int32)
.RE
.RE
.SH FUNCTIONS SECTION
The functions section maps function names to their entry point addresses in the instruction array.
.PP
.B Format:
.RS
.IP \(bu 2
Section ID: 0x04 (1 byte)
.IP \(bu 2
Count: Number of functions (4 bytes, uint32)
.IP \(bu 2
For each function:
.RS
.IP \(bu 2
Name: String (2-byte length + UTF-8 bytes)
.IP \(bu 2
Address: Instruction index (4 bytes, int32)
.RE
.RE
.SH INSTRUCTIONS SECTION
The instructions section contains the actual bytecode program.
.PP
.B Format:
.RS
.IP \(bu 2
Section ID: 0x03 (1 byte)
.IP \(bu 2
Count: Number of instructions (4 bytes, uint32)
.IP \(bu 2
For each instruction:
.RS
.IP \(bu 2
Opcode: Operation code (1 byte, uint8)
.IP \(bu 2
Operand 1: First operand (4 bytes, int32)
.IP \(bu 2
Operand 2: Second operand (4 bytes, int32)
.IP \(bu 2
Operand 3: Third operand (4 bytes, int32)
.IP \(bu 2
Operand 4: Fourth operand (4 bytes, int32)
.IP \(bu 2
Operand 5: Fifth operand (4 bytes, int32)
.RE
.PP
Total instruction size: 21 bytes
.RE
.SH INTEGRITY VERIFICATION
The PHSB format includes integrity checking through CRC32 checksums:
.RS
.IP 1. 3
The checksum in the header covers all bytes following the 16-byte header
.IP 2. 3
The checksum uses the standard CRC32 algorithm with polynomial 0xEDB88320
.IP 3. 3
On loading, the runtime recalculates the checksum and compares it
.IP 4. 3
Mismatched checksums indicate file corruption or tampering
.RE
.SH BYTE ORDER
All multi-byte values in PHSB files use little-endian byte order, ensuring platform independence across x86, x86-64, ARM, and other little-endian architectures. Big-endian systems must perform byte swapping during deserialization.
.SH PLATFORM INDEPENDENCE
PHSB files are platform-independent:
.RS
.IP \(bu 2
No platform-specific data structures
.IP \(bu 2
Consistent byte ordering (little-endian)
.IP \(bu 2
No pointer storage or memory addresses
.IP \(bu 2
Fixed-size data types with explicit widths
.IP \(bu 2
UTF-8 encoding for all text data
.RE
.PP
A PHSB file compiled on one platform can be executed on any other platform with a compatible Phasor VM.
.SH VERSION COMPATIBILITY
The version number in the header (currently 3.0.0.0) determines compatibility:
.RS
.IP \(bu 2
The VM checks the version before loading
.IP \(bu 2
Incompatible versions are rejected with an error
.IP \(bu 2
Future versions may provide backward compatibility
.RE
.SH SIZE LIMITS
The PHSB format has the following limits:
.RS
.IP \(bu 2
Maximum constants: 4,294,967,295 (uint32 max)
.IP \(bu 2
Maximum variables: 4,294,967,295 (uint32 max)
.IP \(bu 2
Maximum functions: 4,294,967,295 (uint32 max)
.IP \(bu 2
Maximum instructions: 4,294,967,295 (uint32 max)
.IP \(bu 2
Maximum string length: 65,535 bytes (uint16 max)
.RE
.PP
In practice, these limits are far beyond typical program requirements.
.SH USAGE
PHSB files are:
.RS
.IP \(bu 2
Generated by
.BR phasorcompiler (1)
from Phasor source files
.IP \(bu 2
Executed by
.BR phasorvm (1)
for optimal performance
.IP \(bu 2
Used as distribution format for compiled programs
.IP \(bu 2
Suitable for embedded systems and constrained environments
.RE
.SH ADVANTAGES
The binary format provides:
.RS
.IP \(bu 2
.B Compact size
- Significantly smaller than text-based formats
.IP \(bu 2
.B Fast loading
- No parsing required, direct deserialization
.IP \(bu 2
.B Integrity checking
- CRC32 checksums detect corruption
.IP \(bu 2
.B Platform independence
- Runs on any system with Phasor VM
.IP \(bu 2
.B Security
- Magic numbers prevent accidental execution of non-bytecode files
.RE
.SH COMPARISON WITH PHIR
.TS
center;
cb cb
l l.
Feature	PHSB vs PHIR
_
Human-readable	No vs Yes
File size	Smaller vs Larger
Loading speed	Faster vs Slower
Editability	No vs Yes
Integrity check	Yes vs No
Comments	No vs Yes
Platform binary	No vs No
.TE
.SH SECURITY CONSIDERATIONS
While PHSB files include integrity checking, they should be treated with caution:
.RS
.IP \(bu 2
CRC32 is not cryptographically secure
.IP \(bu 2
Checksums detect corruption, not malicious modification
.IP \(bu 2
Bytecode execution can perform arbitrary operations
.IP \(bu 2
Only execute PHSB files from trusted sources
.RE
.SH SEE ALSO
.BR phasorcompiler (1),
.BR phasorvm (1),
.BR phir (5),
.BR phs (5)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man7\man2pdf.sh ---
#!/bin/bash

files=(./*.7)
total=${#files[@]}
cpus=$(nproc)

# Progress file
progress_file=$(mktemp)
trap 'rm -f "$progress_file"' EXIT

process_file() {
    local file="$1"
    local output="${file}.pdf"
    local md5_file="${file}.md5"

    current_md5=$(md5sum "$file" | awk '{print $1}')
    prev_md5=""
    [[ -f "$md5_file" ]] && prev_md5=$(<"$md5_file")

    if [[ "$current_md5" != "$prev_md5" ]]; then
        man -l -Tpdf "$file" > "$output"
        echo "$current_md5" > "$md5_file"
        msg="Built $(basename "$output")"
    else
        msg="Skipped $(basename "$output")"
    fi

    # record completion
    echo "$msg" >> "$progress_file"
}

export -f process_file
export progress_file

# Zenity progress loop
(
    while :; do
        completed=$(wc -l < "$progress_file")
        percent=$((completed * 100 / total))

        if (( completed >= total )); then
            echo "100"
            echo "# Done"
            break
        fi

        last=$(tail -n1 "$progress_file")
        [[ -z "$last" ]] && last="Starting…"
        echo "$percent"
        echo "# $last"

        sleep 0.2
    done
) | zenity --progress \
          --title="Building PDFs" \
          --text="Starting…" \
          --percentage=0 \
          --auto-close \
          --width=450 &

zenity_pid=$!

# Start jobs with a simple job slot limiter
active=0
for file in "${files[@]}"; do
    process_file "$file" &
    active=$((active+1))
    if (( active >= cpus )); then
        wait -n
        active=$((active-1))
    fi
done

# wait for all jobs
wait

# wait for Zenity to finish
wait "$zenity_pid"


--- .\docs\man\man7\phasor-ffi.7 ---
.TH PHASOR-FFI 7 "January 2026" "Phasor 3.0.0" "Phasor Foreign Function Interface"
.SH NAME
phasor-ffi \- overview of the Phasor native plugin and foreign function interface

.SH DESCRIPTION
The Phasor Foreign Function Interface (FFI) allows developers to extend the virtual machine's capabilities by loading external shared libraries (.so, .dll, or .dylib). It provides a stable, C-compatible bridge for registering native functions that can be called directly from Phasor scripts.

.SH PLUGIN ENTRY POINT
Every Phasor-compatible plugin must export a single C-linkage entry point that the VM calls upon loading.

.TP
.B void phasor_plugin_entry(const PhasorAPI* \fIapi\fR, PhasorVM* \fIvm\fR)
This function is responsible for registering native functions using the provided \fIapi\fR pointer. The \fIvm\fR pointer is an opaque handle that must be passed back to API functions.

.SH DATA TYPES
The FFI uses the \fBPhasorValue\fR struct, a tagged union representing the VM's internal types.

.SS Supported Types
.IP \(bu 2
\fBPHASOR_TYPE_NULL\fR: Represents a null value.
.IP \(bu 2
\fBPHASOR_TYPE_BOOL\fR: Boolean (\fBtrue\fR/\fBfalse\fR).
.IP \(bu 2
\fBPHASOR_TYPE_INT\fR: 64-bit signed integer.
.IP \(bu 2
\fBPHASOR_TYPE_FLOAT\fR: Double-precision floating point.
.IP \(bu 2
\fBPHASOR_TYPE_STRING\fR: C-style null-terminated string (\fBconst char*\fR).

.SH REGISTERING FUNCTIONS
To expose a C function to the VM, use the \fBregister_function\fR hook provided in the \fIPhasorAPI\fR struct.

.SS Native Function Signature
Native functions must match this prototype:
.IP
\fBPhasorValue func(PhasorVM* vm, int argc, const PhasorValue* argv);\fR

.SS Registration Example
.IP
.nf
void phasor_plugin_entry(const PhasorAPI* api, PhasorVM* vm) {
    api->register_function(vm, "my_native_func", my_native_func);
}
.fi

.SH HELPER MACROS
The \fBPhasorFFI.h\fR header provides inline helpers for creating and inspecting values:

.TP
.B phasor_make_int(\fIval\fR), phasor_make_float(\fIval\fR), ...
Wraps a raw C type into a \fBPhasorValue\fR for return to the VM.
.TP
.B phasor_is_int(\fIval\fR), phasor_is_string(\fIval\fR), ...
Checks the type tag of an incoming argument.
.TP
.B phasor_to_int(\fIval\fR), phasor_to_string(\fIval\fR), ...
Extracts the raw C value from a \fBPhasorValue\fR.

.SH MEMORY MANAGEMENT
.IP \(bu 2
\fBStrings from VM\fR: Strings passed as arguments to native functions are managed by the VM and remain valid for the duration of the function call.
.IP \(bu 2
\fBStrings to VM\fR: When a native function returns a string or passes one to the VM, the VM creates its own internal copy. The plugin remains responsible for any memory it allocated for the original string.
.IP \(bu 2
\fBStructs\fR: Complex objects and structs are not currently supported directly via the FFI.

.SH DEPLOYMENT
Plugins are scanned from the configured \fBplugin\fR directory. The VM looks for files with the following extensions:
.IP \(bu 2
\fB.so\fR (Linux/Unix)
.IP \(bu 2
\fB.dll\fR (Windows)
.IP \(bu 2
\fB.dylib\fR (macOS)
.IP \(bu 2
\fB.phsp\fR (Same as the rest, not universal)

.SH SEE ALSO
.BR Phasor_FFI (3),
.BR phasor-isa (7)

.SH AUTHOR
Daniel McGuire

.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\man\man7\phasor-isa.7 ---
.TH PHASOR-ISA 7 "January 2026" "Phasor 3.0.0" "Phasor Instruction Set 2.0"
.SH NAME
phasor-isa \- overview of the Phasor virtual machine instruction set architecture

.SH DESCRIPTION
The Phasor Instruction Set is a hybrid architecture supporting both stack-based (v1.0) and register-based (v2.0) execution models. 

The virtual machine maintains:
.IP \(bu 2
A primary data \fBstack\fR for temporary values.
.IP \(bu 2
A \fBcall stack\fR for function return addresses.
.IP \(bu 2
256 virtual \fBregisters\fR (\fBr0\fR through \fBr255\fR).
.IP \(bu 2
A global \fBvariable table\fR.

.SH STACK-BASED INSTRUCTIONS
These instructions manipulate the top of the data stack. For binary operations, the VM pops the second operand (\fIb\fR), then the first (\fIa\fR), and pushes the result.

.SS Data Movement
.TP
.B PUSH_CONST \fIindex\fR
Pushes the constant at pool \fIindex\fR onto the stack.
.TP
.B POP
Removes the top value from the stack.
.TP
.B TRUE_P, FALSE_P, NULL_VAL
Pushes literal \fBtrue\fR, \fBfalse\fR, or \fBnull\fR.

.SS Arithmetic
.IP \(bu 2
\fBIADD, ISUBTRACT, IMULTIPLY, IDIVIDE, IMODULO\fR: Integer operations.
.IP \(bu 2
\fBFLADD, FLSUBTRACT, FLMULTIPLY, FLDIVIDE, FLMODULO\fR: Float operations.
.IP \(bu 2
\fBSQRT, POW, LOG, EXP, SIN, COS, TAN\fR: Math functions.
.IP \(bu 2
\fBNEGATE\fR: Unary negation.

.SS Comparison and Logic
.IP \(bu 2
\fBIEQUAL, INOT_EQUAL, ILESS_THAN, IGREATER_THAN\fR: Integer comparisons.
.IP \(bu 2
\fBFLEQUAL, FLNOT_EQUAL, FLLESS_THAN, FLGREATER_THAN\fR: Float comparisons.
.IP \(bu 2
\fBIAND, IOR, NOT\fR: Logical operations.

.SH REGISTER-BASED INSTRUCTIONS (v2.0)
Register instructions operate on \fBr0-r255\fR. These are used for 3-address code optimizations.

.SS 3-Address Arithmetic
Format: \fBOP rA, rB, rC\fR (result \fBrA = rB op rC\fR).
.IP \(bu 2
\fBIADD_R, ISUB_R, IMUL_R, IDIV_R, IMOD_R\fR: Integer math.
.IP \(bu 2
\fBFLADD_R, FLSUB_R, FLMUL_R, FLDIV_R, FLMOD_R\fR: Float math.

.SS Register Data Movement
.TP
.B MOV \fIrA, rB\fR
Copy value from register \fBrB\fR to \fBrA\fR.
.TP
.B LOAD_CONST_R \fIrA, index\fR
Load constant pool \fIindex\fR into register \fBrA\fR.
.TP
.B LOAD_VAR_R \fIrA, index\fR
Load global variable at \fIindex\fR into \fBrA\fR.
.TP
.B STORE_VAR_R \fIrA, index\fR
Store value from \fBrA\fR into variable table at \fIindex\fR.

.SH CONTROL FLOW
.TP
.B JUMP \fIaddress\fR
Unconditional jump to instruction at \fIaddress\fR.
.TP
.B JUMP_IF_FALSE \fIaddress\fR
Pops value; jumps if value is \fBfalse\fR or \fBnull\fR.
.TP
.B JUMP_IF_TRUE \fIaddress\fR
Pops value; jumps if value is \fBtrue\fR.
.TP
.B CALL \fIindex\fR
Pushes return address and jumps to function defined at constant \fIindex\fR.
.TP
.B RETURN
Pops return address from call stack and resumes.

.SH OBJECTS AND STRUCTS
.TP
.B NEW_STRUCT \fIindex\fR
Creates an instance of the struct definition at constant \fIindex\fR.
.TP
.B GET_FIELD, SET_FIELD
Dynamic field access (uses stack for object and field name).
.TP
.B GET_FIELD_STATIC \fIindex, offset\fR
Optimized access using constant \fIindex\fR and pre-calculated \fIoffset\fR.

.SH SYSTEM AND I/O
.TP
.B PRINT
Pops value and prints to \fBstdout\fR.
.TP
.B PRINTERROR
Pops value and prints to \fBstderr\fR.
.TP
.B READLINE
Reads a line from \fBstdin\fR and pushes the string result.
.TP
.B SYSTEM
Pops a command string and executes it via the host shell.
.TP
.B HALT
Terminates the virtual machine execution.

.SH SEE ALSO
.BR phasor (3),
.BR phir (5)
.SH AUTHOR
Daniel McGuire
.SH COPYRIGHT
Copyright \(co 2026 Daniel McGuire


--- .\docs\Update-ManVersion.py ---
#!/usr/bin/env python3

import sys
import re
from pathlib import Path


def update_man_version(old_version: str, new_version: str) -> None:
    man_dir = Path("./man")
    
    if not man_dir.exists():
        print(f"Error: Directory '{man_dir}' does not exist")
        sys.exit(1)
    
    man_extensions = {".1", ".3", ".5", ".7"}
    man_files = [
        f for f in man_dir.rglob("*") 
        if f.is_file() and f.suffix in man_extensions
    ]
    
    if not man_files:
        print(f"No man page files found in {man_dir}")
        return
    
    old_version_escaped = re.escape(old_version)
    
    files_updated = 0
    for file_path in man_files:
        try:
            content = file_path.read_text(encoding='utf-8')
            updated_content = re.sub(old_version_escaped, new_version, content)
            
            if updated_content != content:
                file_path.write_text(updated_content, encoding='utf-8')
                files_updated += 1
                
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
    
    print(f"Updated all man pages from {old_version} to {new_version}")
    print(f"Files modified: {files_updated}/{len(man_files)}")


def main():
    if len(sys.argv) != 3:
        print(f"Usage: python {Path(__file__).name} <old version> <new version>")
        sys.exit(1)
    
    old_version = sys.argv[1]
    new_version = sys.argv[2]
    
    update_man_version(old_version, new_version)


if __name__ == "__main__":
    main()

--- .\Doxyfile ---
# Doxyfile 1.15.0

# This file describes the settings to be used by the documentation system
# Doxygen (www.doxygen.org) for a project.
#
# All text after a double hash (##) is considered a comment and is placed in
# front of the TAG it is preceding.
#
# All text after a single hash (#) is considered a comment and will be ignored.
# The format is:
# TAG = value [value, ...]
# For lists, items can also be appended using:
# TAG += value [value, ...]
# Values that contain spaces should be placed between quotes (\" \").
#
# Note:
#
# Use Doxygen to compare the used configuration file with the template
# configuration file:
# doxygen -x [configFile]
# Use Doxygen to compare the used configuration file with the template
# configuration file without replacing the environment variables or CMake type
# replacement variables:
# doxygen -x_noenv [configFile]

#---------------------------------------------------------------------------
# Project related configuration options
#---------------------------------------------------------------------------

# This tag specifies the encoding used for all characters in the configuration
# file that follow. The default is UTF-8 which is also the encoding used for all
# text before the first occurrence of this tag. Doxygen uses libiconv (or the
# iconv built into libc) for the transcoding. See
# https://www.gnu.org/software/libiconv/ for the list of possible encodings.
# The default value is: UTF-8.

DOXYFILE_ENCODING      = UTF-8

# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
# double-quotes, unless you are using Doxywizard) that should identify the
# project for which the documentation is generated. This name is used in the
# title of most generated pages and in a few other places.
# The default value is: My Project.

PROJECT_NAME           = Phasor

# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
# could be handy for archiving the generated documentation or if some version
# control system is used.

PROJECT_NUMBER         = 3.0.0

# Using the PROJECT_BRIEF tag one can provide an optional one line description
# for a project that appears at the top of each page and should give viewers a
# quick idea about the purpose of the project. Keep the description short.

PROJECT_BRIEF          = "Stack VM based Programming Language"

# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
# in the documentation. The maximum height of the logo should not exceed 55
# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
# the logo to the output directory.

PROJECT_LOGO           = assets/logo-tiny.png

# With the PROJECT_ICON tag one can specify an icon that is included in the tabs
# when the HTML document is shown. Doxygen will copy the logo to the output
# directory.

PROJECT_ICON           =

# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
# into which the generated documentation will be written. If a relative path is
# entered, it will be relative to the location where Doxygen was started. If
# left blank the current directory will be used.

OUTPUT_DIRECTORY       = docs

# If the CREATE_SUBDIRS tag is set to YES then Doxygen will create up to 4096
# sub-directories (in 2 levels) under the output directory of each output format
# and will distribute the generated files over these directories. Enabling this
# option can be useful when feeding Doxygen a huge amount of source files, where
# putting all generated files in the same directory would otherwise cause
# performance problems for the file system. Adapt CREATE_SUBDIRS_LEVEL to
# control the number of sub-directories.
# The default value is: NO.

CREATE_SUBDIRS         = NO

# Controls the number of sub-directories that will be created when
# CREATE_SUBDIRS tag is set to YES. Level 0 represents 16 directories, and every
# level increment doubles the number of directories, resulting in 4096
# directories at level 8 which is the default and also the maximum value. The
# sub-directories are organized in 2 levels, the first level always has a fixed
# number of 16 directories.
# Minimum value: 0, maximum value: 8, default value: 8.
# This tag requires that the tag CREATE_SUBDIRS is set to YES.

CREATE_SUBDIRS_LEVEL   = 8

# If the ALLOW_UNICODE_NAMES tag is set to YES, Doxygen will allow non-ASCII
# characters to appear in the names of generated files. If set to NO, non-ASCII
# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
# U+3044.
# The default value is: NO.

ALLOW_UNICODE_NAMES    = NO

# The OUTPUT_LANGUAGE tag is used to specify the language in which all
# documentation generated by Doxygen is written. Doxygen will use this
# information to generate all constant output in the proper language.
# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Bulgarian,
# Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, English
# (United States), Esperanto, Farsi (Persian), Finnish, French, German, Greek,
# Hindi, Hungarian, Indonesian, Italian, Japanese, Japanese-en (Japanese with
# English messages), Korean, Korean-en (Korean with English messages), Latvian,
# Lithuanian, Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese,
# Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish,
# Swedish, Turkish, Ukrainian and Vietnamese.
# The default value is: English.

OUTPUT_LANGUAGE        = English

# If the BRIEF_MEMBER_DESC tag is set to YES, Doxygen will include brief member
# descriptions after the members that are listed in the file and class
# documentation (similar to Javadoc). Set to NO to disable this.
# The default value is: YES.

BRIEF_MEMBER_DESC      = YES

# If the REPEAT_BRIEF tag is set to YES, Doxygen will prepend the brief
# description of a member or function before the detailed description
#
# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
# brief descriptions will be completely suppressed.
# The default value is: YES.

REPEAT_BRIEF           = YES

# This tag implements a quasi-intelligent brief description abbreviator that is
# used to form the text in various listings. Each string in this list, if found
# as the leading text of the brief description, will be stripped from the text
# and the result, after processing the whole list, is used as the annotated
# text. Otherwise, the brief description is used as-is. If left blank, the
# following values are used ($name is automatically replaced with the name of
# the entity):The $name class, The $name widget, The $name file, is, provides,
# specifies, contains, represents, a, an and the.

ABBREVIATE_BRIEF       = "The $name class" \
                         "The $name widget" \
                         "The $name file" \
                         is \
                         provides \
                         specifies \
                         contains \
                         represents \
                         a \
                         an \
                         the

# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
# Doxygen will generate a detailed section even if there is only a brief
# description.
# The default value is: NO.

ALWAYS_DETAILED_SEC    = NO

# If the INLINE_INHERITED_MEMB tag is set to YES, Doxygen will show all
# inherited members of a class in the documentation of that class as if those
# members were ordinary class members. Constructors, destructors and assignment
# operators of the base classes will not be shown.
# The default value is: NO.

INLINE_INHERITED_MEMB  = NO

# If the FULL_PATH_NAMES tag is set to YES, Doxygen will prepend the full path
# before files name in the file list and in the header files. If set to NO the
# shortest path that makes the file name unique will be used
# The default value is: YES.

FULL_PATH_NAMES        = YES

# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
# Stripping is only done if one of the specified strings matches the left-hand
# part of the path. The tag can be used to show relative paths in the file list.
# If left blank the directory from which Doxygen is run is used as the path to
# strip.
#
# Note that you can specify absolute paths here, but also relative paths, which
# will be relative from the directory where Doxygen is started.
# This tag requires that the tag FULL_PATH_NAMES is set to YES.

STRIP_FROM_PATH        =

# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
# path mentioned in the documentation of a class, which tells the reader which
# header file to include in order to use a class. If left blank only the name of
# the header file containing the class definition is used. Otherwise one should
# specify the list of include paths that are normally passed to the compiler
# using the -I flag.

STRIP_FROM_INC_PATH    =

# If the SHORT_NAMES tag is set to YES, Doxygen will generate much shorter (but
# less readable) file names. This can be useful if your file system doesn't
# support long names like on DOS, Mac, or CD-ROM.
# The default value is: NO.

SHORT_NAMES            = NO

# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen will interpret the
# first line (until the first dot, question mark or exclamation mark) of a
# Javadoc-style comment as the brief description. If set to NO, the Javadoc-
# style will behave just like regular Qt-style comments (thus requiring an
# explicit @brief command for a brief description.)
# The default value is: NO.

JAVADOC_AUTOBRIEF      = NO

# If the JAVADOC_BANNER tag is set to YES then Doxygen will interpret a line
# such as
# /***************
# as being the beginning of a Javadoc-style comment "banner". If set to NO, the
# Javadoc-style will behave just like regular comments and it will not be
# interpreted by Doxygen.
# The default value is: NO.

JAVADOC_BANNER         = NO

# If the QT_AUTOBRIEF tag is set to YES then Doxygen will interpret the first
# line (until the first dot, question mark or exclamation mark) of a Qt-style
# comment as the brief description. If set to NO, the Qt-style will behave just
# like regular Qt-style comments (thus requiring an explicit \brief command for
# a brief description.)
# The default value is: NO.

QT_AUTOBRIEF           = NO

# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make Doxygen treat a
# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
# a brief description. This used to be the default behavior. The new default is
# to treat a multi-line C++ comment block as a detailed description. Set this
# tag to YES if you prefer the old behavior instead.
#
# Note that setting this tag to YES also means that rational rose comments are
# not recognized any more.
# The default value is: NO.

MULTILINE_CPP_IS_BRIEF = NO

# By default Python docstrings are displayed as preformatted text and Doxygen's
# special commands cannot be used. By setting PYTHON_DOCSTRING to NO the
# Doxygen's special commands can be used and the contents of the docstring
# documentation blocks is shown as Doxygen documentation.
# The default value is: YES.

PYTHON_DOCSTRING       = YES

# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
# documentation from any documented member that it re-implements.
# The default value is: YES.

INHERIT_DOCS           = YES

# If the SEPARATE_MEMBER_PAGES tag is set to YES then Doxygen will produce a new
# page for each member. If set to NO, the documentation of a member will be part
# of the file/class/namespace that contains it.
# The default value is: NO.

SEPARATE_MEMBER_PAGES  = NO

# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
# uses this value to replace tabs by spaces in code fragments.
# Minimum value: 1, maximum value: 16, default value: 4.

TAB_SIZE               = 4

# This tag can be used to specify a number of aliases that act as commands in
# the documentation. An alias has the form:
# name=value
# For example adding
# "sideeffect=@par Side Effects:^^"
# will allow you to put the command \sideeffect (or @sideeffect) in the
# documentation, which will result in a user-defined paragraph with heading
# "Side Effects:". Note that you cannot put \n's in the value part of an alias
# to insert newlines (in the resulting output). You can put ^^ in the value part
# of an alias to insert a newline as if a physical newline was in the original
# file. When you need a literal { or } or , in the value part of an alias you
# have to escape them by means of a backslash (\), this can lead to conflicts
# with the commands \{ and \} for these it is advised to use the version @{ and
# @} or use a double escape (\\{ and \\})

ALIASES                =

# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
# only. Doxygen will then generate output that is more tailored for C. For
# instance, some of the names that are used will be different. The list of all
# members will be omitted, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_FOR_C  = NO

# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
# Python sources only. Doxygen will then generate output that is more tailored
# for that language. For instance, namespaces will be presented as packages,
# qualified scopes will look different, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_JAVA   = NO

# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
# sources. Doxygen will then generate output that is tailored for Fortran.
# The default value is: NO.

OPTIMIZE_FOR_FORTRAN   = NO

# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
# sources. Doxygen will then generate output that is tailored for VHDL.
# The default value is: NO.

OPTIMIZE_OUTPUT_VHDL   = NO

# Set the OPTIMIZE_OUTPUT_SLICE tag to YES if your project consists of Slice
# sources only. Doxygen will then generate output that is more tailored for that
# language. For instance, namespaces will be presented as modules, types will be
# separated into more groups, etc.
# The default value is: NO.

OPTIMIZE_OUTPUT_SLICE  = NO

# Doxygen selects the parser to use depending on the extension of the files it
# parses. With this tag you can assign which parser to use for a given
# extension. Doxygen has a built-in mapping, but you can override or extend it
# using this tag. The format is ext=language, where ext is a file extension, and
# language is one of the parsers supported by Doxygen: IDL, Java, JavaScript,
# Csharp (C#), C, C++, Lex, D, PHP, md (Markdown), Objective-C, Python, Slice,
# VHDL, Fortran (fixed format Fortran: FortranFixed, free formatted Fortran:
# FortranFree, unknown formatted Fortran: Fortran. In the later case the parser
# tries to guess whether the code is fixed or free formatted code, this is the
# default for Fortran type files). For instance to make Doxygen treat .inc files
# as Fortran files (default is PHP), and .f files as C (default is Fortran),
# use: inc=Fortran f=C.
#
# Note: For files without extension you can use no_extension as a placeholder.
#
# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
# the files are not read by Doxygen. When specifying no_extension you should add
# * to the FILE_PATTERNS.
#
# Note see also the list of default file extension mappings.

EXTENSION_MAPPING      =

# If the MARKDOWN_SUPPORT tag is enabled then Doxygen pre-processes all comments
# according to the Markdown format, which allows for more readable
# documentation. See https://daringfireball.net/projects/markdown/ for details.
# The output of markdown processing is further processed by Doxygen, so you can
# mix Doxygen, HTML, and XML commands with Markdown formatting. Disable only in
# case of backward compatibilities issues.
# The default value is: YES.

MARKDOWN_SUPPORT       = YES

# If the MARKDOWN_STRICT tag is enabled then Doxygen treats text in comments as
# Markdown formatted also in cases where Doxygen's native markup format
# conflicts with that of Markdown. This is only relevant in cases where
# backticks are used. Doxygen's native markup style allows a single quote to end
# a text fragment started with a backtick and then treat it as a piece of quoted
# text, whereas in Markdown such text fragment is treated as verbatim and only
# ends when a second matching backtick is found. Also, Doxygen's native markup
# format requires double quotes to be escaped when they appear in a backtick
# section, whereas this is not needed for Markdown.
# The default value is: YES.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

MARKDOWN_STRICT        = YES

# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
# to that level are automatically included in the table of contents, even if
# they do not have an id attribute.
# Note: This feature currently applies only to Markdown headings.
# Minimum value: 0, maximum value: 99, default value: 6.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

TOC_INCLUDE_HEADINGS   = 6

# The MARKDOWN_ID_STYLE tag can be used to specify the algorithm used to
# generate identifiers for the Markdown headings. Note: Every identifier is
# unique.
# Possible values are: DOXYGEN use a fixed 'autotoc_md' string followed by a
# sequence number starting at 0 and GITHUB use the lower case version of title
# with any whitespace replaced by '-' and punctuation characters removed.
# The default value is: DOXYGEN.
# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.

MARKDOWN_ID_STYLE      = DOXYGEN

# When enabled Doxygen tries to link words that correspond to documented
# classes, or namespaces to their corresponding documentation. Such a link can
# be prevented in individual cases by putting a % sign in front of the word or
# globally by setting AUTOLINK_SUPPORT to NO. Words listed in the
# AUTOLINK_IGNORE_WORDS tag are excluded from automatic linking.
# The default value is: YES.

AUTOLINK_SUPPORT       = YES

# This tag specifies a list of words that, when matching the start of a word in
# the documentation, will suppress auto links generation, if it is enabled via
# AUTOLINK_SUPPORT. This list does not affect links explicitly created using \#
# or the \link or commands.
# This tag requires that the tag AUTOLINK_SUPPORT is set to YES.

AUTOLINK_IGNORE_WORDS  =

# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
# to include (a tag file for) the STL sources as input, then you should set this
# tag to YES in order to let Doxygen match functions declarations and
# definitions whose arguments contain STL classes (e.g. func(std::string);
# versus func(std::string) {}). This also makes the inheritance and
# collaboration diagrams that involve STL classes more complete and accurate.
# The default value is: NO.

BUILTIN_STL_SUPPORT    = NO

# If you use Microsoft's C++/CLI language, you should set this option to YES to
# enable parsing support.
# The default value is: NO.

CPP_CLI_SUPPORT        = NO

# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
# https://www.riverbankcomputing.com/software) sources only. Doxygen will parse
# them like normal C++ but will assume all classes use public instead of private
# inheritance when no explicit protection keyword is present.
# The default value is: NO.

SIP_SUPPORT            = NO

# For Microsoft's IDL there are propget and propput attributes to indicate
# getter and setter methods for a property. Setting this option to YES will make
# Doxygen to replace the get and set methods by a property in the documentation.
# This will only work if the methods are indeed getting or setting a simple
# type. If this is not the case, or you want to show the methods anyway, you
# should set this option to NO.
# The default value is: YES.

IDL_PROPERTY_SUPPORT   = YES

# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
# tag is set to YES then Doxygen will reuse the documentation of the first
# member in the group (if any) for the other members of the group. By default
# all members of a group must be documented explicitly.
# The default value is: NO.

DISTRIBUTE_GROUP_DOC   = NO

# If one adds a struct or class to a group and this option is enabled, then also
# any nested class or struct is added to the same group. By default this option
# is disabled and one has to add nested compounds explicitly via \ingroup.
# The default value is: NO.

GROUP_NESTED_COMPOUNDS = NO

# Set the SUBGROUPING tag to YES to allow class member groups of the same type
# (for instance a group of public functions) to be put as a subgroup of that
# type (e.g. under the Public Functions section). Set it to NO to prevent
# subgrouping. Alternatively, this can be done per class using the
# \nosubgrouping command.
# The default value is: YES.

SUBGROUPING            = YES

# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
# are shown inside the group in which they are included (e.g. using \ingroup)
# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
# and RTF).
#
# Note that this feature does not work in combination with
# SEPARATE_MEMBER_PAGES.
# The default value is: NO.

INLINE_GROUPED_CLASSES = NO

# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
# with only public data fields or simple typedef fields will be shown inline in
# the documentation of the scope in which they are defined (i.e. file,
# namespace, or group documentation), provided this scope is documented. If set
# to NO, structs, classes, and unions are shown on a separate page (for HTML and
# Man pages) or section (for LaTeX and RTF).
# The default value is: NO.

INLINE_SIMPLE_STRUCTS  = NO

# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
# enum is documented as struct, union, or enum with the name of the typedef. So
# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
# with name TypeT. When disabled the typedef will appear as a member of a file,
# namespace, or class. And the struct will be named TypeS. This can typically be
# useful for C code in case the coding convention dictates that all compound
# types are typedef'ed and only the typedef is referenced, never the tag name.
# The default value is: NO.

TYPEDEF_HIDES_STRUCT   = NO

# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
# cache is used to resolve symbols given their name and scope. Since this can be
# an expensive process and often the same symbol appears multiple times in the
# code, Doxygen keeps a cache of pre-resolved symbols. If the cache is too small
# Doxygen will become slower. If the cache is too large, memory is wasted. The
# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
# symbols. At the end of a run Doxygen will report the cache usage and suggest
# the optimal cache size from a speed point of view.
# Minimum value: 0, maximum value: 9, default value: 0.

LOOKUP_CACHE_SIZE      = 0

# The NUM_PROC_THREADS specifies the number of threads Doxygen is allowed to use
# during processing. When set to 0 Doxygen will based this on the number of
# cores available in the system. You can set it explicitly to a value larger
# than 0 to get more control over the balance between CPU load and processing
# speed. At this moment only the input processing can be done using multiple
# threads. Since this is still an experimental feature the default is set to 1,
# which effectively disables parallel processing. Please report any issues you
# encounter. Generating dot graphs in parallel is controlled by the
# DOT_NUM_THREADS setting.
# Minimum value: 0, maximum value: 512, default value: 1.

NUM_PROC_THREADS       = 1

# If the TIMESTAMP tag is set different from NO then each generated page will
# contain the date or date and time when the page was generated. Setting this to
# NO can help when comparing the output of multiple runs.
# Possible values are: YES, NO, DATETIME and DATE.
# The default value is: NO.

TIMESTAMP              = NO

#---------------------------------------------------------------------------
# Build related configuration options
#---------------------------------------------------------------------------

# If the EXTRACT_ALL tag is set to YES, Doxygen will assume all entities in
# documentation are documented, even if no documentation was available. Private
# class members and static file members will be hidden unless the
# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
# Note: This will also disable the warnings about undocumented members that are
# normally produced when WARNINGS is set to YES.
# The default value is: NO.

EXTRACT_ALL            = YES

# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
# be included in the documentation.
# The default value is: NO.

EXTRACT_PRIVATE        = YES

# If the EXTRACT_PRIV_VIRTUAL tag is set to YES, documented private virtual
# methods of a class will be included in the documentation.
# The default value is: NO.

EXTRACT_PRIV_VIRTUAL   = YES

# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
# scope will be included in the documentation.
# The default value is: NO.

EXTRACT_PACKAGE        = NO

# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
# included in the documentation.
# The default value is: NO.

EXTRACT_STATIC         = YES

# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
# locally in source files will be included in the documentation. If set to NO,
# only classes defined in header files are included. Does not have any effect
# for Java sources.
# The default value is: YES.

EXTRACT_LOCAL_CLASSES  = YES

# This flag is only useful for Objective-C code. If set to YES, local methods,
# which are defined in the implementation section but not in the interface are
# included in the documentation. If set to NO, only methods in the interface are
# included.
# The default value is: NO.

EXTRACT_LOCAL_METHODS  = YES

# If this flag is set to YES, the members of anonymous namespaces will be
# extracted and appear in the documentation as a namespace called
# 'anonymous_namespace{file}', where file will be replaced with the base name of
# the file that contains the anonymous namespace. By default anonymous namespace
# are hidden.
# The default value is: NO.

EXTRACT_ANON_NSPACES   = NO

# If this flag is set to YES, the name of an unnamed parameter in a declaration
# will be determined by the corresponding definition. By default unnamed
# parameters remain unnamed in the output.
# The default value is: YES.

RESOLVE_UNNAMED_PARAMS = YES

# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all
# undocumented members inside documented classes or files. If set to NO these
# members will be included in the various overviews, but no documentation
# section is generated. This option has no effect if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_MEMBERS     = NO

# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all
# undocumented classes that are normally visible in the class hierarchy. If set
# to NO, these classes will be included in the various overviews. This option
# will also hide undocumented C++ concepts if enabled. This option has no effect
# if EXTRACT_ALL is enabled.
# The default value is: NO.

HIDE_UNDOC_CLASSES     = NO

# If the HIDE_UNDOC_NAMESPACES tag is set to YES, Doxygen will hide all
# undocumented namespaces that are normally visible in the namespace hierarchy.
# If set to NO, these namespaces will be included in the various overviews. This
# option has no effect if EXTRACT_ALL is enabled.
# The default value is: YES.

HIDE_UNDOC_NAMESPACES  = YES

# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, Doxygen will hide all friend
# declarations. If set to NO, these declarations will be included in the
# documentation.
# The default value is: NO.

HIDE_FRIEND_COMPOUNDS  = NO

# If the HIDE_IN_BODY_DOCS tag is set to YES, Doxygen will hide any
# documentation blocks found inside the body of a function. If set to NO, these
# blocks will be appended to the function's detailed documentation block.
# The default value is: NO.

HIDE_IN_BODY_DOCS      = NO

# The INTERNAL_DOCS tag determines if documentation that is typed after a
# \internal command is included. If the tag is set to NO then the documentation
# will be excluded. Set it to YES to include the internal documentation.
# The default value is: NO.

INTERNAL_DOCS          = YES

# With the correct setting of option CASE_SENSE_NAMES Doxygen will better be
# able to match the capabilities of the underlying filesystem. In case the
# filesystem is case sensitive (i.e. it supports files in the same directory
# whose names only differ in casing), the option must be set to YES to properly
# deal with such files in case they appear in the input. For filesystems that
# are not case sensitive the option should be set to NO to properly deal with
# output files written for symbols that only differ in casing, such as for two
# classes, one named CLASS and the other named Class, and to also support
# references to files without having to specify the exact matching casing. On
# Windows (including Cygwin) and macOS, users should typically set this option
# to NO, whereas on Linux or other Unix flavors it should typically be set to
# YES.
# Possible values are: SYSTEM, NO and YES.
# The default value is: SYSTEM.

CASE_SENSE_NAMES       = SYSTEM

# If the HIDE_SCOPE_NAMES tag is set to NO then Doxygen will show members with
# their full class and namespace scopes in the documentation. If set to YES, the
# scope will be hidden.
# The default value is: NO.

HIDE_SCOPE_NAMES       = NO

# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then Doxygen will
# append additional text to a page's title, such as Class Reference. If set to
# YES the compound reference will be hidden.
# The default value is: NO.

HIDE_COMPOUND_REFERENCE= NO

# If the SHOW_HEADERFILE tag is set to YES then the documentation for a class
# will show which file needs to be included to use the class.
# The default value is: YES.

SHOW_HEADERFILE        = YES

# If the SHOW_INCLUDE_FILES tag is set to YES then Doxygen will put a list of
# the files that are included by a file in the documentation of that file.
# The default value is: YES.

SHOW_INCLUDE_FILES     = YES

# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
# grouped member an include statement to the documentation, telling the reader
# which file to include in order to use the member.
# The default value is: NO.

SHOW_GROUPED_MEMB_INC  = NO

# If the FORCE_LOCAL_INCLUDES tag is set to YES then Doxygen will list include
# files with double quotes in the documentation rather than with sharp brackets.
# The default value is: NO.

FORCE_LOCAL_INCLUDES   = NO

# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
# documentation for inline members.
# The default value is: YES.

INLINE_INFO            = YES

# If the SORT_MEMBER_DOCS tag is set to YES then Doxygen will sort the
# (detailed) documentation of file and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order.
# The default value is: YES.

SORT_MEMBER_DOCS       = YES

# If the SORT_BRIEF_DOCS tag is set to YES then Doxygen will sort the brief
# descriptions of file, namespace and class members alphabetically by member
# name. If set to NO, the members will appear in declaration order. Note that
# this will also influence the order of the classes in the class list.
# The default value is: NO.

SORT_BRIEF_DOCS        = NO

# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then Doxygen will sort the
# (brief and detailed) documentation of class members so that constructors and
# destructors are listed first. If set to NO the constructors will appear in the
# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
# member documentation.
# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
# detailed member documentation.
# The default value is: NO.

SORT_MEMBERS_CTORS_1ST = NO

# If the SORT_GROUP_NAMES tag is set to YES then Doxygen will sort the hierarchy
# of group names into alphabetical order. If set to NO the group names will
# appear in their defined order.
# The default value is: NO.

SORT_GROUP_NAMES       = NO

# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
# fully-qualified names, including namespaces. If set to NO, the class list will
# be sorted only by class name, not including the namespace part.
# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
# Note: This option applies only to the class list, not to the alphabetical
# list.
# The default value is: NO.

SORT_BY_SCOPE_NAME     = NO

# If the STRICT_PROTO_MATCHING option is enabled and Doxygen fails to do proper
# type resolution of all parameters of a function it will reject a match between
# the prototype and the implementation of a member function even if there is
# only one candidate or it is obvious which candidate to choose by doing a
# simple string match. By disabling STRICT_PROTO_MATCHING Doxygen will still
# accept a match between prototype and implementation in such cases.
# The default value is: NO.

STRICT_PROTO_MATCHING  = NO

# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
# list. This list is created by putting \todo commands in the documentation.
# The default value is: YES.

GENERATE_TODOLIST      = YES

# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
# list. This list is created by putting \test commands in the documentation.
# The default value is: YES.

GENERATE_TESTLIST      = YES

# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
# list. This list is created by putting \bug commands in the documentation.
# The default value is: YES.

GENERATE_BUGLIST       = YES

# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
# the deprecated list. This list is created by putting \deprecated commands in
# the documentation.
# The default value is: YES.

GENERATE_DEPRECATEDLIST= YES

# The ENABLED_SECTIONS tag can be used to enable conditional documentation
# sections, marked by \if <section_label> ... \endif and \cond <section_label>
# ... \endcond blocks.

ENABLED_SECTIONS       =

# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
# initial value of a variable or macro / define can have for it to appear in the
# documentation. If the initializer consists of more lines than specified here
# it will be hidden. Use a value of 0 to hide initializers completely. The
# appearance of the value of individual variables and macros / defines can be
# controlled using \showinitializer or \hideinitializer command in the
# documentation regardless of this setting.
# Minimum value: 0, maximum value: 10000, default value: 30.

MAX_INITIALIZER_LINES  = 30

# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
# the bottom of the documentation of classes and structs. If set to YES, the
# list will mention the files that were used to generate the documentation.
# The default value is: YES.

SHOW_USED_FILES        = YES

# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
# will remove the Files entry from the Quick Index and from the Folder Tree View
# (if specified).
# The default value is: YES.

SHOW_FILES             = YES

# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
# page. This will remove the Namespaces entry from the Quick Index and from the
# Folder Tree View (if specified).
# The default value is: YES.

SHOW_NAMESPACES        = YES

# The FILE_VERSION_FILTER tag can be used to specify a program or script that
# Doxygen should invoke to get the current version for each file (typically from
# the version control system). Doxygen will invoke the program by executing (via
# popen()) the command command input-file, where command is the value of the
# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
# by Doxygen. Whatever the program writes to standard output is used as the file
# version. For an example see the documentation.

FILE_VERSION_FILTER    =

# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
# by Doxygen. The layout file controls the global structure of the generated
# output files in an output format independent way. To create the layout file
# that represents Doxygen's defaults, run Doxygen with the -l option. You can
# optionally specify a file name after the option, if omitted DoxygenLayout.xml
# will be used as the name of the layout file. See also section "Changing the
# layout of pages" for information.
#
# Note that if you run Doxygen from a directory containing a file called
# DoxygenLayout.xml, Doxygen will parse it automatically even if the LAYOUT_FILE
# tag is left empty.

LAYOUT_FILE            =

# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
# the reference definitions. This must be a list of .bib files. The .bib
# extension is automatically appended if omitted. This requires the bibtex tool
# to be installed. See also https://en.wikipedia.org/wiki/BibTeX for more info.
# For LaTeX the style of the bibliography can be controlled using
# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
# search path. See also \cite for info how to create references.

CITE_BIB_FILES         =

# The EXTERNAL_TOOL_PATH tag can be used to extend the search path (PATH
# environment variable) so that external tools such as latex and gs can be
# found.
# Note: Directories specified with EXTERNAL_TOOL_PATH are added in front of the
# path already specified by the PATH variable, and are added in the order
# specified.
# Note: This option is particularly useful for macOS version 14 (Sonoma) and
# higher, when running Doxygen from Doxywizard, because in this case any user-
# defined changes to the PATH are ignored. A typical example on macOS is to set
# EXTERNAL_TOOL_PATH = /Library/TeX/texbin /usr/local/bin
# together with the standard path, the full search path used by doxygen when
# launching external tools will then become
# PATH=/Library/TeX/texbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

EXTERNAL_TOOL_PATH     =

#---------------------------------------------------------------------------
# Configuration options related to warning and progress messages
#---------------------------------------------------------------------------

# The QUIET tag can be used to turn on/off the messages that are generated to
# standard output by Doxygen. If QUIET is set to YES this implies that the
# messages are off.
# The default value is: NO.

QUIET                  = NO

# The WARNINGS tag can be used to turn on/off the warning messages that are
# generated to standard error (stderr) by Doxygen. If WARNINGS is set to YES
# this implies that the warnings are on.
#
# Tip: Turn warnings on while writing the documentation.
# The default value is: YES.

WARNINGS               = YES

# If the WARN_IF_UNDOCUMENTED tag is set to YES then Doxygen will generate
# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: YES.

WARN_IF_UNDOCUMENTED   = YES

# If the WARN_IF_DOC_ERROR tag is set to YES, Doxygen will generate warnings for
# potential errors in the documentation, such as documenting some parameters in
# a documented function twice, or documenting parameters that don't exist or
# using markup commands wrongly.
# The default value is: YES.

WARN_IF_DOC_ERROR      = YES

# If WARN_IF_INCOMPLETE_DOC is set to YES, Doxygen will warn about incomplete
# function parameter documentation. If set to NO, Doxygen will accept that some
# parameters have no documentation without warning.
# The default value is: YES.

WARN_IF_INCOMPLETE_DOC = YES

# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
# are documented, but have no documentation for their parameters or return
# value. If set to NO, Doxygen will only warn about wrong parameter
# documentation, but not about the absence of documentation. If EXTRACT_ALL is
# set to YES then this flag will automatically be disabled. See also
# WARN_IF_INCOMPLETE_DOC
# The default value is: NO.

WARN_NO_PARAMDOC       = NO

# If WARN_IF_UNDOC_ENUM_VAL option is set to YES, Doxygen will warn about
# undocumented enumeration values. If set to NO, Doxygen will accept
# undocumented enumeration values. If EXTRACT_ALL is set to YES then this flag
# will automatically be disabled.
# The default value is: NO.

WARN_IF_UNDOC_ENUM_VAL = NO

# If WARN_LAYOUT_FILE option is set to YES, Doxygen will warn about issues found
# while parsing the user defined layout file, such as missing or wrong elements.
# See also LAYOUT_FILE for details. If set to NO, problems with the layout file
# will be suppressed.
# The default value is: YES.

WARN_LAYOUT_FILE       = YES

# If the WARN_AS_ERROR tag is set to YES then Doxygen will immediately stop when
# a warning is encountered. If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS
# then Doxygen will continue running as if WARN_AS_ERROR tag is set to NO, but
# at the end of the Doxygen process Doxygen will return with a non-zero status.
# If the WARN_AS_ERROR tag is set to FAIL_ON_WARNINGS_PRINT then Doxygen behaves
# like FAIL_ON_WARNINGS but in case no WARN_LOGFILE is defined Doxygen will not
# write the warning messages in between other messages but write them at the end
# of a run, in case a WARN_LOGFILE is defined the warning messages will be
# besides being in the defined file also be shown at the end of a run, unless
# the WARN_LOGFILE is defined as - i.e. standard output (stdout) in that case
# the behavior will remain as with the setting FAIL_ON_WARNINGS.
# Possible values are: NO, YES, FAIL_ON_WARNINGS and FAIL_ON_WARNINGS_PRINT.
# The default value is: NO.

WARN_AS_ERROR          = NO

# The WARN_FORMAT tag determines the format of the warning messages that Doxygen
# can produce. The string should contain the $file, $line, and $text tags, which
# will be replaced by the file and line number from which the warning originated
# and the warning text. Optionally the format may contain $version, which will
# be replaced by the version of the file (if it could be obtained via
# FILE_VERSION_FILTER)
# See also: WARN_LINE_FORMAT
# The default value is: $file:$line: $text.

WARN_FORMAT            = "$file:$line: $text"

# In the $text part of the WARN_FORMAT command it is possible that a reference
# to a more specific place is given. To make it easier to jump to this place
# (outside of Doxygen) the user can define a custom "cut" / "paste" string.
# Example:
# WARN_LINE_FORMAT = "'vi $file +$line'"
# See also: WARN_FORMAT
# The default value is: at line $line of file $file.

WARN_LINE_FORMAT       = "at line $line of file $file"

# The WARN_LOGFILE tag can be used to specify a file to which warning and error
# messages should be written. If left blank the output is written to standard
# error (stderr). In case the file specified cannot be opened for writing the
# warning and error messages are written to standard error. When as file - is
# specified the warning and error messages are written to standard output
# (stdout).

WARN_LOGFILE           =

#---------------------------------------------------------------------------
# Configuration options related to the input files
#---------------------------------------------------------------------------

# The INPUT tag is used to specify the files and/or directories that contain
# documented source files. You may enter file names like myfile.cpp or
# directories like /usr/src/myproject. Separate the files or directories with
# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
# Note: If this tag is empty the current directory is searched.

INPUT                  = src \
                         include

# This tag can be used to specify the character encoding of the source files
# that Doxygen parses. Internally Doxygen uses the UTF-8 encoding. Doxygen uses
# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
# documentation (see:
# https://www.gnu.org/software/libiconv/) for the list of possible encodings.
# See also: INPUT_FILE_ENCODING
# The default value is: UTF-8.

INPUT_ENCODING         = UTF-8

# This tag can be used to specify the character encoding of the source files
# that Doxygen parses. The INPUT_FILE_ENCODING tag can be used to specify
# character encoding on a per file pattern basis. Doxygen will compare the file
# name with each pattern and apply the encoding instead of the default
# INPUT_ENCODING if there is a match. The character encodings are a list of the
# form: pattern=encoding (like *.php=ISO-8859-1).
# See also: INPUT_ENCODING for further information on supported encodings.

INPUT_FILE_ENCODING    =

# If the value of the INPUT tag contains directories, you can use the
# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
# *.h) to filter out the source-files in the directories.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# read by Doxygen.
#
# Note the list of default checked file patterns might differ from the list of
# default file extension mappings.
#
# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cxxm,
# *.cpp, *.cppm, *.ccm, *.c++, *.c++m, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl,
# *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp, *.h++, *.l, *.cs, *.d, *.php,
# *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown, *.md, *.mm, *.dox (to be
# provided as Doxygen C comment), *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
# *.f18, *.f, *.for, *.vhd, *.vhdl, *.ucf, *.qsf and *.ice.

FILE_PATTERNS          = *.c \
                         *.cc \
                         *.cxx \
                         *.cxxm \
                         *.cpp \
                         *.cppm \
                         *.ccm \
                         *.c++ \
                         *.c++m \
                         *.java \
                         *.ii \
                         *.ixx \
                         *.ipp \
                         *.i++ \
                         *.inl \
                         *.idl \
                         *.ddl \
                         *.odl \
                         *.h \
                         *.hh \
                         *.hxx \
                         *.hpp \
                         *.h++ \
                         *.l \
                         *.cs \
                         *.d \
                         *.php \
                         *.php4 \
                         *.php5 \
                         *.phtml \
                         *.inc \
                         *.m \
                         *.markdown \
                         *.md \
                         *.mm \
                         *.dox \
                         *.py \
                         *.pyw \
                         *.f90 \
                         *.f95 \
                         *.f03 \
                         *.f08 \
                         *.f18 \
                         *.f \
                         *.for \
                         *.vhd \
                         *.vhdl \
                         *.ucf \
                         *.qsf \
                         *.ice \
                         *.phs

# The RECURSIVE tag can be used to specify whether or not subdirectories should
# be searched for input files as well.
# The default value is: NO.

RECURSIVE              = YES

# The EXCLUDE tag can be used to specify files and/or directories that should be
# excluded from the INPUT source files. This way you can easily exclude a
# subdirectory from a directory tree whose root is specified with the INPUT tag.
#
# Note that relative paths are relative to the directory from which Doxygen is
# run.

EXCLUDE                =

# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
# directories that are symbolic links (a Unix file system feature) are excluded
# from the input.
# The default value is: NO.

EXCLUDE_SYMLINKS       = NO

# If the value of the INPUT tag contains directories, you can use the
# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
# certain files from those directories.
#
# Note that the wildcards are matched against the file with absolute path, so to
# exclude all test directories for example use the pattern */test/*

EXCLUDE_PATTERNS       =

# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
# (namespaces, classes, functions, etc.) that should be excluded from the
# output. The symbol name can be a fully qualified name, a word, or if the
# wildcard * is used, a substring. Examples: ANamespace, AClass,
# ANamespace::AClass, ANamespace::*Test

EXCLUDE_SYMBOLS        =

# The EXAMPLE_PATH tag can be used to specify one or more files or directories
# that contain example code fragments that are included (see the \include
# command).

EXAMPLE_PATH           =

# If the value of the EXAMPLE_PATH tag contains directories, you can use the
# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
# *.h) to filter out the source-files in the directories. If left blank all
# files are included.

EXAMPLE_PATTERNS       = *

# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
# searched for input files to be used with the \include or \dontinclude commands
# irrespective of the value of the RECURSIVE tag.
# The default value is: NO.

EXAMPLE_RECURSIVE      = NO

# The IMAGE_PATH tag can be used to specify one or more files or directories
# that contain images that are to be included in the documentation (see the
# \image command).

IMAGE_PATH             =

# The INPUT_FILTER tag can be used to specify a program that Doxygen should
# invoke to filter for each input file. Doxygen will invoke the filter program
# by executing (via popen()) the command:
#
# <filter> <input-file>
#
# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
# name of an input file. Doxygen will then use the output that the filter
# program writes to standard output. If FILTER_PATTERNS is specified, this tag
# will be ignored.
#
# Note that the filter must not add or remove lines; it is applied before the
# code is scanned, but not when the output code is generated. If lines are added
# or removed, the anchors will not be placed correctly.
#
# Note that Doxygen will use the data processed and written to standard output
# for further processing, therefore nothing else, like debug statements or used
# commands (so in case of a Windows batch file always use @echo OFF), should be
# written to standard output.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by Doxygen.

INPUT_FILTER           =

# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
# basis. Doxygen will compare the file name with each pattern and apply the
# filter if there is a match. The filters are a list of the form: pattern=filter
# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
# patterns match the file name, INPUT_FILTER is applied.
#
# Note that for custom extensions or not directly supported extensions you also
# need to set EXTENSION_MAPPING for the extension otherwise the files are not
# properly processed by Doxygen.

FILTER_PATTERNS        =

# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
# INPUT_FILTER) will also be used to filter the input files that are used for
# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
# The default value is: NO.

FILTER_SOURCE_FILES    = NO

# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
# it is also possible to disable source filtering for a specific pattern using
# *.ext= (so without naming a filter).
# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.

FILTER_SOURCE_PATTERNS =

# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
# is part of the input, its contents will be placed on the main page
# (index.html). This can be useful if you have a project on for instance GitHub
# and want to reuse the introduction page also for the Doxygen output.

USE_MDFILE_AS_MAINPAGE =

# If the IMPLICIT_DIR_DOCS tag is set to YES, any README.md file found in sub-
# directories of the project's root, is used as the documentation for that sub-
# directory, except when the README.md starts with a \dir, \page or \mainpage
# command. If set to NO, the README.md file needs to start with an explicit \dir
# command in order to be used as directory documentation.
# The default value is: YES.

IMPLICIT_DIR_DOCS      = YES

# The Fortran standard specifies that for fixed formatted Fortran code all
# characters from position 72 are to be considered as comment. A common
# extension is to allow longer lines before the automatic comment starts. The
# setting FORTRAN_COMMENT_AFTER will also make it possible that longer lines can
# be processed before the automatic comment starts.
# Minimum value: 7, maximum value: 10000, default value: 72.

FORTRAN_COMMENT_AFTER  = 72

#---------------------------------------------------------------------------
# Configuration options related to source browsing
#---------------------------------------------------------------------------

# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
# generated. Documented entities will be cross-referenced with these sources.
#
# Note: To get rid of all source code in the generated output, make sure that
# also VERBATIM_HEADERS is set to NO.
# The default value is: NO.

SOURCE_BROWSER         = YES

# Setting the INLINE_SOURCES tag to YES will include the body of functions,
# multi-line macros, enums or list initialized variables directly into the
# documentation.
# The default value is: NO.

INLINE_SOURCES         = NO

# Setting the STRIP_CODE_COMMENTS tag to YES will instruct Doxygen to hide any
# special comment blocks from generated source code fragments. Normal C, C++ and
# Fortran comments will always remain visible.
# The default value is: YES.

STRIP_CODE_COMMENTS    = YES

# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
# entity all documented functions referencing it will be listed.
# The default value is: NO.

REFERENCED_BY_RELATION = NO

# If the REFERENCES_RELATION tag is set to YES then for each documented function
# all documented entities called/used by that function will be listed.
# The default value is: NO.

REFERENCES_RELATION    = NO

# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
# to YES then the hyperlinks from functions in REFERENCES_RELATION and
# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
# link to the documentation.
# The default value is: YES.

REFERENCES_LINK_SOURCE = YES

# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
# source code will show a tooltip with additional information such as prototype,
# brief description and links to the definition and documentation. Since this
# will make the HTML file larger and loading of large files a bit slower, you
# can opt to disable this feature.
# The default value is: YES.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

SOURCE_TOOLTIPS        = YES

# If the USE_HTAGS tag is set to YES then the references to source code will
# point to the HTML generated by the htags(1) tool instead of Doxygen built-in
# source browser. The htags tool is part of GNU's global source tagging system
# (see https://www.gnu.org/software/global/global.html). You will need version
# 4.8.6 or higher.
#
# To use it do the following:
# - Install the latest version of global
# - Enable SOURCE_BROWSER and USE_HTAGS in the configuration file
# - Make sure the INPUT points to the root of the source tree
# - Run doxygen as normal
#
# Doxygen will invoke htags (and that will in turn invoke gtags), so these
# tools must be available from the command line (i.e. in the search path).
#
# The result: instead of the source browser generated by Doxygen, the links to
# source code will now point to the output of htags.
# The default value is: NO.
# This tag requires that the tag SOURCE_BROWSER is set to YES.

USE_HTAGS              = NO

# If the VERBATIM_HEADERS tag is set the YES then Doxygen will generate a
# verbatim copy of the header file for each class for which an include is
# specified. Set to NO to disable this.
# See also: Section \class.
# The default value is: YES.

VERBATIM_HEADERS       = YES

# If the CLANG_ASSISTED_PARSING tag is set to YES then Doxygen will use the
# clang parser (see:
# http://clang.llvm.org/) for more accurate parsing at the cost of reduced
# performance. This can be particularly helpful with template rich C++ code for
# which Doxygen's built-in parser lacks the necessary type information.
# Note: The availability of this option depends on whether or not Doxygen was
# generated with the -Duse_libclang=ON option for CMake.
# The default value is: NO.

CLANG_ASSISTED_PARSING = NO

# If the CLANG_ASSISTED_PARSING tag is set to YES and the CLANG_ADD_INC_PATHS
# tag is set to YES then Doxygen will add the directory of each input to the
# include path.
# The default value is: YES.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_ADD_INC_PATHS    = YES

# If clang assisted parsing is enabled you can provide the compiler with command
# line options that you would normally use when invoking the compiler. Note that
# the include paths will already be set by Doxygen for the files and directories
# specified with INPUT and INCLUDE_PATH.
# This tag requires that the tag CLANG_ASSISTED_PARSING is set to YES.

CLANG_OPTIONS          =

# If clang assisted parsing is enabled you can provide the clang parser with the
# path to the directory containing a file called compile_commands.json. This
# file is the compilation database (see:
# http://clang.llvm.org/docs/HowToSetupToolingForLLVM.html) containing the
# options used when the source files were built. This is equivalent to
# specifying the -p option to a clang tool, such as clang-check. These options
# will then be passed to the parser. Any options specified with CLANG_OPTIONS
# will be added as well.
# Note: The availability of this option depends on whether or not Doxygen was
# generated with the -Duse_libclang=ON option for CMake.

CLANG_DATABASE_PATH    =

#---------------------------------------------------------------------------
# Configuration options related to the alphabetical class index
#---------------------------------------------------------------------------

# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
# compounds will be generated. Enable this if the project contains a lot of
# classes, structs, unions or interfaces.
# The default value is: YES.

ALPHABETICAL_INDEX     = YES

# The IGNORE_PREFIX tag can be used to specify a prefix (or a list of prefixes)
# that should be ignored while generating the index headers. The IGNORE_PREFIX
# tag works for classes, function and member names. The entity will be placed in
# the alphabetical list under the first letter of the entity name that remains
# after removing the prefix.
# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.

IGNORE_PREFIX          =

#---------------------------------------------------------------------------
# Configuration options related to the HTML output
#---------------------------------------------------------------------------

# If the GENERATE_HTML tag is set to YES, Doxygen will generate HTML output
# The default value is: YES.

GENERATE_HTML          = YES

# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_OUTPUT            = html

# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
# generated HTML page (for example: .htm, .php, .asp).
# The default value is: .html.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FILE_EXTENSION    = .html

# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
# each generated HTML page. If the tag is left blank Doxygen will generate a
# standard header.
#
# To get valid HTML the header file that includes any scripts and style sheets
# that Doxygen needs, which is dependent on the configuration options used (e.g.
# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
# default header using
# doxygen -w html new_header.html new_footer.html new_stylesheet.css
# YourConfigFile
# and then modify the file new_header.html. See also section "Doxygen usage"
# for information on how to generate the default header that Doxygen normally
# uses.
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of Doxygen. For a description
# of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_HEADER            =

# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
# generated HTML page. If the tag is left blank Doxygen will generate a standard
# footer. See HTML_HEADER for more information on how to generate a default
# footer and what special commands can be used inside the footer. See also
# section "Doxygen usage" for information on how to generate the default footer
# that Doxygen normally uses.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FOOTER            =

# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
# sheet that is used by each HTML page. It can be used to fine-tune the look of
# the HTML output. If left blank Doxygen will generate a default style sheet.
# See also section "Doxygen usage" for information on how to generate the style
# sheet that Doxygen normally uses.
# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
# it is more robust and this tag (HTML_STYLESHEET) will in the future become
# obsolete.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_STYLESHEET        =

# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# cascading style sheets that are included after the standard style sheets
# created by Doxygen. Using this option one can overrule certain style aspects.
# This is preferred over using HTML_STYLESHEET since it does not replace the
# standard style sheet and is therefore more robust against future updates.
# Doxygen will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# Note: Since the styling of scrollbars can currently not be overruled in
# Webkit/Chromium, the styling will be left out of the default doxygen.css if
# one or more extra stylesheets have been specified. So if scrollbar
# customization is desired it has to be added explicitly. For an example see the
# documentation.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_STYLESHEET  =

# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the HTML output directory. Note
# that these files will be copied to the base HTML output directory. Use the
# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
# files will be copied as-is; there are no commands or markers available.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_EXTRA_FILES       =

# The HTML_COLORSTYLE tag can be used to specify if the generated HTML output
# should be rendered with a dark or light theme.
# Possible values are: LIGHT always generates light mode output, DARK always
# generates dark mode output, AUTO_LIGHT automatically sets the mode according
# to the user preference, uses light mode if no preference is set (the default),
# AUTO_DARK automatically sets the mode according to the user preference, uses
# dark mode if no preference is set and TOGGLE allows a user to switch between
# light and dark mode via a button.
# The default value is: AUTO_LIGHT.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE        = AUTO_LIGHT

# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
# will adjust the colors in the style sheet and background images according to
# this color. Hue is specified as an angle on a color-wheel, see
# https://en.wikipedia.org/wiki/Hue for more information. For instance the value
# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
# purple, and 360 is red again.
# Minimum value: 0, maximum value: 359, default value: 220.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_HUE    = 220

# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
# in the HTML output. For a value of 0 the output will use gray-scales only. A
# value of 255 will produce the most vivid colors.
# Minimum value: 0, maximum value: 255, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_SAT    = 100

# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
# luminance component of the colors in the HTML output. Values below 100
# gradually make the output lighter, whereas values above 100 make the output
# darker. The value divided by 100 is the actual gamma applied, so 80 represents
# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
# change the gamma.
# Minimum value: 40, maximum value: 240, default value: 80.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COLORSTYLE_GAMMA  = 80

# If the HTML_DYNAMIC_MENUS tag is set to YES then the generated HTML
# documentation will contain a main index with vertical navigation menus that
# are dynamically created via JavaScript. If disabled, the navigation index will
# consists of multiple levels of tabs that are statically embedded in every HTML
# page. Disable this option to support browsers that do not have JavaScript,
# like the Qt help browser.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_MENUS     = YES

# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
# documentation will contain sections that can be hidden and shown after the
# page has loaded.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_DYNAMIC_SECTIONS  = NO

# If the HTML_CODE_FOLDING tag is set to YES then classes and functions can be
# dynamically folded and expanded in the generated HTML source code.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_CODE_FOLDING      = YES

# If the HTML_COPY_CLIPBOARD tag is set to YES then Doxygen will show an icon in
# the top right corner of code and text fragments that allows the user to copy
# its content to the clipboard. Note this only works if supported by the browser
# and the web page is served via a secure context (see:
# https://www.w3.org/TR/secure-contexts/), i.e. using the https: or file:
# protocol.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_COPY_CLIPBOARD    = YES

# Doxygen stores a couple of settings persistently in the browser (via e.g.
# cookies). By default these settings apply to all HTML pages generated by
# Doxygen across all projects. The HTML_PROJECT_COOKIE tag can be used to store
# the settings under a project specific key, such that the user preferences will
# be stored separately.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_PROJECT_COOKIE    =

# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
# shown in the various tree structured indices initially; the user can expand
# and collapse entries dynamically later on. Doxygen will expand the tree to
# such a level that at most the specified number of entries are visible (unless
# a fully collapsed tree already exceeds this amount). So setting the number of
# entries 1 will produce a full collapsed tree by default. 0 is a special value
# representing an infinite number of entries and will result in a full expanded
# tree by default.
# Minimum value: 0, maximum value: 9999, default value: 100.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_INDEX_NUM_ENTRIES = 100

# If the GENERATE_DOCSET tag is set to YES, additional index files will be
# generated that can be used as input for Apple's Xcode 3 integrated development
# environment (see:
# https://developer.apple.com/xcode/), introduced with OSX 10.5 (Leopard). To
# create a documentation set, Doxygen will generate a Makefile in the HTML
# output directory. Running make will produce the docset in that directory and
# running make install will install the docset in
# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
# startup. See https://developer.apple.com/library/archive/featuredarticles/Doxy
# genXcode/_index.html for more information.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_DOCSET        = NO

# This tag determines the name of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# The default value is: Doxygen generated docs.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDNAME        = "Doxygen generated docs"

# This tag determines the URL of the docset feed. A documentation feed provides
# an umbrella under which multiple documentation sets from a single provider
# (such as a company or product suite) can be grouped.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_FEEDURL         =

# This tag specifies a string that should uniquely identify the documentation
# set bundle. This should be a reverse domain-name style string, e.g.
# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_BUNDLE_ID       = org.doxygen.Project

# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
# the documentation publisher. This should be a reverse domain-name style
# string, e.g. com.mycompany.MyDocSet.documentation.
# The default value is: org.doxygen.Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_ID    = org.doxygen.Publisher

# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
# The default value is: Publisher.
# This tag requires that the tag GENERATE_DOCSET is set to YES.

DOCSET_PUBLISHER_NAME  = Publisher

# If the GENERATE_HTMLHELP tag is set to YES then Doxygen generates three
# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
# on Windows. In the beginning of 2021 Microsoft took the original page, with
# a.o. the download links, offline (the HTML help workshop was already many
# years in maintenance mode). You can download the HTML help workshop from the
# web archives at Installation executable (see:
# http://web.archive.org/web/20160201063255/http://download.microsoft.com/downlo
# ad/0/A/9/0A939EF6-E31C-430F-A3DF-DFAE7960D564/htmlhelp.exe).
#
# The HTML Help Workshop contains a compiler that can convert all HTML output
# generated by Doxygen into a single compiled HTML file (.chm). Compiled HTML
# files are now used as the Windows 98 help format, and will replace the old
# Windows help format (.hlp) on all Windows platforms in the future. Compressed
# HTML files also contain an index, a table of contents, and you can search for
# words in the documentation. The HTML workshop also contains a viewer for
# compressed HTML files.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_HTMLHELP      = NO

# The CHM_FILE tag can be used to specify the file name of the resulting .chm
# file. You can add a path in front of the file if the result should not be
# written to the html output directory.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_FILE               =

# The HHC_LOCATION tag can be used to specify the location (absolute path
# including file name) of the HTML help compiler (hhc.exe). If non-empty,
# Doxygen will try to run the HTML help compiler on the generated index.hhp.
# The file has to be specified with full path.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

HHC_LOCATION           =

# The GENERATE_CHI flag controls if a separate .chi index file is generated
# (YES) or that it should be included in the main .chm file (NO).
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

GENERATE_CHI           = NO

# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
# and project file content.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

CHM_INDEX_ENCODING     =

# The BINARY_TOC flag controls whether a binary table of contents is generated
# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
# enables the Previous and Next buttons.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

BINARY_TOC             = NO

# The TOC_EXPAND flag can be set to YES to add extra items for group members to
# the table of contents of the HTML help documentation and to the tree view.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTMLHELP is set to YES.

TOC_EXPAND             = NO

# The SITEMAP_URL tag is used to specify the full URL of the place where the
# generated documentation will be placed on the server by the user during the
# deployment of the documentation. The generated sitemap is called sitemap.xml
# and placed on the directory specified by HTML_OUTPUT. In case no SITEMAP_URL
# is specified no sitemap is generated. For information about the sitemap
# protocol see https://www.sitemaps.org
# This tag requires that the tag GENERATE_HTML is set to YES.

SITEMAP_URL            =

# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
# (.qch) of the generated HTML documentation.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_QHP           = NO

# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
# the file name of the resulting .qch file. The path specified is relative to
# the HTML output folder.
# This tag requires that the tag GENERATE_QHP is set to YES.

QCH_FILE               =

# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
# Project output. For more information please see Qt Help Project / Namespace
# (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#namespace).
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_NAMESPACE          = org.doxygen.Project

# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
# Help Project output. For more information please see Qt Help Project / Virtual
# Folders (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#virtual-folders).
# The default value is: doc.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_VIRTUAL_FOLDER     = doc

# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
# filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_NAME   =

# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
# custom filter to add. For more information please see Qt Help Project / Custom
# Filters (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#custom-filters).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_CUST_FILTER_ATTRS  =

# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
# project's filter section matches. Qt Help Project / Filter Attributes (see:
# https://doc.qt.io/archives/qt-4.8/qthelpproject.html#filter-attributes).
# This tag requires that the tag GENERATE_QHP is set to YES.

QHP_SECT_FILTER_ATTRS  =

# The QHG_LOCATION tag can be used to specify the location (absolute path
# including file name) of Qt's qhelpgenerator. If non-empty Doxygen will try to
# run qhelpgenerator on the generated .qhp file.
# This tag requires that the tag GENERATE_QHP is set to YES.

QHG_LOCATION           =

# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
# generated, together with the HTML files, they form an Eclipse help plugin. To
# install this plugin and make it available under the help contents menu in
# Eclipse, the contents of the directory containing the HTML and XML files needs
# to be copied into the plugins directory of eclipse. The name of the directory
# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
# After copying Eclipse needs to be restarted before the help appears.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_ECLIPSEHELP   = NO

# A unique identifier for the Eclipse help plugin. When installing the plugin
# the directory name containing the HTML and XML files should also have this
# name. Each documentation set should have its own identifier.
# The default value is: org.doxygen.Project.
# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.

ECLIPSE_DOC_ID         = org.doxygen.Project

# If you want full control over the layout of the generated HTML pages it might
# be necessary to disable the index and replace it with your own. The
# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
# of each HTML page. A value of NO enables the index and the value YES disables
# it. Since the tabs in the index contain the same information as the navigation
# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

DISABLE_INDEX          = NO

# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
# structure should be generated to display hierarchical information. If the tag
# value is set to YES, a side panel will be generated containing a tree-like
# index structure (just like the one that is generated for HTML Help). For this
# to work a browser that supports JavaScript, DHTML, CSS and frames is required
# (i.e. any modern browser). Windows users are probably better off using the
# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
# further fine tune the look of the index (see "Fine-tuning the output"). As an
# example, the default style sheet generated by Doxygen has an example that
# shows how to put an image at the root of the tree instead of the PROJECT_NAME.
# Since the tree basically has more details information than the tab index, you
# could consider setting DISABLE_INDEX to YES when enabling this option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

GENERATE_TREEVIEW      = YES

# When GENERATE_TREEVIEW is set to YES, the PAGE_OUTLINE_PANEL option determines
# if an additional navigation panel is shown at the right hand side of the
# screen, displaying an outline of the contents of the main page, similar to
# e.g. https://developer.android.com/reference If GENERATE_TREEVIEW is set to
# NO, this option has no effect.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

PAGE_OUTLINE_PANEL     = YES

# When GENERATE_TREEVIEW is set to YES, the FULL_SIDEBAR option determines if
# the side bar is limited to only the treeview area (value NO) or if it should
# extend to the full height of the window (value YES). Setting this to YES gives
# a layout similar to e.g. https://docs.readthedocs.io with more room for
# contents, but less room for the project logo, title, and description. If
# GENERATE_TREEVIEW is set to NO, this option has no effect.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

FULL_SIDEBAR           = NO

# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
# Doxygen will group on one line in the generated HTML documentation.
#
# Note that a value of 0 will completely suppress the enum values from appearing
# in the overview section.
# Minimum value: 0, maximum value: 20, default value: 4.
# This tag requires that the tag GENERATE_HTML is set to YES.

ENUM_VALUES_PER_LINE   = 4

# When the SHOW_ENUM_VALUES tag is set doxygen will show the specified
# enumeration values besides the enumeration mnemonics.
# The default value is: NO.

SHOW_ENUM_VALUES       = NO

# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
# to set the initial width (in pixels) of the frame in which the tree is shown.
# Minimum value: 0, maximum value: 1500, default value: 250.
# This tag requires that the tag GENERATE_HTML is set to YES.

TREEVIEW_WIDTH         = 250

# If the EXT_LINKS_IN_WINDOW option is set to YES, Doxygen will open links to
# external symbols imported via tag files in a separate window.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

EXT_LINKS_IN_WINDOW    = NO

# If the OBFUSCATE_EMAILS tag is set to YES, Doxygen will obfuscate email
# addresses.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

OBFUSCATE_EMAILS       = YES

# If the HTML_FORMULA_FORMAT option is set to svg, Doxygen will use the pdf2svg
# tool (see https://github.com/dawbarton/pdf2svg) or inkscape (see
# https://inkscape.org) to generate formulas as SVG images instead of PNGs for
# the HTML output. These images will generally look nicer at scaled resolutions.
# Possible values are: png (the default) and svg (looks nicer but requires the
# pdf2svg or inkscape tool).
# The default value is: png.
# This tag requires that the tag GENERATE_HTML is set to YES.

HTML_FORMULA_FORMAT    = png

# Use this tag to change the font size of LaTeX formulas included as images in
# the HTML documentation. When you change the font size after a successful
# Doxygen run you need to manually remove any form_*.png images from the HTML
# output directory to force them to be regenerated.
# Minimum value: 8, maximum value: 50, default value: 10.
# This tag requires that the tag GENERATE_HTML is set to YES.

FORMULA_FONTSIZE       = 10

# The FORMULA_MACROFILE can contain LaTeX \newcommand and \renewcommand commands
# to create new LaTeX commands to be used in formulas as building blocks. See
# the section "Including formulas" for details.

FORMULA_MACROFILE      =

# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
# https://www.mathjax.org) which uses client side JavaScript for the rendering
# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
# installed or if you want to formulas look prettier in the HTML output. When
# enabled you may also need to install MathJax separately and configure the path
# to it using the MATHJAX_RELPATH option.
# The default value is: NO.
# This tag requires that the tag GENERATE_HTML is set to YES.

USE_MATHJAX            = NO

# With MATHJAX_VERSION it is possible to specify the MathJax version to be used.
# Note that the different versions of MathJax have different requirements with
# regards to the different settings, so it is possible that also other MathJax
# settings have to be changed when switching between the different MathJax
# versions.
# Possible values are: MathJax_2, MathJax_3 and MathJax_4.
# The default value is: MathJax_2.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_VERSION        = MathJax_2

# When MathJax is enabled you can set the default output format to be used for
# the MathJax output. For more details about the output format see MathJax
# version 2 (see:
# https://docs.mathjax.org/en/v2.7/output.html), MathJax version 3 (see:
# https://docs.mathjax.org/en/v3.2/output/index.html) and MathJax version 4
# (see:
# https://docs.mathjax.org/en/v4.0/output/index.htm).
# Possible values are: HTML-CSS (which is slower, but has the best
# compatibility. This is the name for Mathjax version 2, for MathJax version 3
# this will be translated into chtml), NativeMML (i.e. MathML. Only supported
# for MathJax 2. For MathJax version 3 chtml will be used instead.), chtml (This
# is the name for Mathjax version 3, for MathJax version 2 this will be
# translated into HTML-CSS) and SVG.
# The default value is: HTML-CSS.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_FORMAT         = HTML-CSS

# When MathJax is enabled you need to specify the location relative to the HTML
# output directory using the MATHJAX_RELPATH option. For Mathjax version 2 the
# destination directory should contain the MathJax.js script. For instance, if
# the mathjax directory is located at the same level as the HTML output
# directory, then MATHJAX_RELPATH should be ../mathjax.s For Mathjax versions 3
# and 4 the destination directory should contain the tex-<format>.js script
# (where <format> is either chtml or svg). The default value points to the
# MathJax Content Delivery Network so you can quickly see the result without
# installing MathJax. However, it is strongly recommended to install a local
# copy of MathJax from https://www.mathjax.org before deployment. The default
# value is:
# - in case of MathJax version 2: https://cdn.jsdelivr.net/npm/mathjax@2
# - in case of MathJax version 3: https://cdn.jsdelivr.net/npm/mathjax@3
# - in case of MathJax version 4: https://cdn.jsdelivr.net/npm/mathjax@4
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_RELPATH        =

# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
# extension names that should be enabled during MathJax rendering. For example
# for MathJax version 2 (see https://docs.mathjax.org/en/v2.7/tex.html):
# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
# For example for MathJax version 3 (see
# https://docs.mathjax.org/en/v3.2/input/tex/extensions/):
# MATHJAX_EXTENSIONS = ams
# For example for MathJax version 4 (see
# https://docs.mathjax.org/en/v4.0/input/tex/extensions/):
# MATHJAX_EXTENSIONS = units
# Note that for Mathjax version 4 quite a few extensions are already
# automatically loaded. To disable a package in Mathjax version 4 one can use
# the package name prepended with a minus sign (- like MATHJAX_EXTENSIONS +=
# -textmacros)
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_EXTENSIONS     =

# The MATHJAX_CODEFILE tag can be used to specify a file with JavaScript pieces
# of code that will be used on startup of the MathJax code. See the Mathjax site
# for more details:
# - MathJax version 2 (see:
# https://docs.mathjax.org/en/v2.7/)
# - MathJax version 3 (see:
# https://docs.mathjax.org/en/v3.2/)
# - MathJax version 4 (see:
# https://docs.mathjax.org/en/v4.0/) For an example see the documentation.
# This tag requires that the tag USE_MATHJAX is set to YES.

MATHJAX_CODEFILE       =

# When the SEARCHENGINE tag is enabled Doxygen will generate a search box for
# the HTML output. The underlying search engine uses JavaScript and DHTML and
# should work on any modern browser. Note that when using HTML help
# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
# there is already a search function so this one should typically be disabled.
# For large projects the JavaScript based search engine can be slow, then
# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
# search using the keyboard; to jump to the search box use <access key> + S
# (what the <access key> is depends on the OS and browser, but it is typically
# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
# key> to jump into the search results window, the results can be navigated
# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
# the search. The filter options can be selected when the cursor is inside the
# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
# to select a filter and <Enter> or <escape> to activate or cancel the filter
# option.
# The default value is: YES.
# This tag requires that the tag GENERATE_HTML is set to YES.

SEARCHENGINE           = YES

# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
# implemented using a web server instead of a web client using JavaScript. There
# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
# setting. When disabled, Doxygen will generate a PHP script for searching and
# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
# and searching needs to be provided by external tools. See the section
# "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

SERVER_BASED_SEARCH    = NO

# When EXTERNAL_SEARCH tag is enabled Doxygen will no longer generate the PHP
# script for searching. Instead the search results are written to an XML file
# which needs to be processed by an external indexer. Doxygen will invoke an
# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
# search results.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/).
#
# See the section "External Indexing and Searching" for details.
# The default value is: NO.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH        = NO

# The SEARCHENGINE_URL should point to a search engine hosted by a web server
# which will return the search results when EXTERNAL_SEARCH is enabled.
#
# Doxygen ships with an example indexer (doxyindexer) and search engine
# (doxysearch.cgi) which are based on the open source search engine library
# Xapian (see:
# https://xapian.org/). See the section "External Indexing and Searching" for
# details.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHENGINE_URL       =

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
# search data is written to a file for indexing by an external tool. With the
# SEARCHDATA_FILE tag the name of this file can be specified.
# The default file is: searchdata.xml.
# This tag requires that the tag SEARCHENGINE is set to YES.

SEARCHDATA_FILE        = searchdata.xml

# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
# projects and redirect the results back to the right project.
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTERNAL_SEARCH_ID     =

# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through Doxygen
# projects other than the one defined by this configuration file, but that are
# all added to the same external search index. Each project needs to have a
# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
# to a relative location where the documentation can be found. The format is:
# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
# This tag requires that the tag SEARCHENGINE is set to YES.

EXTRA_SEARCH_MAPPINGS  =

#---------------------------------------------------------------------------
# Configuration options related to the LaTeX output
#---------------------------------------------------------------------------

# If the GENERATE_LATEX tag is set to YES, Doxygen will generate LaTeX output.
# The default value is: YES.

GENERATE_LATEX         = NO

# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: latex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_OUTPUT           = latex

# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
# invoked.
#
# Note that when not enabling USE_PDFLATEX the default is latex when enabling
# USE_PDFLATEX the default is pdflatex and when in the later case latex is
# chosen this is overwritten by pdflatex. For specific output languages the
# default can have been set differently, this depends on the implementation of
# the output language.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_CMD_NAME         =

# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
# index for LaTeX.
# Note: This tag is used in the Makefile / make.bat.
# See also: LATEX_MAKEINDEX_CMD for the part in the generated output file
# (.tex).
# The default file is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

MAKEINDEX_CMD_NAME     = makeindex

# The LATEX_MAKEINDEX_CMD tag can be used to specify the command name to
# generate index for LaTeX. In case there is no backslash (\) as first character
# it will be automatically added in the LaTeX code.
# Note: This tag is used in the generated output file (.tex).
# See also: MAKEINDEX_CMD_NAME for the part in the Makefile / make.bat.
# The default value is: makeindex.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_MAKEINDEX_CMD    = makeindex

# If the COMPACT_LATEX tag is set to YES, Doxygen generates more compact LaTeX
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

COMPACT_LATEX          = NO

# The PAPER_TYPE tag can be used to set the paper type that is used by the
# printer.
# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
# 14 inches) and executive (7.25 x 10.5 inches).
# The default value is: a4.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PAPER_TYPE             = a4

# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
# that should be included in the LaTeX output. The package can be specified just
# by its name or with the correct syntax as to be used with the LaTeX
# \usepackage command. To get the times font for instance you can specify :
# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
# To use the option intlimits with the amsmath package you can specify:
# EXTRA_PACKAGES=[intlimits]{amsmath}
# If left blank no extra packages will be included.
# This tag requires that the tag GENERATE_LATEX is set to YES.

EXTRA_PACKAGES         =

# The LATEX_HEADER tag can be used to specify a user-defined LaTeX header for
# the generated LaTeX document. The header should contain everything until the
# first chapter. If it is left blank Doxygen will generate a standard header. It
# is highly recommended to start with a default header using
# doxygen -w latex new_header.tex new_footer.tex new_stylesheet.sty
# and then modify the file new_header.tex. See also section "Doxygen usage" for
# information on how to generate the default header that Doxygen normally uses.
#
# Note: Only use a user-defined header if you know what you are doing!
# Note: The header is subject to change so you typically have to regenerate the
# default header when upgrading to a newer version of Doxygen. The following
# commands have a special meaning inside the header (and footer): For a
# description of the possible markers and block names see the documentation.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HEADER           =

# The LATEX_FOOTER tag can be used to specify a user-defined LaTeX footer for
# the generated LaTeX document. The footer should contain everything after the
# last chapter. If it is left blank Doxygen will generate a standard footer. See
# LATEX_HEADER for more information on how to generate a default footer and what
# special commands can be used inside the footer. See also section "Doxygen
# usage" for information on how to generate the default footer that Doxygen
# normally uses. Note: Only use a user-defined footer if you know what you are
# doing!
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_FOOTER           =

# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
# LaTeX style sheets that are included after the standard style sheets created
# by Doxygen. Using this option one can overrule certain style aspects. Doxygen
# will copy the style sheet files to the output directory.
# Note: The order of the extra style sheet files is of importance (e.g. the last
# style sheet in the list overrules the setting of the previous ones in the
# list).
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_STYLESHEET =

# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the LATEX_OUTPUT output
# directory. Note that the files will be copied as-is; there are no commands or
# markers available.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EXTRA_FILES      =

# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
# contain links (just like the HTML output) instead of page references. This
# makes the output suitable for online browsing using a PDF viewer.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

PDF_HYPERLINKS         = YES

# If the USE_PDFLATEX tag is set to YES, Doxygen will use the engine as
# specified with LATEX_CMD_NAME to generate the PDF file directly from the LaTeX
# files. Set this option to YES, to get a higher quality PDF documentation.
#
# See also section LATEX_CMD_NAME for selecting the engine.
# The default value is: YES.
# This tag requires that the tag GENERATE_LATEX is set to YES.

USE_PDFLATEX           = YES

# The LATEX_BATCHMODE tag signals the behavior of LaTeX in case of an error.
# Possible values are: NO same as ERROR_STOP, YES same as BATCH, BATCH In batch
# mode nothing is printed on the terminal, errors are scrolled as if <return> is
# hit at every error; missing files that TeX tries to input or request from
# keyboard input (\read on a not open input stream) cause the job to abort,
# NON_STOP In nonstop mode the diagnostic message will appear on the terminal,
# but there is no possibility of user interaction just like in batch mode,
# SCROLL In scroll mode, TeX will stop only for missing files to input or if
# keyboard input is necessary and ERROR_STOP In errorstop mode, TeX will stop at
# each error, asking for user intervention.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BATCHMODE        = NO

# If the LATEX_HIDE_INDICES tag is set to YES then Doxygen will not include the
# index chapters (such as File Index, Compound Index, etc.) in the output.
# The default value is: NO.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_HIDE_INDICES     = NO

# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
# bibliography, e.g. plainnat, or ieeetr. See
# https://en.wikipedia.org/wiki/BibTeX and \cite for more info.
# The default value is: plainnat.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_BIB_STYLE        = plainnat

# The LATEX_EMOJI_DIRECTORY tag is used to specify the (relative or absolute)
# path from which the emoji images will be read. If a relative path is entered,
# it will be relative to the LATEX_OUTPUT directory. If left blank the
# LATEX_OUTPUT directory will be used.
# This tag requires that the tag GENERATE_LATEX is set to YES.

LATEX_EMOJI_DIRECTORY  =

#---------------------------------------------------------------------------
# Configuration options related to the RTF output
#---------------------------------------------------------------------------

# If the GENERATE_RTF tag is set to YES, Doxygen will generate RTF output. The
# RTF output is optimized for Word 97 and may not look too pretty with other RTF
# readers/editors.
# The default value is: NO.

GENERATE_RTF           = NO

# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: rtf.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_OUTPUT             = rtf

# If the COMPACT_RTF tag is set to YES, Doxygen generates more compact RTF
# documents. This may be useful for small projects and may help to save some
# trees in general.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

COMPACT_RTF            = NO

# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
# contain hyperlink fields. The RTF file will contain links (just like the HTML
# output) instead of page references. This makes the output suitable for online
# browsing using Word or some other Word compatible readers that support those
# fields.
#
# Note: WordPad (write) and others do not support links.
# The default value is: NO.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_HYPERLINKS         = NO

# Load stylesheet definitions from file. Syntax is similar to Doxygen's
# configuration file, i.e. a series of assignments. You only have to provide
# replacements, missing definitions are set to their default value.
#
# See also section "Doxygen usage" for information on how to generate the
# default style sheet that Doxygen normally uses.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_STYLESHEET_FILE    =

# Set optional variables used in the generation of an RTF document. Syntax is
# similar to Doxygen's configuration file. A template extensions file can be
# generated using doxygen -e rtf extensionFile.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTENSIONS_FILE    =

# The RTF_EXTRA_FILES tag can be used to specify one or more extra images or
# other source files which should be copied to the RTF_OUTPUT output directory.
# Note that the files will be copied as-is; there are no commands or markers
# available.
# This tag requires that the tag GENERATE_RTF is set to YES.

RTF_EXTRA_FILES        =

#---------------------------------------------------------------------------
# Configuration options related to the man page output
#---------------------------------------------------------------------------

# If the GENERATE_MAN tag is set to YES, Doxygen will generate man pages for
# classes and files.
# The default value is: NO.

GENERATE_MAN           = YES

# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it. A directory man3 will be created inside the directory specified by
# MAN_OUTPUT.
# The default directory is: man.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_OUTPUT             = doxman

# The MAN_EXTENSION tag determines the extension that is added to the generated
# man pages. In case the manual section does not start with a number, the number
# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
# optional.
# The default value is: .3.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_EXTENSION          = .3

# The MAN_SUBDIR tag determines the name of the directory created within
# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
# MAN_EXTENSION with the initial . removed.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_SUBDIR             =

# If the MAN_LINKS tag is set to YES and Doxygen generates man output, then it
# will generate one additional man file for each entity documented in the real
# man page(s). These additional files only source the real man page, but without
# them the man command would be unable to find the correct page.
# The default value is: NO.
# This tag requires that the tag GENERATE_MAN is set to YES.

MAN_LINKS              = NO

#---------------------------------------------------------------------------
# Configuration options related to the XML output
#---------------------------------------------------------------------------

# If the GENERATE_XML tag is set to YES, Doxygen will generate an XML file that
# captures the structure of the code including all documentation.
# The default value is: NO.

GENERATE_XML           = NO

# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
# it.
# The default directory is: xml.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_OUTPUT             = xml

# If the XML_PROGRAMLISTING tag is set to YES, Doxygen will dump the program
# listings (including syntax highlighting and cross-referencing information) to
# the XML output. Note that enabling this will significantly increase the size
# of the XML output.
# The default value is: YES.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_PROGRAMLISTING     = YES

# If the XML_NS_MEMB_FILE_SCOPE tag is set to YES, Doxygen will include
# namespace members in file scope as well, matching the HTML output.
# The default value is: NO.
# This tag requires that the tag GENERATE_XML is set to YES.

XML_NS_MEMB_FILE_SCOPE = NO

#---------------------------------------------------------------------------
# Configuration options related to the DOCBOOK output
#---------------------------------------------------------------------------

# If the GENERATE_DOCBOOK tag is set to YES, Doxygen will generate Docbook files
# that can be used to generate PDF.
# The default value is: NO.

GENERATE_DOCBOOK       = NO

# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
# front of it.
# The default directory is: docbook.
# This tag requires that the tag GENERATE_DOCBOOK is set to YES.

DOCBOOK_OUTPUT         = docbook

#---------------------------------------------------------------------------
# Configuration options for the AutoGen Definitions output
#---------------------------------------------------------------------------

# If the GENERATE_AUTOGEN_DEF tag is set to YES, Doxygen will generate an
# AutoGen Definitions (see https://autogen.sourceforge.net/) file that captures
# the structure of the code including all documentation. Note that this feature
# is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_AUTOGEN_DEF   = NO

#---------------------------------------------------------------------------
# Configuration options related to Sqlite3 output
#---------------------------------------------------------------------------

# If the GENERATE_SQLITE3 tag is set to YES Doxygen will generate a Sqlite3
# database with symbols found by Doxygen stored in tables.
# The default value is: NO.

GENERATE_SQLITE3       = NO

# The SQLITE3_OUTPUT tag is used to specify where the Sqlite3 database will be
# put. If a relative path is entered the value of OUTPUT_DIRECTORY will be put
# in front of it.
# The default directory is: sqlite3.
# This tag requires that the tag GENERATE_SQLITE3 is set to YES.

SQLITE3_OUTPUT         = sqlite3

# The SQLITE3_RECREATE_DB tag is set to YES, the existing doxygen_sqlite3.db
# database file will be recreated with each Doxygen run. If set to NO, Doxygen
# will warn if a database file is already found and not modify it.
# The default value is: YES.
# This tag requires that the tag GENERATE_SQLITE3 is set to YES.

SQLITE3_RECREATE_DB    = YES

#---------------------------------------------------------------------------
# Configuration options related to the Perl module output
#---------------------------------------------------------------------------

# If the GENERATE_PERLMOD tag is set to YES, Doxygen will generate a Perl module
# file that captures the structure of the code including all documentation.
#
# Note that this feature is still experimental and incomplete at the moment.
# The default value is: NO.

GENERATE_PERLMOD       = NO

# If the PERLMOD_LATEX tag is set to YES, Doxygen will generate the necessary
# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
# output from the Perl module output.
# The default value is: NO.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_LATEX          = NO

# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
# formatted so it can be parsed by a human reader. This is useful if you want to
# understand what is going on. On the other hand, if this tag is set to NO, the
# size of the Perl module output will be much smaller and Perl will parse it
# just the same.
# The default value is: YES.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_PRETTY         = YES

# The names of the make variables in the generated doxyrules.make file are
# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
# so different doxyrules.make files included by the same Makefile don't
# overwrite each other's variables.
# This tag requires that the tag GENERATE_PERLMOD is set to YES.

PERLMOD_MAKEVAR_PREFIX =

#---------------------------------------------------------------------------
# Configuration options related to the preprocessor
#---------------------------------------------------------------------------

# If the ENABLE_PREPROCESSING tag is set to YES, Doxygen will evaluate all
# C-preprocessor directives found in the sources and include files.
# The default value is: YES.

ENABLE_PREPROCESSING   = YES

# If the MACRO_EXPANSION tag is set to YES, Doxygen will expand all macro names
# in the source code. If set to NO, only conditional compilation will be
# performed. Macro expansion can be done in a controlled way by setting
# EXPAND_ONLY_PREDEF to YES.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

MACRO_EXPANSION        = NO

# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
# the macro expansion is limited to the macros specified with the PREDEFINED and
# EXPAND_AS_DEFINED tags.
# The default value is: NO.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_ONLY_PREDEF     = NO

# If the SEARCH_INCLUDES tag is set to YES, the include files in the
# INCLUDE_PATH will be searched if a #include is found.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SEARCH_INCLUDES        = YES

# The INCLUDE_PATH tag can be used to specify one or more directories that
# contain include files that are not input files but should be processed by the
# preprocessor. Note that the INCLUDE_PATH is not recursive, so the setting of
# RECURSIVE has no effect here.
# This tag requires that the tag SEARCH_INCLUDES is set to YES.

INCLUDE_PATH           =

# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
# patterns (like *.h and *.hpp) to filter out the header-files in the
# directories. If left blank, the patterns specified with FILE_PATTERNS will be
# used.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

INCLUDE_FILE_PATTERNS  =

# The PREDEFINED tag can be used to specify one or more macro names that are
# defined before the preprocessor is started (similar to the -D option of e.g.
# gcc). The argument of the tag is a list of macros of the form: name or
# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
# is assumed. To prevent a macro definition from being undefined via #undef or
# recursively expanded use the := operator instead of the = operator.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

PREDEFINED             =

# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
# tag can be used to specify a list of macro names that should be expanded. The
# macro definition that is found in the sources will be used. Use the PREDEFINED
# tag if you want to use a different macro definition that overrules the
# definition found in the source code.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

EXPAND_AS_DEFINED      =

# If the SKIP_FUNCTION_MACROS tag is set to YES then Doxygen's preprocessor will
# remove all references to function-like macros that are alone on a line, have
# an all uppercase name, and do not end with a semicolon. Such function macros
# are typically used for boiler-plate code, and will confuse the parser if not
# removed.
# The default value is: YES.
# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.

SKIP_FUNCTION_MACROS   = YES

#---------------------------------------------------------------------------
# Configuration options related to external references
#---------------------------------------------------------------------------

# The TAGFILES tag can be used to specify one or more tag files. For each tag
# file the location of the external documentation should be added. The format of
# a tag file without this location is as follows:
# TAGFILES = file1 file2 ...
# Adding location for the tag files is done as follows:
# TAGFILES = file1=loc1 "file2 = loc2" ...
# where loc1 and loc2 can be relative or absolute paths or URLs. See the
# section "Linking to external documentation" for more information about the use
# of tag files.
# Note: Each tag file must have a unique name (where the name does NOT include
# the path). If a tag file is not located in the directory in which Doxygen is
# run, you must also specify the path to the tagfile here.

TAGFILES               =

# When a file name is specified after GENERATE_TAGFILE, Doxygen will create a
# tag file that is based on the input files it reads. See section "Linking to
# external documentation" for more information about the usage of tag files.

GENERATE_TAGFILE       =

# If the ALLEXTERNALS tag is set to YES, all external classes and namespaces
# will be listed in the class and namespace index. If set to NO, only the
# inherited external classes will be listed.
# The default value is: NO.

ALLEXTERNALS           = NO

# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
# in the topic index. If set to NO, only the current project's groups will be
# listed.
# The default value is: YES.

EXTERNAL_GROUPS        = YES

# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
# the related pages index. If set to NO, only the current project's pages will
# be listed.
# The default value is: YES.

EXTERNAL_PAGES         = YES

#---------------------------------------------------------------------------
# Configuration options related to diagram generator tools
#---------------------------------------------------------------------------

# If set to YES the inheritance and collaboration graphs will hide inheritance
# and usage relations if the target is undocumented or is not a class.
# The default value is: YES.

HIDE_UNDOC_RELATIONS   = YES

# If you set the HAVE_DOT tag to YES then Doxygen will assume the dot tool is
# available from the path. This tool is part of Graphviz (see:
# https://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
# Bell Labs. The other options in this section have no effect if this option is
# set to NO
# The default value is: NO.

HAVE_DOT               = YES

# The DOT_NUM_THREADS specifies the number of dot invocations Doxygen is allowed
# to run in parallel. When set to 0 Doxygen will base this on the number of
# processors available in the system. You can set it explicitly to a value
# larger than 0 to get control over the balance between CPU load and processing
# speed.
# Minimum value: 0, maximum value: 512, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NUM_THREADS        = 8

# DOT_COMMON_ATTR is common attributes for nodes, edges and labels of
# subgraphs. When you want a differently looking font in the dot files that
# Doxygen generates you can specify fontname, fontcolor and fontsize attributes.
# For details please see <a href=https://graphviz.org/doc/info/attrs.html>Node,
# Edge and Graph Attributes specification</a> You need to make sure dot is able
# to find the font, which can be done by putting it in a standard location or by
# setting the DOTFONTPATH environment variable or by setting DOT_FONTPATH to the
# directory containing the font. Default graphviz fontsize is 14.
# The default value is: fontname=Helvetica,fontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_COMMON_ATTR        = "fontname=Helvetica,fontsize=10"

# DOT_EDGE_ATTR is concatenated with DOT_COMMON_ATTR. For elegant style you can
# add 'arrowhead=open, arrowtail=open, arrowsize=0.5'. <a
# href=https://graphviz.org/doc/info/arrows.html>Complete documentation about
# arrows shapes.</a>
# The default value is: labelfontname=Helvetica,labelfontsize=10.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_EDGE_ATTR          = "labelfontname=Helvetica,labelfontsize=10"

# DOT_NODE_ATTR is concatenated with DOT_COMMON_ATTR. For view without boxes
# around nodes set 'shape=plain' or 'shape=plaintext' <a
# href=https://www.graphviz.org/doc/info/shapes.html>Shapes specification</a>
# The default value is: shape=box,height=0.2,width=0.4.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_NODE_ATTR          = "shape=box,height=0.2,width=0.4"

# You can set the path where dot can find font specified with fontname in
# DOT_COMMON_ATTR and others dot attributes.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_FONTPATH           =

# If the CLASS_GRAPH tag is set to YES or GRAPH or BUILTIN then Doxygen will
# generate a graph for each documented class showing the direct and indirect
# inheritance relations. In case the CLASS_GRAPH tag is set to YES or GRAPH and
# HAVE_DOT is enabled as well, then dot will be used to draw the graph. In case
# the CLASS_GRAPH tag is set to YES and HAVE_DOT is disabled or if the
# CLASS_GRAPH tag is set to BUILTIN, then the built-in generator will be used.
# If the CLASS_GRAPH tag is set to TEXT the direct and indirect inheritance
# relations will be shown as texts / links. Explicit enabling an inheritance
# graph or choosing a different representation for an inheritance graph of a
# specific class, can be accomplished by means of the command \inheritancegraph.
# Disabling an inheritance graph can be accomplished by means of the command
# \hideinheritancegraph.
# Possible values are: NO, YES, TEXT, GRAPH and BUILTIN.
# The default value is: YES.

CLASS_GRAPH            = YES

# If the COLLABORATION_GRAPH tag is set to YES then Doxygen will generate a
# graph for each documented class showing the direct and indirect implementation
# dependencies (inheritance, containment, and class references variables) of the
# class with other documented classes. Explicit enabling a collaboration graph,
# when COLLABORATION_GRAPH is set to NO, can be accomplished by means of the
# command \collaborationgraph. Disabling a collaboration graph can be
# accomplished by means of the command \hidecollaborationgraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

COLLABORATION_GRAPH    = YES

# If the GROUP_GRAPHS tag is set to YES then Doxygen will generate a graph for
# groups, showing the direct groups dependencies. Explicit enabling a group
# dependency graph, when GROUP_GRAPHS is set to NO, can be accomplished by means
# of the command \groupgraph. Disabling a directory graph can be accomplished by
# means of the command \hidegroupgraph. See also the chapter Grouping in the
# manual.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GROUP_GRAPHS           = YES

# If the UML_LOOK tag is set to YES, Doxygen will generate inheritance and
# collaboration diagrams in a style similar to the OMG's Unified Modeling
# Language.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

UML_LOOK               = NO

# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
# class node. If there are many fields or methods and many nodes the graph may
# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
# number of items for each type to make the size more manageable. Set this to 0
# for no limit. Note that the threshold may be exceeded by 50% before the limit
# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
# but if the number exceeds 15, the total amount of fields shown is limited to
# 10.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag UML_LOOK is set to YES.

UML_LIMIT_NUM_FIELDS   = 10

# If the UML_LOOK tag is enabled, field labels are shown along the edge between
# two class nodes. If there are many fields and many nodes the graph may become
# too cluttered. The UML_MAX_EDGE_LABELS threshold limits the number of items to
# make the size more manageable. Set this to 0 for no limit.
# Minimum value: 0, maximum value: 100, default value: 10.
# This tag requires that the tag UML_LOOK is set to YES.

UML_MAX_EDGE_LABELS    = 10

# If the DOT_UML_DETAILS tag is set to NO, Doxygen will show attributes and
# methods without types and arguments in the UML graphs. If the DOT_UML_DETAILS
# tag is set to YES, Doxygen will add type and arguments for attributes and
# methods in the UML graphs. If the DOT_UML_DETAILS tag is set to NONE, Doxygen
# will not generate fields with class member information in the UML graphs. The
# class diagrams will look similar to the default class diagrams but using UML
# notation for the relationships.
# Possible values are: NO, YES and NONE.
# The default value is: NO.
# This tag requires that the tag UML_LOOK is set to YES.

DOT_UML_DETAILS        = NO

# The DOT_WRAP_THRESHOLD tag can be used to set the maximum number of characters
# to display on a single line. If the actual line length exceeds this threshold
# significantly it will be wrapped across multiple lines. Some heuristics are
# applied to avoid ugly line breaks.
# Minimum value: 0, maximum value: 1000, default value: 17.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_WRAP_THRESHOLD     = 17

# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
# collaboration graphs will show the relations between templates and their
# instances.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

TEMPLATE_RELATIONS     = YES

# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
# YES then Doxygen will generate a graph for each documented file showing the
# direct and indirect include dependencies of the file with other documented
# files. Explicit enabling an include graph, when INCLUDE_GRAPH is is set to NO,
# can be accomplished by means of the command \includegraph. Disabling an
# include graph can be accomplished by means of the command \hideincludegraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDE_GRAPH          = YES

# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
# set to YES then Doxygen will generate a graph for each documented file showing
# the direct and indirect include dependencies of the file with other documented
# files. Explicit enabling an included by graph, when INCLUDED_BY_GRAPH is set
# to NO, can be accomplished by means of the command \includedbygraph. Disabling
# an included by graph can be accomplished by means of the command
# \hideincludedbygraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

INCLUDED_BY_GRAPH      = YES

# If the CALL_GRAPH tag is set to YES then Doxygen will generate a call
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable call graphs for selected
# functions only using the \callgraph command. Disabling a call graph can be
# accomplished by means of the command \hidecallgraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALL_GRAPH             = YES

# If the CALLER_GRAPH tag is set to YES then Doxygen will generate a caller
# dependency graph for every global function or class method.
#
# Note that enabling this option will significantly increase the time of a run.
# So in most cases it will be better to enable caller graphs for selected
# functions only using the \callergraph command. Disabling a caller graph can be
# accomplished by means of the command \hidecallergraph.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

CALLER_GRAPH           = YES

# If the GRAPHICAL_HIERARCHY tag is set to YES then Doxygen will graphical
# hierarchy of all classes instead of a textual one.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GRAPHICAL_HIERARCHY    = YES

# If the DIRECTORY_GRAPH tag is set to YES then Doxygen will show the
# dependencies a directory has on other directories in a graphical way. The
# dependency relations are determined by the #include relations between the
# files in the directories. Explicit enabling a directory graph, when
# DIRECTORY_GRAPH is set to NO, can be accomplished by means of the command
# \directorygraph. Disabling a directory graph can be accomplished by means of
# the command \hidedirectorygraph.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

DIRECTORY_GRAPH        = YES

# The DIR_GRAPH_MAX_DEPTH tag can be used to limit the maximum number of levels
# of child directories generated in directory dependency graphs by dot.
# Minimum value: 1, maximum value: 25, default value: 1.
# This tag requires that the tag DIRECTORY_GRAPH is set to YES.

DIR_GRAPH_MAX_DEPTH    = 25

# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
# generated by dot. For an explanation of the image formats see the section
# output formats in the documentation of the dot tool (Graphviz (see:
# https://www.graphviz.org/)).
#
# Note the formats svg:cairo and svg:cairo:cairo cannot be used in combination
# with INTERACTIVE_SVG (the INTERACTIVE_SVG will be set to NO).
# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus,
# png:gdiplus:gdiplus, svg:cairo, svg:cairo:cairo, svg:svg, svg:svg:core,
# gif:cairo, gif:cairo:gd, gif:cairo:gdiplus, gif:gdiplus, gif:gdiplus:gdiplus,
# gif:gd, gif:gd:gd, jpg:cairo, jpg:cairo:gd, jpg:cairo:gdiplus, jpg:gd,
# jpg:gd:gd, jpg:gdiplus and jpg:gdiplus:gdiplus.
# The default value is: png.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_IMAGE_FORMAT       = svg

# If DOT_IMAGE_FORMAT is set to svg or svg:svg or svg:svg:core, then this option
# can be set to YES to enable generation of interactive SVG images that allow
# zooming and panning.
#
# Note that this requires a modern browser other than Internet Explorer. Tested
# and working are Firefox, Chrome, Safari, and Opera.
#
# Note This option will be automatically disabled when DOT_IMAGE_FORMAT is set
# to svg:cairo or svg:cairo:cairo.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

INTERACTIVE_SVG        = YES

# The DOT_PATH tag can be used to specify the path where the dot tool can be
# found. If left blank, it is assumed the dot tool can be found in the path.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_PATH               =

# The DOTFILE_DIRS tag can be used to specify one or more directories that
# contain dot files that are included in the documentation (see the \dotfile
# command).
# This tag requires that the tag HAVE_DOT is set to YES.

DOTFILE_DIRS           =

# You can include diagrams made with dia in Doxygen documentation. Doxygen will
# then run dia to produce the diagram and insert it in the documentation. The
# DIA_PATH tag allows you to specify the directory where the dia binary resides.
# If left empty dia is assumed to be found in the default search path.

DIA_PATH               =

# The DIAFILE_DIRS tag can be used to specify one or more directories that
# contain dia files that are included in the documentation (see the \diafile
# command).

DIAFILE_DIRS           =

# When using PlantUML, the PLANTUML_JAR_PATH tag should be used to specify the
# path where java can find the plantuml.jar file or to the filename of jar file
# to be used. If left blank, it is assumed PlantUML is not used or called during
# a preprocessing step. Doxygen will generate a warning when it encounters a
# \startuml command in this case and will not generate output for the diagram.

PLANTUML_JAR_PATH      =

# When using PlantUML, the PLANTUML_CFG_FILE tag can be used to specify a
# configuration file for PlantUML.

PLANTUML_CFG_FILE      =

# When using PlantUML, the specified paths are searched for files specified by
# the !include statement in a PlantUML block.

PLANTUML_INCLUDE_PATH  =

# The PLANTUMLFILE_DIRS tag can be used to specify one or more directories that
# contain PlantUml files that are included in the documentation (see the
# \plantumlfile command).

PLANTUMLFILE_DIRS      =

# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
# that will be shown in the graph. If the number of nodes in a graph becomes
# larger than this value, Doxygen will truncate the graph, which is visualized
# by representing a node as a red box. Note that if the number of direct
# children of the root node in a graph is already larger than
# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
# Minimum value: 0, maximum value: 10000, default value: 50.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_GRAPH_MAX_NODES    = 64

# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
# generated by dot. A depth value of 3 means that only nodes reachable from the
# root by following a path via at most 3 edges will be shown. Nodes that lay
# further from the root node will be omitted. Note that setting this option to 1
# or 2 may greatly reduce the computation time needed for large code bases. Also
# note that the size of a graph can be further restricted by
# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
# Minimum value: 0, maximum value: 1000, default value: 0.
# This tag requires that the tag HAVE_DOT is set to YES.

MAX_DOT_GRAPH_DEPTH    = 4

# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
# files in one run (i.e. multiple -o and -T options on the command line). This
# makes dot run faster, but since only newer versions of dot (>1.8.10) support
# this, this feature is disabled by default.
# The default value is: NO.
# This tag requires that the tag HAVE_DOT is set to YES.

DOT_MULTI_TARGETS      = NO

# If the GENERATE_LEGEND tag is set to YES Doxygen will generate a legend page
# explaining the meaning of the various boxes and arrows in the dot generated
# graphs.
# Note: This tag requires that UML_LOOK isn't set, i.e. the Doxygen internal
# graphical representation for inheritance and collaboration diagrams is used.
# The default value is: YES.
# This tag requires that the tag HAVE_DOT is set to YES.

GENERATE_LEGEND        = YES

# If the DOT_CLEANUP tag is set to YES, Doxygen will remove the intermediate
# files that are used to generate the various graphs.
#
# Note: This setting is not only used for dot files but also for msc temporary
# files.
# The default value is: YES.

DOT_CLEANUP            = YES

# You can define message sequence charts within Doxygen comments using the \msc
# command. If the MSCGEN_TOOL tag is left empty (the default), then Doxygen will
# use a built-in version of mscgen tool to produce the charts. Alternatively,
# the MSCGEN_TOOL tag can also specify the name an external tool. For instance,
# specifying prog as the value, Doxygen will call the tool as prog -T
# <outfile_format> -o <outputfile> <inputfile>. The external tool should support
# output file formats "png", "eps", "svg", and "ismap".

MSCGEN_TOOL            =

# The MSCFILE_DIRS tag can be used to specify one or more directories that
# contain msc files that are included in the documentation (see the \mscfile
# command).

MSCFILE_DIRS           =


--- .\examples\clocf.conf ---
clocf.phs
clocf.phsb
phasorcompiler
--no-logo -o %s %s

--- .\examples\clocf.phs ---
using("stdsys", "stdio", "stdstr", "stdfile", "stdtype");

fn print_help() -> void {
    var sb = sb_new();
    sb_append(sb, "clocf - cloc formatter\n\n");
    sb_append(sb, "Usage:\n");
    sb_append(sb, "  cloc [options] <path> | clocf    # Process cloc output via pipe\n");
    puts(sb_to_string(sb));
    sb_free(sb);
}

fn main() -> int {
    var argc = sys_argc();
    
    if (argc > 1) {
        var arg = sys_argv(1);
        if (arg == "--help" || arg == "-h") {
            print_help();
            return 0;
        }
    }

    var totalCode = 0;
    var maxNameLen = 0;
    var langCount = 0;
    
    var dataStorage = sb_new();
    
    while (true) {
        var line = gets();
        if (len(line) == 0) { break; }

        if (starts_with(line, "github.com/AlDanial/cloc") || starts_with(line, "-") || starts_with(line, "Language") || starts_with(line, "SUM")) {
            continue;
        }

        var codeStr = "";
        var foundDigits = false;
        var codeIdxStart = 0;

        for (var i = len(line) - 1; i >= 0; i = i - 1) {
            var c = char_at(line, i);
            var isDigit = (c == "0" || c == "1" || c == "2" || c == "3" || c == "4" || 
                           c == "5" || c == "6" || c == "7" || c == "8" || c == "9");
            
            if (isDigit) {
                var tempSb = sb_new();
                sb_append(tempSb, c);
                sb_append(tempSb, codeStr);
                codeStr = sb_free(tempSb);
                foundDigits = true;
            } else if (foundDigits) {
                codeIdxStart = i;
                break;
            }
        }

        var namePart = "";
        for (var j = 0; j < len(line); j = j + 1) {
            var c = char_at(line, j);
            if (c == " " && j > 0) {
                if (char_at(line, j-1) != " ") {
                     namePart = substr(line, 0, j);
                     break;
                }
            }
        }

        if (len(codeStr) > 0 && len(namePart) > 0) {
            var codeValue = to_int(codeStr);
            totalCode = totalCode + codeValue;
            
            if (len(namePart) > maxNameLen) {
                maxNameLen = len(namePart);
            }

            sb_append(dataStorage, namePart);
            sb_append(dataStorage, ":");
            sb_append(dataStorage, codeStr);
            sb_append(dataStorage, "\n");
            langCount = langCount + 1;
        }
    }

    if (totalCode == 0) {
        puts_error("Error: No cloc data received via pipe.");
        sb_free(dataStorage);
        return 1;
    }

    var headerSb = sb_new();
    sb_append(headerSb, "Total code lines: ");
    sb_append(headerSb, to_string(to_int(totalCode)));
    puts(sb_to_string(headerSb));
    sb_free(headerSb);
    puts("Language percentages:");

    var rawResults = sb_free(dataStorage);
    var currentPos = 0;

    for (var k = 0; k < langCount; k = k + 1) {
        var entry = "";
        for (var m = currentPos; m < len(rawResults); m = m + 1) {
            if (char_at(rawResults, m) == "\n") {
                entry = substr(rawResults, currentPos, m - currentPos);
                currentPos = m + 1;
                break;
            }
        }

        var splitIdx = 0;
        for (var n = 0; n < len(entry); n = n + 1) {
            if (char_at(entry, n) == ":") {
                splitIdx = n;
                break;
            }
        }

        var lName = substr(entry, 0, splitIdx);
        var lCode = to_int(substr(entry, splitIdx + 1));
        var percent = (lCode * 100.0) / totalCode;

        var lineSb = sb_new();
        sb_append(lineSb, lName);
        
        var padding = maxNameLen - len(lName);
        for (var p = 0; p < padding; p = p + 1) {
            sb_append(lineSb, " ");
        }

        sb_append(lineSb, " : ");
        sb_append(lineSb, to_string(percent));
        sb_append(lineSb, "% (");
        sb_append(lineSb, to_string(lCode));
        sb_append(lineSb, " lines)");
        
        puts(sb_to_string(lineSb));
        sb_free(lineSb);
    }

    return 0;
}

shutdown(main());


--- .\examples\FFI\CXX\CMakeLists.txt ---
cmake_minimum_required(VERSION 3.10)
project(PhasorFFI_Example CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Add the include directory for PhasorFFI.hpp, which is in the parent project's 'include' directory.
include_directories(../../../include)

# Build the shared library (plugin) from the source file.
# No linking is needed here because the Phasor API symbols will be
# resolved by the host application when it loads the plugin.
add_library(phasor_ffi_example SHARED src/ffi.cpp)

--- .\examples\FFI\CXX\src\ffi.cpp ---
#define PHASOR_FFI_BUILD_DLL
#include <PhasorFFI.h>

#include <iostream>

/**
 * @brief A simple native function to be exposed to the Phasor VM.
 *
 * This function demonstrates how to interact with the FFI:
 * - It accepts an array of PhasorValue arguments.
 * - It uses the `phasor_is_*` and `phasor_to_*` helpers to inspect arguments.
 * - It returns a PhasorValue using a `phasor_make_*` helper.
 */
PhasorValue hello_from_ffi(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	std::cout << "Hello from a C++ FFI plugin!" << std::endl;
	std::cout << "Received " << argc << " arguments." << std::endl;

	for (int i = 0; i < argc; ++i)
	{
		std::cout << "  Arg " << i << ": ";
		switch (argv[i].type)
		{
		case PHASOR_TYPE_NULL:
			std::cout << "null";
			break;
		case PHASOR_TYPE_BOOL:
			std::cout << (phasor_to_bool(argv[i]) ? "true" : "false");
			break;
		case PHASOR_TYPE_INT:
			std::cout << phasor_to_int(argv[i]);
			break;
		case PHASOR_TYPE_FLOAT:
			std::cout << phasor_to_float(argv[i]);
			break;
		case PHASOR_TYPE_STRING: {
			std::cout << "\"" << phasor_to_string(argv[i]) << "\"";
			break;
		}
		}
		std::cout << std::endl;
	}

	// Return a string value back to the VM.
	// Note: For literal strings, this is safe. For dynamically allocated
	// strings, you must ensure the memory outlives the return to the VM.
	// The VM is expected to copy the string content.
	return phasor_make_string("Success from FFI!");
}

/**
 * @brief The required entry point for the plugin.
 *
 * The Phasor host calls this function after loading the shared library.
 * This function is responsible for registering all of the plugin's
 * native functions with the Phasor VM.
 */
void phasor_plugin_entry(const PhasorAPI *api, PhasorVM *vm)
{
	// Use the `register_function` pointer provided by the host to
	// register our `hello_from_ffi` function.
	api->register_function(vm, "hello", &hello_from_ffi);
}


--- .\examples\FFI\Rust\cargo.toml ---
[package]
name = "phasor_plugin_sample"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
panic = "abort"
lto = true
codegen-units = 1


--- .\examples\FFI\Rust\src\lib.rs ---
use std::os::raw::{c_char, c_int};

#[repr(C)]
pub struct PhasorVM {
    _private: [u8; 0],
}

#[repr(C)]
#[derive(Copy, Clone)]
pub enum PhasorValueType {
    PHASOR_TYPE_NULL,
    PHASOR_TYPE_BOOL,
    PHASOR_TYPE_INT,
    PHASOR_TYPE_FLOAT,
    PHASOR_TYPE_STRING,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union PhasorValueUnion {
    pub b: bool,
    pub i: i64,
    pub f: f64,
    pub s: *const c_char,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct PhasorValue {
    pub type_: PhasorValueType,
    pub as_: PhasorValueUnion,
}

#[repr(C)]
pub struct PhasorAPI {
    pub register_function: Option<
        extern "C" fn(
            vm: *mut PhasorVM,
            name: *const c_char,
            func: PhasorNativeFunction,
        ),
    >,
}

pub type PhasorNativeFunction =
    extern "C" fn(vm: *mut PhasorVM, argc: c_int, argv: *const PhasorValue) -> PhasorValue;

fn make_int(value: i64) -> PhasorValue {
    PhasorValue {
        type_: PhasorValueType::PHASOR_TYPE_INT,
        as_: PhasorValueUnion { i: value },
    }
}

extern "C" fn add_integers(
    _vm: *mut PhasorVM,
    argc: c_int,
    argv: *const PhasorValue,
) -> PhasorValue {
    if argc != 2 || argv.is_null() {
        return make_int(0);
    }

    unsafe {
        let a = (*argv.add(0)).as_.i;
        let b = (*argv.add(1)).as_.i;
        make_int(a + b)
    }
}

#[no_mangle]
pub extern "C" fn phasor_plugin_entry(api: *const PhasorAPI, vm: *mut PhasorVM) {
    if api.is_null() || vm.is_null() {
        return;
    }

    unsafe {
        let api = &*api;
        if let Some(register) = api.register_function {
            let name = b"add\0";
            register(vm, name.as_ptr() as *const c_char, add_integers);
        }
    }
}


--- .\examples\FFI\Zig\lib.zig ---
const c = @cImport({
    @cInclude("stdint.h");
    @cInclude("stddef.h");
    @cInclude("stdbool.h");
});

pub const PhasorVM = opaque {};

pub const PhasorValueType = enum(u32) {
    PHASOR_TYPE_NULL,
    PHASOR_TYPE_BOOL,
    PHASOR_TYPE_INT,
    PHASOR_TYPE_FLOAT,
    PHASOR_TYPE_STRING,
};

pub const PhasorValueUnion = extern union {
    b: bool,
    i: i64,
    f: f64,
    s: [*c]const u8,
};

pub const PhasorValue = extern struct {
    type_: PhasorValueType,
    as_: PhasorValueUnion,
};

pub fn phasor_make_null() PhasorValue {
    return PhasorValue{ .type_ = PhasorValueType.PHASOR_TYPE_NULL, .as_ = undefined };
}

pub fn phasor_make_bool(b: bool) PhasorValue {
    return PhasorValue{ .type_ = PhasorValueType.PHASOR_TYPE_BOOL, .as_ = .{ .b = b } };
}

pub fn phasor_make_int(i: i64) PhasorValue {
    return PhasorValue{ .type_ = PhasorValueType.PHASOR_TYPE_INT, .as_ = .{ .i = i } };
}

pub fn phasor_make_float(f: f64) PhasorValue {
    return PhasorValue{ .type_ = PhasorValueType.PHASOR_TYPE_FLOAT, .as_ = .{ .f = f } };
}

pub fn phasor_make_string(s: [*c]const u8) PhasorValue {
    return PhasorValue{ .type_ = PhasorValueType.PHASOR_TYPE_STRING, .as_ = .{ .s = s } };
}

pub fn phasor_is_null(val: PhasorValue) bool {
    return val.type_ == PhasorValueType.PHASOR_TYPE_NULL;
}
pub fn phasor_is_bool(val: PhasorValue) bool {
    return val.type_ == PhasorValueType.PHASOR_TYPE_BOOL;
}
pub fn phasor_is_int(val: PhasorValue) bool {
    return val.type_ == PhasorValueType.PHASOR_TYPE_INT;
}
pub fn phasor_is_float(val: PhasorValue) bool {
    return val.type_ == PhasorValueType.PHASOR_TYPE_FLOAT;
}
pub fn phasor_is_string(val: PhasorValue) bool {
    return val.type_ == PhasorValueType.PHASOR_TYPE_STRING;
}
pub fn phasor_is_number(val: PhasorValue) bool {
    return phasor_is_int(val) or phasor_is_float(val);
}

pub fn phasor_to_bool(val: PhasorValue) bool {
    return val.as_.b;
}
pub fn phasor_to_int(val: PhasorValue) i64 {
    return val.as_.i;
}
pub fn phasor_to_float(val: PhasorValue) f64 {
    if (phasor_is_int(val)) {
        return @floatFromInt(val.as_.i);
    }
    return val.as_.f;
}

pub fn phasor_to_string(val: PhasorValue) [*c]const u8 {
    return val.as_.s;
}

pub const PhasorNativeFunction = *const fn (vm: *PhasorVM, argc: c_int, argv: ?*const PhasorValue) callconv(.c) PhasorValue;

pub const PhasorAPI = extern struct {
    register_function: ?*const fn (vm: *PhasorVM, name: [*c]const u8, func: PhasorNativeFunction) callconv(.c) void,
};

pub export fn add_integers(
    _: *PhasorVM,
    argc: c_int,
    argv: ?*const PhasorValue,
) callconv(.c) PhasorValue {
    if (argv == null or argc != 2) {
        return phasor_make_int(0);
    }

    const args: [*]const PhasorValue = @ptrCast(argv.?);

    if (!phasor_is_int(args[0]) or !phasor_is_int(args[1])) {
        return phasor_make_int(0);
    }

    return phasor_make_int(phasor_to_int(args[0]) + phasor_to_int(args[1]));
}

pub export fn phasor_plugin_entry(api: *const PhasorAPI, vm: *PhasorVM) callconv(.c) void {
    if (api.register_function) |register| {
        register(vm, "add", add_integers);
    }
}

--- .\examples\hello.phs ---
print "Hello World!";


--- .\examples\hello.phs.conf ---
hello.phs
hello.phs.phsb
phasorcompiler
--no-logo -o %s %s

--- .\examples\hello.pul ---
print "Hello World!"


--- .\examples\hello.pul.conf ---
hello.pul
hello.pul.phsb
pulsarcompiler
--no-logo -o %s %s

--- .\examples\progress_bar.conf ---
progress_bar.phs
progress_bar.phsb
phasorcompiler
--no-logo -o %s %s

--- .\examples\progress_bar.phs ---
using("stdio", "stdstr", "stdtype", "stdsys");

fn extract_filename(line) {
    var last_space = -1;
    var i = 0;
    while (i < len(line)) {
        if (char_at(line, i) == " ") {
            last_space = i;
        }
        i = i + 1;
    }
    
    if (last_space == -1) {
        return "";
    }
    
    var candidate = substr(line, last_space + 1);
    var has_slash = find(candidate, "/") != -1;
    var has_backslash = find(candidate, "\\") != -1;
    
    if (has_slash || has_backslash) {
        return candidate;
    }
    
    return "";
}

fn main() {
    var width = 40;
    
    while (true) {
        var line = gets();
        
        var start = find(line, "[");
        if (start == -1) {
            break;
        }
        
        var slash = find(line, "/", start);
        if (slash == -1) {
            continue;
        }
        
        var end = find(line, "]", slash);
        if (end == -1) {
            continue;
        }
        
        var current_str = substr(line, start + 1, slash - start - 1);
        var total_str = substr(line, slash + 1, end - slash - 1);
        
        var current = to_int(current_str);
        var total = to_int(total_str);
        
        var pos = 0;
        if (total > 0) {
            pos = current * width / total;
        }
        
        var bar = sb_new();
        sb_append(bar, "\r[");
        
        var i = 0;
        while (i < width) {
            if (i < pos) {
                sb_append(bar, "=");
            } else if (i == pos) {
                sb_append(bar, ">");
            } else {
                sb_append(bar, " ");
            }
            i = i + 1;
        }
        
        sb_append(bar, "] ");
        sb_append(bar, to_string(current));
        sb_append(bar, "/");
        sb_append(bar, to_string(total));
        
        var filename = extract_filename(line);
        if (len(filename) > 0) {
            sb_append(bar, " ");
            sb_append(bar, filename);
        }
        
        printf("%s", sb_to_string(bar));
        sb_free(bar);
    }
    
    puts("");
    return 0;
}

shutdown(main());


--- .\examples\rule110.conf ---
rule110.phs
rule110.phsb
phasorcompiler
--no-logo -o %s %s

--- .\examples\rule110.phs ---
#!/usr/bin/env phasor
using("stdio", "stdstr", "stdtype", "stdsys", "stdfile");

var logfile = "outfile.txt";

fn secondsToMinutes(seconds: float) -> string {
    if (seconds < 60) return c_fmt("%fs", seconds);
    if (seconds % 60 < 10) return c_fmt("%d:0%ds", seconds / 60, seconds % 60);
    return c_fmt("%d:%ds", seconds / 60, seconds % 60);
}

fn msToSeconds(milli: float) -> float {
    return milli / 1000;
}

fn rule110(width: int, generations: int, stdout: bool) -> int {
    if (!stdout) puts(concat("Output at ", logfile));
    frm(logfile);
    var start = time();

    var board_sb = sb_new();
    var i = 0;
    while (i < width - 1) {
        sb_append(board_sb, " ");
        i = i + 1;
    }
    sb_append(board_sb, "#");

    var board = sb_to_string(board_sb);
    sb_free(board_sb);

    var next_board = sb_new();
    var file_buffer = sb_new(); 
    var g = 0;

    if (!stdout) printf("GENERATION 0 TIME: %s", secondsToMinutes(msToSeconds(time() - start)));
    var l_start = time();
    var avg_amt = 0.0;
    var avg_gen = 0.0;
    var average = 0.0;
    var avg_remaining = 0.0;

    while (g <= generations) {
        if (stdout) { 
            puts(board);
        } 
    
        sb_append(file_buffer, board);
        sb_append(file_buffer, "\n");

        next_board = sb_new();

        var k = 0;
        while (k < width) {
                    var l = " ";
        if (k > 0)
            l = char_at(board, k - 1);
        var c = char_at(board, k);
        var r = " ";
        if (k < width - 1)
            r = char_at(board, k + 1);
        var next_val = " ";
        if ((c == "#" && r == " ") || (c == " " && r == "#") || (l == " " && c == "#" && r == "#"))
            next_val = "#";

        sb_append(next_board, next_val);
            k = k + 1;
        }

        if (g != 0 && (g % 500 == 0)) {
            var chunk = sb_to_string(file_buffer);
            fappend(logfile, chunk);
            sb_free(file_buffer);
            file_buffer = sb_new();

            if (!stdout) {
                var now = time();

                var chunk_time;
                chunk_time = msToSeconds(now - l_start);

                avg_amt = avg_amt + chunk_time;
                avg_gen = avg_gen + 1;

                average = avg_amt / avg_gen;

                var chunks_done;
                chunks_done = avg_gen;

                var chunks_total;
                chunks_total = generations / 500.0;

                avg_remaining = (chunks_total - chunks_done) * average;
				prints("\r                                                                        ");
                printf(
                    "\rGENERATION %d-%d TIME: %s, TOTAL: %s, ETA: %s",
                    (g - 499),
                    g,
                    secondsToMinutes(chunk_time),
                    secondsToMinutes(msToSeconds(now - start)),
                    secondsToMinutes(avg_remaining)
                );

                l_start = now;
            }

        }

        board = sb_to_string(next_board);
        sb_free(next_board);
        g = g + 1;
    }

    var final_chunk = sb_to_string(file_buffer);
    fappend(logfile, final_chunk);
    sb_free(file_buffer);

    sb_free(next_board);
    putf("\nTOTAL: %s", secondsToMinutes(msToSeconds(time() - start)));
    return 0;
}

if (sys_argc() < 4) shutdown(rule110(2085, 25050, false)); // Close to 1MB per block

shutdown(rule110(to_int(sys_argv(1)), to_int(sys_argv(2)), to_int(sys_argv(3))));


--- .\include\json.hpp ---
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

/****************************************************************************\
 * Note on documentation: The source files contain links to the online      *
 * documentation of the public API at https://json.nlohmann.me. This URL    *
 * contains the most recent documentation and should also be applicable to  *
 * previous versions; documentation for deprecated functions is not         *
 * removed, but marked deprecated. See "Generate documentation" section in  *
 * file docs/README.md.                                                     *
\****************************************************************************/

#ifndef INCLUDE_NLOHMANN_JSON_HPP_
#define INCLUDE_NLOHMANN_JSON_HPP_

#include <algorithm> // all_of, find, for_each
#include <cstddef> // nullptr_t, ptrdiff_t, size_t
#include <functional> // hash, less
#include <initializer_list> // initializer_list
#ifndef JSON_NO_IO
    #include <iosfwd> // istream, ostream
#endif  // JSON_NO_IO
#include <iterator> // random_access_iterator_tag
#include <memory> // unique_ptr
#include <string> // string, stoi, to_string
#include <utility> // declval, forward, move, pair, swap
#include <vector> // vector

// #include <nlohmann/adl_serializer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <utility>

// #include <nlohmann/detail/abi_macros.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// This file contains all macro definitions affecting or depending on the ABI

#ifndef JSON_SKIP_LIBRARY_VERSION_CHECK
    #if defined(NLOHMANN_JSON_VERSION_MAJOR) && defined(NLOHMANN_JSON_VERSION_MINOR) && defined(NLOHMANN_JSON_VERSION_PATCH)
        #if NLOHMANN_JSON_VERSION_MAJOR != 3 || NLOHMANN_JSON_VERSION_MINOR != 12 || NLOHMANN_JSON_VERSION_PATCH != 0
            #warning "Already included a different version of the library!"
        #endif
    #endif
#endif

#define NLOHMANN_JSON_VERSION_MAJOR 3   // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_MINOR 12  // NOLINT(modernize-macro-to-enum)
#define NLOHMANN_JSON_VERSION_PATCH 0   // NOLINT(modernize-macro-to-enum)

#ifndef JSON_DIAGNOSTICS
    #define JSON_DIAGNOSTICS 0
#endif

#ifndef JSON_DIAGNOSTIC_POSITIONS
    #define JSON_DIAGNOSTIC_POSITIONS 0
#endif

#ifndef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON 0
#endif

#if JSON_DIAGNOSTICS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS _diag
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS
#endif

#if JSON_DIAGNOSTIC_POSITIONS
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS _dp
#else
    #define NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS
#endif

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON _ldvcmp
#else
    #define NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_NO_VERSION
    #define NLOHMANN_JSON_NAMESPACE_NO_VERSION 0
#endif

// Construct the namespace ABI tags component
#define NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c) json_abi ## a ## b ## c
#define NLOHMANN_JSON_ABI_TAGS_CONCAT(a, b, c) \
    NLOHMANN_JSON_ABI_TAGS_CONCAT_EX(a, b, c)

#define NLOHMANN_JSON_ABI_TAGS                                       \
    NLOHMANN_JSON_ABI_TAGS_CONCAT(                                   \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTICS,                       \
            NLOHMANN_JSON_ABI_TAG_LEGACY_DISCARDED_VALUE_COMPARISON, \
            NLOHMANN_JSON_ABI_TAG_DIAGNOSTIC_POSITIONS)

// Construct the namespace version component
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch) \
    _v ## major ## _ ## minor ## _ ## patch
#define NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(major, minor, patch) \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT_EX(major, minor, patch)

#if NLOHMANN_JSON_NAMESPACE_NO_VERSION
#define NLOHMANN_JSON_NAMESPACE_VERSION
#else
#define NLOHMANN_JSON_NAMESPACE_VERSION                                 \
    NLOHMANN_JSON_NAMESPACE_VERSION_CONCAT(NLOHMANN_JSON_VERSION_MAJOR, \
                                           NLOHMANN_JSON_VERSION_MINOR, \
                                           NLOHMANN_JSON_VERSION_PATCH)
#endif

// Combine namespace components
#define NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b) a ## b
#define NLOHMANN_JSON_NAMESPACE_CONCAT(a, b) \
    NLOHMANN_JSON_NAMESPACE_CONCAT_EX(a, b)

#ifndef NLOHMANN_JSON_NAMESPACE
#define NLOHMANN_JSON_NAMESPACE               \
    nlohmann::NLOHMANN_JSON_NAMESPACE_CONCAT( \
            NLOHMANN_JSON_ABI_TAGS,           \
            NLOHMANN_JSON_NAMESPACE_VERSION)
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_BEGIN
#define NLOHMANN_JSON_NAMESPACE_BEGIN                \
    namespace nlohmann                               \
    {                                                \
    inline namespace NLOHMANN_JSON_NAMESPACE_CONCAT( \
                NLOHMANN_JSON_ABI_TAGS,              \
                NLOHMANN_JSON_NAMESPACE_VERSION)     \
    {
#endif

#ifndef NLOHMANN_JSON_NAMESPACE_END
#define NLOHMANN_JSON_NAMESPACE_END                                     \
    }  /* namespace (inline namespace) NOLINT(readability/namespace) */ \
    }  // namespace nlohmann
#endif

// #include <nlohmann/detail/conversions/from_json.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // transform
#include <array> // array
#include <forward_list> // forward_list
#include <iterator> // inserter, front_inserter, end
#include <map> // map
#include <string> // string
#include <tuple> // tuple, make_tuple
#include <type_traits> // is_arithmetic, is_same, is_enum, underlying_type, is_convertible
#include <unordered_map> // unordered_map
#include <utility> // pair, declval
#include <valarray> // valarray

// #include <nlohmann/detail/exceptions.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // nullptr_t
#include <exception> // exception
#if JSON_DIAGNOSTICS
    #include <numeric> // accumulate
#endif
#include <stdexcept> // runtime_error
#include <string> // to_string
#include <vector> // vector

// #include <nlohmann/detail/value_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <cstdint> // uint8_t
#include <string> // string

// #include <nlohmann/detail/macro_scope.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <utility> // declval, pair
// #include <nlohmann/detail/meta/detected.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <type_traits>

// #include <nlohmann/detail/meta/void_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename ...Ts> struct make_void
{
    using type = void;
};
template<typename ...Ts> using void_t = typename make_void<Ts...>::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// https://en.cppreference.com/w/cpp/experimental/is_detected
struct nonesuch
{
    nonesuch() = delete;
    ~nonesuch() = delete;
    nonesuch(nonesuch const&) = delete;
    nonesuch(nonesuch const&&) = delete;
    void operator=(nonesuch const&) = delete;
    void operator=(nonesuch&&) = delete;
};

template<class Default,
         class AlwaysVoid,
         template<class...> class Op,
         class... Args>
struct detector
{
    using value_t = std::false_type;
    using type = Default;
};

template<class Default, template<class...> class Op, class... Args>
struct detector<Default, void_t<Op<Args...>>, Op, Args...>
{
    using value_t = std::true_type;
    using type = Op<Args...>;
};

template<template<class...> class Op, class... Args>
using is_detected = typename detector<nonesuch, void, Op, Args...>::value_t;

template<template<class...> class Op, class... Args>
struct is_detected_lazy : is_detected<Op, Args...> { };

template<template<class...> class Op, class... Args>
using detected_t = typename detector<nonesuch, void, Op, Args...>::type;

template<class Default, template<class...> class Op, class... Args>
using detected_or = detector<Default, void, Op, Args...>;

template<class Default, template<class...> class Op, class... Args>
using detected_or_t = typename detected_or<Default, Op, Args...>::type;

template<class Expected, template<class...> class Op, class... Args>
using is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;

template<class To, template<class...> class Op, class... Args>
using is_detected_convertible =
    std::is_convertible<detected_t<Op, Args...>, To>;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/thirdparty/hedley/hedley.hpp>


//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2016-2021 Evan Nemerson <evan@nemerson.com>
// SPDX-License-Identifier: MIT

/* Hedley - https://nemequ.github.io/hedley
 * Created by Evan Nemerson <evan@nemerson.com>
 * SPDX-License-Identifier: CC0-1.0
 */

#if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)
#if defined(JSON_HEDLEY_VERSION)
    #undef JSON_HEDLEY_VERSION
#endif
#define JSON_HEDLEY_VERSION 15

#if defined(JSON_HEDLEY_STRINGIFY_EX)
    #undef JSON_HEDLEY_STRINGIFY_EX
#endif
#define JSON_HEDLEY_STRINGIFY_EX(x) #x

#if defined(JSON_HEDLEY_STRINGIFY)
    #undef JSON_HEDLEY_STRINGIFY
#endif
#define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)

#if defined(JSON_HEDLEY_CONCAT_EX)
    #undef JSON_HEDLEY_CONCAT_EX
#endif
#define JSON_HEDLEY_CONCAT_EX(a,b) a##b

#if defined(JSON_HEDLEY_CONCAT)
    #undef JSON_HEDLEY_CONCAT
#endif
#define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)

#if defined(JSON_HEDLEY_CONCAT3_EX)
    #undef JSON_HEDLEY_CONCAT3_EX
#endif
#define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c

#if defined(JSON_HEDLEY_CONCAT3)
    #undef JSON_HEDLEY_CONCAT3
#endif
#define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)

#if defined(JSON_HEDLEY_VERSION_ENCODE)
    #undef JSON_HEDLEY_VERSION_ENCODE
#endif
#define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))

#if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)

#if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)
    #undef JSON_HEDLEY_VERSION_DECODE_MINOR
#endif
#define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)

#if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)
    #undef JSON_HEDLEY_VERSION_DECODE_REVISION
#endif
#define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)

#if defined(JSON_HEDLEY_GNUC_VERSION)
    #undef JSON_HEDLEY_GNUC_VERSION
#endif
#if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)
#elif defined(__GNUC__)
    #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)
#endif

#if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)
    #undef JSON_HEDLEY_GNUC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GNUC_VERSION)
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION)
    #undef JSON_HEDLEY_MSVC_VERSION
#endif
#if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)
#elif defined(_MSC_FULL_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)
#elif defined(_MSC_VER) && !defined(__ICL)
    #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)
#endif

#if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)
    #undef JSON_HEDLEY_MSVC_VERSION_CHECK
#endif
#if !defined(JSON_HEDLEY_MSVC_VERSION)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)
#elif defined(_MSC_VER) && (_MSC_VER >= 1400)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))
#elif defined(_MSC_VER) && (_MSC_VER >= 1200)
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))
#else
    #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION)
    #undef JSON_HEDLEY_INTEL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)
#elif defined(__INTEL_COMPILER) && !defined(__ICL)
    #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_VERSION)
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #undef JSON_HEDLEY_INTEL_CL_VERSION
#endif
#if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)
    #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)
#endif

#if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)
    #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_INTEL_CL_VERSION)
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION)
    #undef JSON_HEDLEY_PGI_VERSION
#endif
#if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)
    #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)
#endif

#if defined(JSON_HEDLEY_PGI_VERSION_CHECK)
    #undef JSON_HEDLEY_PGI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PGI_VERSION)
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #undef JSON_HEDLEY_SUNPRO_VERSION
#endif
#if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)
#elif defined(__SUNPRO_C)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)
#elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)
#elif defined(__SUNPRO_CC)
    #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)
#endif

#if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)
    #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_SUNPRO_VERSION)
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#endif
#if defined(__EMSCRIPTEN__)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)
#endif

#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)
    #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION)
    #undef JSON_HEDLEY_ARM_VERSION
#endif
#if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)
#elif defined(__CC_ARM) && defined(__ARMCC_VERSION)
    #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)
#endif

#if defined(JSON_HEDLEY_ARM_VERSION_CHECK)
    #undef JSON_HEDLEY_ARM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_ARM_VERSION)
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION)
    #undef JSON_HEDLEY_IBM_VERSION
#endif
#if defined(__ibmxl__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)
#elif defined(__xlC__) && defined(__xlC_ver__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)
#elif defined(__xlC__)
    #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)
#endif

#if defined(JSON_HEDLEY_IBM_VERSION_CHECK)
    #undef JSON_HEDLEY_IBM_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IBM_VERSION)
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_VERSION)
    #undef JSON_HEDLEY_TI_VERSION
#endif
#if \
    defined(__TI_COMPILER_VERSION__) && \
    ( \
      defined(__TMS470__) || defined(__TI_ARM__) || \
      defined(__MSP430__) || \
      defined(__TMS320C2000__) \
    )
#if (__TI_COMPILER_VERSION__ >= 16000000)
    #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif
#endif

#if defined(JSON_HEDLEY_TI_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_VERSION)
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #undef JSON_HEDLEY_TI_CL2000_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)
    #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL2000_VERSION)
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #undef JSON_HEDLEY_TI_CL430_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)
    #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL430_VERSION)
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))
    #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_ARMCL_VERSION)
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #undef JSON_HEDLEY_TI_CL6X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)
    #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL6X_VERSION)
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #undef JSON_HEDLEY_TI_CL7X_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)
    #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CL7X_VERSION)
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION
#endif
#if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)
    #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))
#endif

#if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)
    #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TI_CLPRU_VERSION)
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION)
    #undef JSON_HEDLEY_CRAY_VERSION
#endif
#if defined(_CRAYC)
    #if defined(_RELEASE_PATCHLEVEL)
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)
    #else
        #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)
    #undef JSON_HEDLEY_CRAY_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_CRAY_VERSION)
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_IAR_VERSION)
    #undef JSON_HEDLEY_IAR_VERSION
#endif
#if defined(__IAR_SYSTEMS_ICC__)
    #if __VER__ > 1000
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))
    #else
        #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)
    #endif
#endif

#if defined(JSON_HEDLEY_IAR_VERSION_CHECK)
    #undef JSON_HEDLEY_IAR_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_IAR_VERSION)
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION)
    #undef JSON_HEDLEY_TINYC_VERSION
#endif
#if defined(__TINYC__)
    #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)
#endif

#if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)
    #undef JSON_HEDLEY_TINYC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION)
    #undef JSON_HEDLEY_DMC_VERSION
#endif
#if defined(__DMC__)
    #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)
#endif

#if defined(JSON_HEDLEY_DMC_VERSION_CHECK)
    #undef JSON_HEDLEY_DMC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_DMC_VERSION)
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #undef JSON_HEDLEY_COMPCERT_VERSION
#endif
#if defined(__COMPCERT_VERSION__)
    #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)
#endif

#if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)
    #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_COMPCERT_VERSION)
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION)
    #undef JSON_HEDLEY_PELLES_VERSION
#endif
#if defined(__POCC__)
    #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)
#endif

#if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)
    #undef JSON_HEDLEY_PELLES_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_PELLES_VERSION)
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #undef JSON_HEDLEY_MCST_LCC_VERSION
#endif
#if defined(__LCC__) && defined(__LCC_MINOR__)
    #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)
#endif

#if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)
    #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_GCC_VERSION)
    #undef JSON_HEDLEY_GCC_VERSION
#endif
#if \
    defined(JSON_HEDLEY_GNUC_VERSION) && \
    !defined(__clang__) && \
    !defined(JSON_HEDLEY_INTEL_VERSION) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_ARM_VERSION) && \
    !defined(JSON_HEDLEY_CRAY_VERSION) && \
    !defined(JSON_HEDLEY_TI_VERSION) && \
    !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL430_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \
    !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \
    !defined(__COMPCERT__) && \
    !defined(JSON_HEDLEY_MCST_LCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION
#endif

#if defined(JSON_HEDLEY_GCC_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_VERSION_CHECK
#endif
#if defined(JSON_HEDLEY_GCC_VERSION)
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))
#else
    #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)
#endif

#if defined(JSON_HEDLEY_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_ATTRIBUTE
#endif
#if \
  defined(__has_attribute) && \
  ( \
    (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \
  )
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)
#else
#  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#endif
#if defined(__has_attribute)
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#endif
#if \
    defined(__has_cpp_attribute) && \
    defined(__cplusplus) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)
    #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#endif
#if !defined(__cplusplus) || !defined(__has_cpp_attribute)
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#elif \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_IAR_VERSION) && \
    (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \
    (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)
#else
    #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#endif
#if defined(__has_cpp_attribute) && defined(__cplusplus)
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_BUILTIN)
    #undef JSON_HEDLEY_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)
    #undef JSON_HEDLEY_GCC_HAS_BUILTIN
#endif
#if defined(__has_builtin)
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)
#else
    #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_FEATURE)
    #undef JSON_HEDLEY_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)
#else
    #define JSON_HEDLEY_HAS_FEATURE(feature) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)
    #undef JSON_HEDLEY_GNUC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_FEATURE)
    #undef JSON_HEDLEY_GCC_HAS_FEATURE
#endif
#if defined(__has_feature)
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)
#else
    #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_EXTENSION)
    #undef JSON_HEDLEY_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)
#else
    #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)
    #undef JSON_HEDLEY_GCC_HAS_EXTENSION
#endif
#if defined(__has_extension)
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)
#else
    #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#endif
#if defined(__has_declspec_attribute)
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)
#else
    #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_HAS_WARNING)
    #undef JSON_HEDLEY_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)
#else
    #define JSON_HEDLEY_HAS_WARNING(warning) (0)
#endif

#if defined(JSON_HEDLEY_GNUC_HAS_WARNING)
    #undef JSON_HEDLEY_GNUC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_GCC_HAS_WARNING)
    #undef JSON_HEDLEY_GCC_HAS_WARNING
#endif
#if defined(__has_warning)
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)
#else
    #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    defined(__clang__) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \
    (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))
    #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_PRAGMA(value) __pragma(value)
#else
    #define JSON_HEDLEY_PRAGMA(value)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)
    #undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#endif
#if defined(JSON_HEDLEY_DIAGNOSTIC_POP)
    #undef JSON_HEDLEY_DIAGNOSTIC_POP
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))
    #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))
#elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)")
    #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_PUSH
    #define JSON_HEDLEY_DIAGNOSTIC_POP
#endif

/* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat")
#    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions")
#      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions")
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    _Pragma("clang diagnostic ignored \"-Wc++1z-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      else
#        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    _Pragma("clang diagnostic ignored \"-Wc++17-extensions\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#      endif
#    else
#      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wc++98-compat\"") \
    xpr \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    endif
#  endif
#endif
#if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x
#endif

#if defined(JSON_HEDLEY_CONST_CAST)
    #undef JSON_HEDLEY_CONST_CAST
#endif
#if defined(__cplusplus)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))
#elif \
  JSON_HEDLEY_HAS_WARNING("-Wcast-qual") || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_REINTERPRET_CAST)
    #undef JSON_HEDLEY_REINTERPRET_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))
#else
    #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_STATIC_CAST)
    #undef JSON_HEDLEY_STATIC_CAST
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))
#else
    #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))
#endif

#if defined(JSON_HEDLEY_CPP_CAST)
    #undef JSON_HEDLEY_CPP_CAST
#endif
#if defined(__cplusplus)
#  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast")
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wold-style-cast\"") \
    ((T) (expr)) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)
#    define JSON_HEDLEY_CPP_CAST(T, expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("diag_suppress=Pe137") \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))
#  endif
#else
#  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215")
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \"-Wunknown-pragmas\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \"-Wunknown-attributes\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \"-Wdeprecated-declarations\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)")
#elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))
#elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098")
#elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)")
#elif \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097")
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wcast-qual")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \"-Wcast-qual\"")
#elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \"-Wcast-qual\"")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#endif

#if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)
    #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunused-function")
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \"-Wunused-function\"")
#elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))
#elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142")
#else
    #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#endif

#if defined(JSON_HEDLEY_DEPRECATED)
    #undef JSON_HEDLEY_DEPRECATED
#endif
#if defined(JSON_HEDLEY_DEPRECATED_FOR)
    #undef JSON_HEDLEY_DEPRECATED_FOR
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since " # since))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since " #since "; use " #replacement))
#elif \
    (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since " #since)))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since " #since "; use " #replacement)))
#elif defined(__cplusplus) && (__cplusplus >= 201402L)
    #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since)]])
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since " #since "; use " #replacement)]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated")
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated")
#else
    #define JSON_HEDLEY_DEPRECATED(since)
    #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)
#endif

#if defined(JSON_HEDLEY_UNAVAILABLE)
    #undef JSON_HEDLEY_UNAVAILABLE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until " #available_since)))
#else
    #define JSON_HEDLEY_UNAVAILABLE(available_since)
#endif

#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT
#endif
#if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)
    #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))
#elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)
    #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])
#elif defined(_Check_return_) /* SAL */
    #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_
#else
    #define JSON_HEDLEY_WARN_UNUSED_RESULT
    #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)
#endif

#if defined(JSON_HEDLEY_SENTINEL)
    #undef JSON_HEDLEY_SENTINEL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))
#else
    #define JSON_HEDLEY_SENTINEL(position)
#endif

#if defined(JSON_HEDLEY_NO_RETURN)
    #undef JSON_HEDLEY_NO_RETURN
#endif
#if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NO_RETURN __noreturn
#elif \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L
    #define JSON_HEDLEY_NO_RETURN _Noreturn
#elif defined(__cplusplus) && (__cplusplus >= 201103L)
    #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)
#else
    #define JSON_HEDLEY_NO_RETURN
#endif

#if defined(JSON_HEDLEY_NO_ESCAPE)
    #undef JSON_HEDLEY_NO_ESCAPE
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)
    #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))
#else
    #define JSON_HEDLEY_NO_ESCAPE
#endif

#if defined(JSON_HEDLEY_UNREACHABLE)
    #undef JSON_HEDLEY_UNREACHABLE
#endif
#if defined(JSON_HEDLEY_UNREACHABLE_RETURN)
    #undef JSON_HEDLEY_UNREACHABLE_RETURN
#endif
#if defined(JSON_HEDLEY_ASSUME)
    #undef JSON_HEDLEY_ASSUME
#endif
#if \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_ASSUME(expr) __assume(expr)
#elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)
    #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)
#elif \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
    #if defined(__cplusplus)
        #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)
    #else
        #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)
    #endif
#endif
#if \
    (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()
#elif defined(JSON_HEDLEY_ASSUME)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif
#if !defined(JSON_HEDLEY_ASSUME)
    #if defined(JSON_HEDLEY_UNREACHABLE)
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))
    #else
        #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)
    #endif
#endif
#if defined(JSON_HEDLEY_UNREACHABLE)
    #if  \
        JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))
    #else
        #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()
    #endif
#else
    #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)
#endif
#if !defined(JSON_HEDLEY_UNREACHABLE)
    #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)
#endif

JSON_HEDLEY_DIAGNOSTIC_PUSH
#if JSON_HEDLEY_HAS_WARNING("-Wpedantic")
    #pragma clang diagnostic ignored "-Wpedantic"
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic") && defined(__cplusplus)
    #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros",4,0,0)
    #if defined(__clang__)
        #pragma clang diagnostic ignored "-Wvariadic-macros"
    #elif defined(JSON_HEDLEY_GCC_VERSION)
        #pragma GCC diagnostic ignored "-Wvariadic-macros"
    #endif
#endif
#if defined(JSON_HEDLEY_NON_NULL)
    #undef JSON_HEDLEY_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))
#else
    #define JSON_HEDLEY_NON_NULL(...)
#endif
JSON_HEDLEY_DIAGNOSTIC_POP

#if defined(JSON_HEDLEY_PRINTF_FORMAT)
    #undef JSON_HEDLEY_PRINTF_FORMAT
#endif
#if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))
#elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))
#elif \
    JSON_HEDLEY_HAS_ATTRIBUTE(format) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))
#else
    #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)
#endif

#if defined(JSON_HEDLEY_CONSTEXPR)
    #undef JSON_HEDLEY_CONSTEXPR
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)
    #endif
#endif
#if !defined(JSON_HEDLEY_CONSTEXPR)
    #define JSON_HEDLEY_CONSTEXPR
#endif

#if defined(JSON_HEDLEY_PREDICT)
    #undef JSON_HEDLEY_PREDICT
#endif
#if defined(JSON_HEDLEY_LIKELY)
    #undef JSON_HEDLEY_LIKELY
#endif
#if defined(JSON_HEDLEY_UNLIKELY)
    #undef JSON_HEDLEY_UNLIKELY
#endif
#if defined(JSON_HEDLEY_UNPREDICTABLE)
    #undef JSON_HEDLEY_UNPREDICTABLE
#endif
#if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))
#endif
#if \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))
#  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )
#  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )
#elif \
  (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \
  JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) \
    (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \
    }))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \
    (__extension__ ({ \
        double hedley_probability_ = (probability); \
        ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \
    }))
#  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)
#  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)
#else
#  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))
#  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))
#  define JSON_HEDLEY_LIKELY(expr) (!!(expr))
#  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))
#endif
#if !defined(JSON_HEDLEY_UNPREDICTABLE)
    #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)
#endif

#if defined(JSON_HEDLEY_MALLOC)
    #undef JSON_HEDLEY_MALLOC
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory")
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_MALLOC __declspec(restrict)
#else
    #define JSON_HEDLEY_MALLOC
#endif

#if defined(JSON_HEDLEY_PURE)
    #undef JSON_HEDLEY_PURE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#  define JSON_HEDLEY_PURE __attribute__((__pure__))
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
#  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data")
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \
    )
#  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;")
#else
#  define JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_CONST)
    #undef JSON_HEDLEY_CONST
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(const) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_CONST __attribute__((__const__))
#elif \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)
    #define JSON_HEDLEY_CONST _Pragma("no_side_effect")
#else
    #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE
#endif

#if defined(JSON_HEDLEY_RESTRICT)
    #undef JSON_HEDLEY_RESTRICT
#endif
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT restrict
#elif \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \
    defined(__clang__) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RESTRICT __restrict
#elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)
    #define JSON_HEDLEY_RESTRICT _Restrict
#else
    #define JSON_HEDLEY_RESTRICT
#endif

#if defined(JSON_HEDLEY_INLINE)
    #undef JSON_HEDLEY_INLINE
#endif
#if \
    (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \
    (defined(__cplusplus) && (__cplusplus >= 199711L))
    #define JSON_HEDLEY_INLINE inline
#elif \
    defined(JSON_HEDLEY_GCC_VERSION) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)
    #define JSON_HEDLEY_INLINE __inline__
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_INLINE __inline
#else
    #define JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_ALWAYS_INLINE)
    #undef JSON_HEDLEY_ALWAYS_INLINE
#endif
#if \
  JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
  JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
  JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
  JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
  JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
  (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
  (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
  (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
  (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
  JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
  JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
  JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
  JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
  JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_ALWAYS_INLINE __forceinline
#elif defined(__cplusplus) && \
    ( \
      JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
      JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
      JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
      JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
      JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
      JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \
    )
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced")
#else
#  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE
#endif

#if defined(JSON_HEDLEY_NEVER_INLINE)
    #undef JSON_HEDLEY_NEVER_INLINE
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \
    JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \
    (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \
    (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \
    (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \
    (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \
    JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \
    JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \
    JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline")
#elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;")
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
    #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never")
#elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)
    #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)
    #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)
#else
    #define JSON_HEDLEY_NEVER_INLINE
#endif

#if defined(JSON_HEDLEY_PRIVATE)
    #undef JSON_HEDLEY_PRIVATE
#endif
#if defined(JSON_HEDLEY_PUBLIC)
    #undef JSON_HEDLEY_PUBLIC
#endif
#if defined(JSON_HEDLEY_IMPORT)
    #undef JSON_HEDLEY_IMPORT
#endif
#if defined(_WIN32) || defined(__CYGWIN__)
#  define JSON_HEDLEY_PRIVATE
#  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)
#  define JSON_HEDLEY_IMPORT   __declspec(dllimport)
#else
#  if \
    JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    ( \
      defined(__TI_EABI__) && \
      ( \
        (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \
        JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \
      ) \
    ) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
#    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden")))
#    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default")))
#  else
#    define JSON_HEDLEY_PRIVATE
#    define JSON_HEDLEY_PUBLIC
#  endif
#  define JSON_HEDLEY_IMPORT    extern
#endif

#if defined(JSON_HEDLEY_NO_THROW)
    #undef JSON_HEDLEY_NO_THROW
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))
#elif \
    JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)
    #define JSON_HEDLEY_NO_THROW __declspec(nothrow)
#else
    #define JSON_HEDLEY_NO_THROW
#endif

#if defined(JSON_HEDLEY_FALL_THROUGH)
    #undef JSON_HEDLEY_FALL_THROUGH
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])
#elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)
    #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])
#elif defined(__fallthrough) /* SAL */
    #define JSON_HEDLEY_FALL_THROUGH __fallthrough
#else
    #define JSON_HEDLEY_FALL_THROUGH
#endif

#if defined(JSON_HEDLEY_RETURNS_NON_NULL)
    #undef JSON_HEDLEY_RETURNS_NON_NULL
#endif
#if \
    JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))
#elif defined(_Ret_notnull_) /* SAL */
    #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_
#else
    #define JSON_HEDLEY_RETURNS_NON_NULL
#endif

#if defined(JSON_HEDLEY_ARRAY_PARAM)
    #undef JSON_HEDLEY_ARRAY_PARAM
#endif
#if \
    defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \
    !defined(__STDC_NO_VLA__) && \
    !defined(__cplusplus) && \
    !defined(JSON_HEDLEY_PGI_VERSION) && \
    !defined(JSON_HEDLEY_TINYC_VERSION)
    #define JSON_HEDLEY_ARRAY_PARAM(name) (name)
#else
    #define JSON_HEDLEY_ARRAY_PARAM(name)
#endif

#if defined(JSON_HEDLEY_IS_CONSTANT)
    #undef JSON_HEDLEY_IS_CONSTANT
#endif
#if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)
    #undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#endif
/* JSON_HEDLEY_IS_CONSTEXPR_ is for
   HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #undef JSON_HEDLEY_IS_CONSTEXPR_
#endif
#if \
    JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \
    JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
    JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
    JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \
    JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \
    JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
    JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \
    (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \
    JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
    JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)
    #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)
#endif
#if !defined(__cplusplus)
#  if \
       JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \
       JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \
       JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)
#endif
#  elif \
       ( \
          defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \
          !defined(JSON_HEDLEY_SUNPRO_VERSION) && \
          !defined(JSON_HEDLEY_PGI_VERSION) && \
          !defined(JSON_HEDLEY_IAR_VERSION)) || \
       (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \
       JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \
       JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \
       JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \
       JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)
#if defined(__INTPTR_TYPE__)
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)
#else
    #include <stdint.h>
    #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)
#endif
#  elif \
       defined(JSON_HEDLEY_GCC_VERSION) || \
       defined(JSON_HEDLEY_INTEL_VERSION) || \
       defined(JSON_HEDLEY_TINYC_VERSION) || \
       defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \
       JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \
       defined(JSON_HEDLEY_TI_CL2000_VERSION) || \
       defined(JSON_HEDLEY_TI_CL6X_VERSION) || \
       defined(JSON_HEDLEY_TI_CL7X_VERSION) || \
       defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \
       defined(__clang__)
#    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \
        sizeof(void) != \
        sizeof(*( \
                  1 ? \
                  ((void*) ((expr) * 0L) ) : \
((struct { char v[sizeof(void) * 2]; } *) 1) \
                ) \
              ) \
                                            )
#  endif
#endif
#if defined(JSON_HEDLEY_IS_CONSTEXPR_)
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))
#else
    #if !defined(JSON_HEDLEY_IS_CONSTANT)
        #define JSON_HEDLEY_IS_CONSTANT(expr) (0)
    #endif
    #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)
#endif

#if defined(JSON_HEDLEY_BEGIN_C_DECLS)
    #undef JSON_HEDLEY_BEGIN_C_DECLS
#endif
#if defined(JSON_HEDLEY_END_C_DECLS)
    #undef JSON_HEDLEY_END_C_DECLS
#endif
#if defined(JSON_HEDLEY_C_DECL)
    #undef JSON_HEDLEY_C_DECL
#endif
#if defined(__cplusplus)
    #define JSON_HEDLEY_BEGIN_C_DECLS extern "C" {
    #define JSON_HEDLEY_END_C_DECLS }
    #define JSON_HEDLEY_C_DECL extern "C"
#else
    #define JSON_HEDLEY_BEGIN_C_DECLS
    #define JSON_HEDLEY_END_C_DECLS
    #define JSON_HEDLEY_C_DECL
#endif

#if defined(JSON_HEDLEY_STATIC_ASSERT)
    #undef JSON_HEDLEY_STATIC_ASSERT
#endif
#if \
  !defined(__cplusplus) && ( \
      (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \
      (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \
      JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \
      JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \
      defined(_Static_assert) \
    )
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)
#elif \
  (defined(__cplusplus) && (__cplusplus >= 201103L)) || \
  JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))
#else
#  define JSON_HEDLEY_STATIC_ASSERT(expr, message)
#endif

#if defined(JSON_HEDLEY_NULL)
    #undef JSON_HEDLEY_NULL
#endif
#if defined(__cplusplus)
    #if __cplusplus >= 201103L
        #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)
    #elif defined(NULL)
        #define JSON_HEDLEY_NULL NULL
    #else
        #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)
    #endif
#elif defined(NULL)
    #define JSON_HEDLEY_NULL NULL
#else
    #define JSON_HEDLEY_NULL ((void*) 0)
#endif

#if defined(JSON_HEDLEY_MESSAGE)
    #undef JSON_HEDLEY_MESSAGE
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_MESSAGE(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(message msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)
#elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)
#elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)
#  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_WARNING)
    #undef JSON_HEDLEY_WARNING
#endif
#if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas")
#  define JSON_HEDLEY_WARNING(msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \
    JSON_HEDLEY_PRAGMA(clang warning msg) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#elif \
  JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \
  JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \
  JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)
#elif \
  JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \
  JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))
#else
#  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)
#endif

#if defined(JSON_HEDLEY_REQUIRE)
    #undef JSON_HEDLEY_REQUIRE
#endif
#if defined(JSON_HEDLEY_REQUIRE_MSG)
    #undef JSON_HEDLEY_REQUIRE_MSG
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)
#  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat")
#    define JSON_HEDLEY_REQUIRE(expr) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), #expr, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \
    JSON_HEDLEY_DIAGNOSTIC_PUSH \
    _Pragma("clang diagnostic ignored \"-Wgcc-compat\"") \
    __attribute__((diagnose_if(!(expr), msg, "error"))) \
    JSON_HEDLEY_DIAGNOSTIC_POP
#  else
#    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error")))
#    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error")))
#  endif
#else
#  define JSON_HEDLEY_REQUIRE(expr)
#  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)
#endif

#if defined(JSON_HEDLEY_FLAGS)
    #undef JSON_HEDLEY_FLAGS
#endif
#if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"))
    #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))
#else
    #define JSON_HEDLEY_FLAGS
#endif

#if defined(JSON_HEDLEY_FLAGS_CAST)
    #undef JSON_HEDLEY_FLAGS_CAST
#endif
#if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ ({ \
        JSON_HEDLEY_DIAGNOSTIC_PUSH \
        _Pragma("warning(disable:188)") \
        ((T) (expr)); \
        JSON_HEDLEY_DIAGNOSTIC_POP \
    }))
#else
#  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)
#endif

#if defined(JSON_HEDLEY_EMPTY_BASES)
    #undef JSON_HEDLEY_EMPTY_BASES
#endif
#if \
    (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \
    JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)
    #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)
#else
    #define JSON_HEDLEY_EMPTY_BASES
#endif

/* Remaining macros are deprecated. */

#if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)
    #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#endif
#if defined(__clang__)
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)
#else
    #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)
#endif

#if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)
    #undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#endif
#define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)

#if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)
    #undef JSON_HEDLEY_CLANG_HAS_FEATURE
#endif
#define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)

#if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)
    #undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#endif
#define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)

#if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)
    #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#endif
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)

#if defined(JSON_HEDLEY_CLANG_HAS_WARNING)
    #undef JSON_HEDLEY_CLANG_HAS_WARNING
#endif
#define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)

#endif /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */


// This file contains all internal macro definitions (except those affecting ABI)
// You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them

// #include <nlohmann/detail/abi_macros.hpp>


// exclude unsupported compilers
#if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)
    #if defined(__clang__)
        #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400
            #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))
        #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800
            #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"
        #endif
    #endif
#endif

// C++ language standard detection
// if the user manually specified the used C++ version, this is skipped
#if !defined(JSON_HAS_CPP_26) && !defined(JSON_HAS_CPP_23) && !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)
    #if (defined(__cplusplus) && __cplusplus > 202302L) || (defined(_MSVC_LANG) && _MSVC_LANG > 202302L)
        #define JSON_HAS_CPP_26
        #define JSON_HAS_CPP_23
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG > 202002L)
        #define JSON_HAS_CPP_23
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG > 201703L)
        #define JSON_HAS_CPP_20
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201402L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) // fix for issue #464
        #define JSON_HAS_CPP_17
        #define JSON_HAS_CPP_14
    #elif (defined(__cplusplus) && __cplusplus > 201103L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)
        #define JSON_HAS_CPP_14
    #endif
    // the cpp 11 flag is always specified because it is the minimal required version
    #define JSON_HAS_CPP_11
#endif

#ifdef __has_include
    #if __has_include(<version>)
        #include <version>
    #endif
#endif

#if !defined(JSON_HAS_FILESYSTEM) && !defined(JSON_HAS_EXPERIMENTAL_FILESYSTEM)
    #ifdef JSON_HAS_CPP_17
        #if defined(__cpp_lib_filesystem)
            #define JSON_HAS_FILESYSTEM 1
        #elif defined(__cpp_lib_experimental_filesystem)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif !defined(__has_include)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #elif __has_include(<filesystem>)
            #define JSON_HAS_FILESYSTEM 1
        #elif __has_include(<experimental/filesystem>)
            #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 1
        #endif

        // std::filesystem does not work on MinGW GCC 8: https://sourceforge.net/p/mingw-w64/bugs/737/
        #if defined(__MINGW32__) && defined(__GNUC__) && __GNUC__ == 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before GCC 8: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__GNUC__) && !defined(__clang__) && __GNUC__ < 8
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before Clang 7: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(__clang_major__) && __clang_major__ < 7
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before MSVC 19.14: https://en.cppreference.com/w/cpp/compiler_support
        #if defined(_MSC_VER) && _MSC_VER < 1914
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before iOS 13
        #if defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED < 130000
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif

        // no filesystem support before macOS Catalina
        #if defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED < 101500
            #undef JSON_HAS_FILESYSTEM
            #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
        #endif
    #endif
#endif

#ifndef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #define JSON_HAS_EXPERIMENTAL_FILESYSTEM 0
#endif

#ifndef JSON_HAS_FILESYSTEM
    #define JSON_HAS_FILESYSTEM 0
#endif

#ifndef JSON_HAS_THREE_WAY_COMPARISON
    #if defined(__cpp_impl_three_way_comparison) && __cpp_impl_three_way_comparison >= 201907L \
        && defined(__cpp_lib_three_way_comparison) && __cpp_lib_three_way_comparison >= 201907L
        #define JSON_HAS_THREE_WAY_COMPARISON 1
    #else
        #define JSON_HAS_THREE_WAY_COMPARISON 0
    #endif
#endif

#ifndef JSON_HAS_RANGES
    // ranges header shipping in GCC 11.1.0 (released 2021-04-27) has a syntax error
    #if defined(__GLIBCXX__) && __GLIBCXX__ == 20210427
        #define JSON_HAS_RANGES 0
    #elif defined(__cpp_lib_ranges)
        #define JSON_HAS_RANGES 1
    #else
        #define JSON_HAS_RANGES 0
    #endif
#endif

#ifndef JSON_HAS_STATIC_RTTI
    #if !defined(_HAS_STATIC_RTTI) || _HAS_STATIC_RTTI != 0
        #define JSON_HAS_STATIC_RTTI 1
    #else
        #define JSON_HAS_STATIC_RTTI 0
    #endif
#endif

#ifdef JSON_HAS_CPP_17
    #define JSON_INLINE_VARIABLE inline
#else
    #define JSON_INLINE_VARIABLE
#endif

#if JSON_HEDLEY_HAS_ATTRIBUTE(no_unique_address)
    #define JSON_NO_UNIQUE_ADDRESS [[no_unique_address]]
#else
    #define JSON_NO_UNIQUE_ADDRESS
#endif

// disable documentation warnings on clang
#if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wdocumentation"
    #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"
#endif

// allow disabling exceptions
#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)
    #define JSON_THROW(exception) throw exception
    #define JSON_TRY try
    #define JSON_CATCH(exception) catch(exception)
    #define JSON_INTERNAL_CATCH(exception) catch(exception)
#else
    #include <cstdlib>
    #define JSON_THROW(exception) std::abort()
    #define JSON_TRY if(true)
    #define JSON_CATCH(exception) if(false)
    #define JSON_INTERNAL_CATCH(exception) if(false)
#endif

// override exception macros
#if defined(JSON_THROW_USER)
    #undef JSON_THROW
    #define JSON_THROW JSON_THROW_USER
#endif
#if defined(JSON_TRY_USER)
    #undef JSON_TRY
    #define JSON_TRY JSON_TRY_USER
#endif
#if defined(JSON_CATCH_USER)
    #undef JSON_CATCH
    #define JSON_CATCH JSON_CATCH_USER
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_CATCH_USER
#endif
#if defined(JSON_INTERNAL_CATCH_USER)
    #undef JSON_INTERNAL_CATCH
    #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER
#endif

// allow overriding assert
#if !defined(JSON_ASSERT)
    #include <cassert> // assert
    #define JSON_ASSERT(x) assert(x)
#endif

// allow accessing some private functions (needed by the test suite)
#if defined(JSON_TESTS_PRIVATE)
    #define JSON_PRIVATE_UNLESS_TESTED public
#else
    #define JSON_PRIVATE_UNLESS_TESTED private
#endif

/*!
@brief macro to briefly define a mapping between an enum and JSON
@def NLOHMANN_JSON_SERIALIZE_ENUM
@since version 3.4.0
*/
#define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \
    template<typename BasicJsonType>                                                            \
    inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \
    {                                                                                           \
        /* NOLINTNEXTLINE(modernize-type-traits) we use C++11 */                                \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        /* NOLINTNEXTLINE(modernize-avoid-c-arrays) we don't want to depend on <array> */       \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \
        {                                                                                       \
            return ej_pair.first == e;                                                          \
        });                                                                                     \
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \
    }                                                                                           \
    template<typename BasicJsonType>                                                            \
    inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \
    {                                                                                           \
        /* NOLINTNEXTLINE(modernize-type-traits) we use C++11 */                                \
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \
        /* NOLINTNEXTLINE(modernize-avoid-c-arrays) we don't want to depend on <array> */       \
        static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \
        auto it = std::find_if(std::begin(m), std::end(m),                                      \
                               [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \
        {                                                                                       \
            return ej_pair.second == j;                                                         \
        });                                                                                     \
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \
    }

// Ugly macros to avoid uglier copy-paste when specializing basic_json. They
// may be removed in the future once the class is split.

#define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \
    template<template<typename, typename, typename...> class ObjectType,   \
             template<typename, typename...> class ArrayType,              \
             class StringType, class BooleanType, class NumberIntegerType, \
             class NumberUnsignedType, class NumberFloatType,              \
             template<typename> class AllocatorType,                       \
             template<typename, typename = void> class JSONSerializer,     \
             class BinaryType,                                             \
             class CustomBaseClass>

#define NLOHMANN_BASIC_JSON_TPL                                            \
    basic_json<ObjectType, ArrayType, StringType, BooleanType,             \
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \
    AllocatorType, JSONSerializer, BinaryType, CustomBaseClass>

// Macros to simplify conversion from/to types

#define NLOHMANN_JSON_EXPAND( x ) x
#define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME
#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \
        NLOHMANN_JSON_PASTE64, \
        NLOHMANN_JSON_PASTE63, \
        NLOHMANN_JSON_PASTE62, \
        NLOHMANN_JSON_PASTE61, \
        NLOHMANN_JSON_PASTE60, \
        NLOHMANN_JSON_PASTE59, \
        NLOHMANN_JSON_PASTE58, \
        NLOHMANN_JSON_PASTE57, \
        NLOHMANN_JSON_PASTE56, \
        NLOHMANN_JSON_PASTE55, \
        NLOHMANN_JSON_PASTE54, \
        NLOHMANN_JSON_PASTE53, \
        NLOHMANN_JSON_PASTE52, \
        NLOHMANN_JSON_PASTE51, \
        NLOHMANN_JSON_PASTE50, \
        NLOHMANN_JSON_PASTE49, \
        NLOHMANN_JSON_PASTE48, \
        NLOHMANN_JSON_PASTE47, \
        NLOHMANN_JSON_PASTE46, \
        NLOHMANN_JSON_PASTE45, \
        NLOHMANN_JSON_PASTE44, \
        NLOHMANN_JSON_PASTE43, \
        NLOHMANN_JSON_PASTE42, \
        NLOHMANN_JSON_PASTE41, \
        NLOHMANN_JSON_PASTE40, \
        NLOHMANN_JSON_PASTE39, \
        NLOHMANN_JSON_PASTE38, \
        NLOHMANN_JSON_PASTE37, \
        NLOHMANN_JSON_PASTE36, \
        NLOHMANN_JSON_PASTE35, \
        NLOHMANN_JSON_PASTE34, \
        NLOHMANN_JSON_PASTE33, \
        NLOHMANN_JSON_PASTE32, \
        NLOHMANN_JSON_PASTE31, \
        NLOHMANN_JSON_PASTE30, \
        NLOHMANN_JSON_PASTE29, \
        NLOHMANN_JSON_PASTE28, \
        NLOHMANN_JSON_PASTE27, \
        NLOHMANN_JSON_PASTE26, \
        NLOHMANN_JSON_PASTE25, \
        NLOHMANN_JSON_PASTE24, \
        NLOHMANN_JSON_PASTE23, \
        NLOHMANN_JSON_PASTE22, \
        NLOHMANN_JSON_PASTE21, \
        NLOHMANN_JSON_PASTE20, \
        NLOHMANN_JSON_PASTE19, \
        NLOHMANN_JSON_PASTE18, \
        NLOHMANN_JSON_PASTE17, \
        NLOHMANN_JSON_PASTE16, \
        NLOHMANN_JSON_PASTE15, \
        NLOHMANN_JSON_PASTE14, \
        NLOHMANN_JSON_PASTE13, \
        NLOHMANN_JSON_PASTE12, \
        NLOHMANN_JSON_PASTE11, \
        NLOHMANN_JSON_PASTE10, \
        NLOHMANN_JSON_PASTE9, \
        NLOHMANN_JSON_PASTE8, \
        NLOHMANN_JSON_PASTE7, \
        NLOHMANN_JSON_PASTE6, \
        NLOHMANN_JSON_PASTE5, \
        NLOHMANN_JSON_PASTE4, \
        NLOHMANN_JSON_PASTE3, \
        NLOHMANN_JSON_PASTE2, \
        NLOHMANN_JSON_PASTE1)(__VA_ARGS__))
#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)
#define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)
#define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)
#define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)
#define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)
#define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)
#define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)
#define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)
#define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)
#define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)
#define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
#define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)
#define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)
#define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)
#define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)
#define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)
#define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)
#define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)
#define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)
#define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)
#define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)
#define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)
#define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)
#define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)
#define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)
#define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)
#define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)
#define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)
#define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)
#define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)
#define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)
#define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)
#define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)
#define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)
#define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)
#define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)
#define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)
#define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)
#define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)
#define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)
#define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)
#define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)
#define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)
#define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)
#define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)
#define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)
#define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)
#define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)
#define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)
#define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)
#define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)
#define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)
#define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)
#define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)
#define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)
#define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)
#define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)
#define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)
#define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)
#define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)
#define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)
#define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)
#define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)

#define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;
#define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);
#define NLOHMANN_JSON_FROM_WITH_DEFAULT(v1) nlohmann_json_t.v1 = !nlohmann_json_j.is_null() ? nlohmann_json_j.value(#v1, nlohmann_json_default_obj.v1) : nlohmann_json_default_obj.v1;

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE
@since version 3.9.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT
@since version 3.11.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE
@since version 3.11.3
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE
@since version 3.9.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT
@since version 3.11.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE
@since version 3.11.3
@sa https://json.nlohmann.me/api/macros/nlohmann_define_type_non_intrusive/
*/
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(Type, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_WITH_DEFAULT(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_INTRUSIVE_ONLY_SERIALIZE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    friend void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_WITH_DEFAULT(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) } \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void from_json(const BasicJsonType& nlohmann_json_j, Type& nlohmann_json_t) { nlohmann::from_json(nlohmann_json_j, static_cast<BaseType&>(nlohmann_json_t)); const Type nlohmann_json_default_obj{}; NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM_WITH_DEFAULT, __VA_ARGS__)) }

/*!
@brief macro
@def NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE
@since version 3.12.0
@sa https://json.nlohmann.me/api/macros/nlohmann_define_derived_type/
*/
#define NLOHMANN_DEFINE_DERIVED_TYPE_NON_INTRUSIVE_ONLY_SERIALIZE(Type, BaseType, ...)  \
    template<typename BasicJsonType, nlohmann::detail::enable_if_t<nlohmann::detail::is_basic_json<BasicJsonType>::value, int> = 0> \
    void to_json(BasicJsonType& nlohmann_json_j, const Type& nlohmann_json_t) { nlohmann::to_json(nlohmann_json_j, static_cast<const BaseType &>(nlohmann_json_t)); NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) }

// inspired from https://stackoverflow.com/a/26745591
// allows calling any std function as if (e.g., with begin):
// using std::begin; begin(x);
//
// it allows using the detected idiom to retrieve the return type
// of such an expression
#define NLOHMANN_CAN_CALL_STD_FUNC_IMPL(std_name)                                 \
    namespace detail {                                                            \
    using std::std_name;                                                          \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    }                                                                             \
    \
    namespace detail2 {                                                           \
    struct std_name##_tag                                                         \
    {                                                                             \
    };                                                                            \
    \
    template<typename... T>                                                       \
    std_name##_tag std_name(T&&...);                                              \
    \
    template<typename... T>                                                       \
    using result_of_##std_name = decltype(std_name(std::declval<T>()...));        \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name                                              \
    {                                                                             \
        static constexpr auto const value = ::nlohmann::detail::                  \
                                            is_detected_exact<std_name##_tag, result_of_##std_name, T...>::value; \
    };                                                                            \
    } /* namespace detail2 */ \
    \
    template<typename... T>                                                       \
    struct would_call_std_##std_name : detail2::would_call_std_##std_name<T...>   \
    {                                                                             \
    }

#ifndef JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_USE_IMPLICIT_CONVERSIONS 1
#endif

#if JSON_USE_IMPLICIT_CONVERSIONS
    #define JSON_EXPLICIT
#else
    #define JSON_EXPLICIT explicit
#endif

#ifndef JSON_DISABLE_ENUM_SERIALIZATION
    #define JSON_DISABLE_ENUM_SERIALIZATION 0
#endif

#ifndef JSON_USE_GLOBAL_UDLS
    #define JSON_USE_GLOBAL_UDLS 1
#endif

#if JSON_HAS_THREE_WAY_COMPARISON
    #include <compare> // partial_ordering
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////////////
// JSON type enumeration //
///////////////////////////

/*!
@brief the JSON type enumeration

This enumeration collects the different JSON types. It is internally used to
distinguish the stored values, and the functions @ref basic_json::is_null(),
@ref basic_json::is_object(), @ref basic_json::is_array(),
@ref basic_json::is_string(), @ref basic_json::is_boolean(),
@ref basic_json::is_number() (with @ref basic_json::is_number_integer(),
@ref basic_json::is_number_unsigned(), and @ref basic_json::is_number_float()),
@ref basic_json::is_discarded(), @ref basic_json::is_primitive(), and
@ref basic_json::is_structured() rely on it.

@note There are three enumeration entries (number_integer, number_unsigned, and
number_float), because the library distinguishes these three types for numbers:
@ref basic_json::number_unsigned_t is used for unsigned integers,
@ref basic_json::number_integer_t is used for signed integers, and
@ref basic_json::number_float_t is used for floating-point numbers or to
approximate integers which do not fit in the limits of their respective type.

@sa see @ref basic_json::basic_json(const value_t value_type) -- create a JSON
value with the default value for a given type

@since version 1.0.0
*/
enum class value_t : std::uint8_t
{
    null,             ///< null value
    object,           ///< object (unordered set of name/value pairs)
    array,            ///< array (ordered collection of values)
    string,           ///< string value
    boolean,          ///< boolean value
    number_integer,   ///< number value (signed integer)
    number_unsigned,  ///< number value (unsigned integer)
    number_float,     ///< number value (floating-point)
    binary,           ///< binary array (ordered collection of bytes)
    discarded         ///< discarded by the parser callback function
};

/*!
@brief comparison operator for JSON types

Returns an ordering that is similar to Python:
- order: null < boolean < number < object < array < string < binary
- furthermore, each type is not smaller than itself
- discarded values are not comparable
- binary is represented as a b"" string in python and directly comparable to a
  string; however, making a binary array directly comparable with a string would
  be surprising behavior in a JSON file.

@since version 1.0.0
*/
#if JSON_HAS_THREE_WAY_COMPARISON
    inline std::partial_ordering operator<=>(const value_t lhs, const value_t rhs) noexcept // *NOPAD*
#else
    inline bool operator<(const value_t lhs, const value_t rhs) noexcept
#endif
{
    static constexpr std::array<std::uint8_t, 9> order = {{
            0 /* null */, 3 /* object */, 4 /* array */, 5 /* string */,
            1 /* boolean */, 2 /* integer */, 2 /* unsigned */, 2 /* float */,
            6 /* binary */
        }
    };

    const auto l_index = static_cast<std::size_t>(lhs);
    const auto r_index = static_cast<std::size_t>(rhs);
#if JSON_HAS_THREE_WAY_COMPARISON
    if (l_index < order.size() && r_index < order.size())
    {
        return order[l_index] <=> order[r_index]; // *NOPAD*
    }
    return std::partial_ordering::unordered;
#else
    return l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];
#endif
}

// GCC selects the built-in operator< over an operator rewritten from
// a user-defined spaceship operator
// Clang, MSVC, and ICC select the rewritten candidate
// (see GCC bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105200)
#if JSON_HAS_THREE_WAY_COMPARISON && defined(__GNUC__)
inline bool operator<(const value_t lhs, const value_t rhs) noexcept
{
    return std::is_lt(lhs <=> rhs); // *NOPAD*
}
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_escape.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief replace all occurrences of a substring by another string

@param[in,out] s  the string to manipulate; changed so that all
               occurrences of @a f are replaced with @a t
@param[in]     f  the substring to replace with @a t
@param[in]     t  the string to replace @a f

@pre The search string @a f must not be empty. **This precondition is
enforced with an assertion.**

@since version 2.0.0
*/
template<typename StringType>
inline void replace_substring(StringType& s, const StringType& f,
                              const StringType& t)
{
    JSON_ASSERT(!f.empty());
    for (auto pos = s.find(f);                // find the first occurrence of f
            pos != StringType::npos;          // make sure f was found
            s.replace(pos, f.size(), t),      // replace with t, and
            pos = s.find(f, pos + t.size()))  // find the next occurrence of f
    {}
}

/*!
 * @brief string escaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to escape
 * @return    escaped string
 *
 * Note the order of escaping "~" to "~0" and "/" to "~1" is important.
 */
template<typename StringType>
inline StringType escape(StringType s)
{
    replace_substring(s, StringType{"~"}, StringType{"~0"});
    replace_substring(s, StringType{"/"}, StringType{"~1"});
    return s;
}

/*!
 * @brief string unescaping as described in RFC 6901 (Sect. 4)
 * @param[in] s string to unescape
 * @return    unescaped string
 *
 * Note the order of escaping "~1" to "/" and "~0" to "~" is important.
 */
template<typename StringType>
inline void unescape(StringType& s)
{
    replace_substring(s, StringType{"~1"}, StringType{"/"});
    replace_substring(s, StringType{"~0"}, StringType{"~"});
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/position_t.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// struct to capture the start position of the current token
struct position_t
{
    /// the total number of characters read
    std::size_t chars_read_total = 0;
    /// the number of characters read in the current line
    std::size_t chars_read_current_line = 0;
    /// the number of lines read
    std::size_t lines_read = 0;

    /// conversion to size_t to preserve SAX interface
    constexpr operator size_t() const
    {
        return chars_read_total;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-FileCopyrightText: 2018 The Abseil Authors
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <type_traits> // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type
#include <utility> // index_sequence, make_index_sequence, index_sequence_for

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using uncvref_t = typename std::remove_cv<typename std::remove_reference<T>::type>::type;

#ifdef JSON_HAS_CPP_14

// the following utilities are natively available in C++14
using std::enable_if_t;
using std::index_sequence;
using std::make_index_sequence;
using std::index_sequence_for;

#else

// alias templates to reduce boilerplate
template<bool B, typename T = void>
using enable_if_t = typename std::enable_if<B, T>::type;

// The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h
// which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.

//// START OF CODE FROM GOOGLE ABSEIL

// integer_sequence
//
// Class template representing a compile-time integer sequence. An instantiation
// of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its
// type through its template arguments (which is a common need when
// working with C++11 variadic templates). `absl::integer_sequence` is designed
// to be a drop-in replacement for C++14's `std::integer_sequence`.
//
// Example:
//
//   template< class T, T... Ints >
//   void user_function(integer_sequence<T, Ints...>);
//
//   int main()
//   {
//     // user_function's `T` will be deduced to `int` and `Ints...`
//     // will be deduced to `0, 1, 2, 3, 4`.
//     user_function(make_integer_sequence<int, 5>());
//   }
template <typename T, T... Ints>
struct integer_sequence
{
    using value_type = T;
    static constexpr std::size_t size() noexcept
    {
        return sizeof...(Ints);
    }
};

// index_sequence
//
// A helper template for an `integer_sequence` of `size_t`,
// `absl::index_sequence` is designed to be a drop-in replacement for C++14's
// `std::index_sequence`.
template <size_t... Ints>
using index_sequence = integer_sequence<size_t, Ints...>;

namespace utility_internal
{

template <typename Seq, size_t SeqSize, size_t Rem>
struct Extend;

// Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.
template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 0>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;
};

template <typename T, T... Ints, size_t SeqSize>
struct Extend<integer_sequence<T, Ints...>, SeqSize, 1>
{
    using type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;
};

// Recursion helper for 'make_integer_sequence<T, N>'.
// 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.
template <typename T, size_t N>
struct Gen
{
    using type =
        typename Extend < typename Gen < T, N / 2 >::type, N / 2, N % 2 >::type;
};

template <typename T>
struct Gen<T, 0>
{
    using type = integer_sequence<T>;
};

}  // namespace utility_internal

// Compile-time sequences of integers

// make_integer_sequence
//
// This template alias is equivalent to
// `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in
// replacement for C++14's `std::make_integer_sequence`.
template <typename T, T N>
using make_integer_sequence = typename utility_internal::Gen<T, N>::type;

// make_index_sequence
//
// This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,
// and is designed to be a drop-in replacement for C++14's
// `std::make_index_sequence`.
template <size_t N>
using make_index_sequence = make_integer_sequence<size_t, N>;

// index_sequence_for
//
// Converts a typename pack into an index sequence of the same length, and
// is designed to be a drop-in replacement for C++14's
// `std::index_sequence_for()`
template <typename... Ts>
using index_sequence_for = make_index_sequence<sizeof...(Ts)>;

//// END OF CODE FROM GOOGLE ABSEIL

#endif

// dispatch utility (taken from ranges-v3)
template<unsigned N> struct priority_tag : priority_tag < N - 1 > {};
template<> struct priority_tag<0> {};

// taken from ranges-v3
template<typename T>
struct static_const
{
    static JSON_INLINE_VARIABLE constexpr T value{};
};

#ifndef JSON_HAS_CPP_17
    template<typename T>
    constexpr T static_const<T>::value;
#endif

template<typename T, typename... Args>
constexpr std::array<T, sizeof...(Args)> make_array(Args&& ... args)
{
    return std::array<T, sizeof...(Args)> {{static_cast<T>(std::forward<Args>(args))...}};
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/type_traits.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <limits> // numeric_limits
#include <string> // char_traits
#include <tuple> // tuple
#include <type_traits> // false_type, is_constructible, is_integral, is_same, true_type
#include <utility> // declval
#if defined(__cpp_lib_byte) && __cpp_lib_byte >= 201603L
    #include <cstddef> // byte
#endif
// #include <nlohmann/detail/iterators/iterator_traits.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <iterator> // random_access_iterator_tag

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/void_t.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename It, typename = void>
struct iterator_types {};

template<typename It>
struct iterator_types <
    It,
    void_t<typename It::difference_type, typename It::value_type, typename It::pointer,
    typename It::reference, typename It::iterator_category >>
{
    using difference_type = typename It::difference_type;
    using value_type = typename It::value_type;
    using pointer = typename It::pointer;
    using reference = typename It::reference;
    using iterator_category = typename It::iterator_category;
};

// This is required as some compilers implement std::iterator_traits in a way that
// doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.
template<typename T, typename = void>
struct iterator_traits
{
};

template<typename T>
struct iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>
    : iterator_types<T>
{
};

template<typename T>
struct iterator_traits<T*, enable_if_t<std::is_object<T>::value>>
{
    using iterator_category = std::random_access_iterator_tag;
    using value_type = T;
    using difference_type = ptrdiff_t;
    using pointer = T*;
    using reference = T&;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/call_std/begin.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(begin);

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/call_std/end.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

NLOHMANN_CAN_CALL_STD_FUNC_IMPL(end);

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/json_fwd.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT

#ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_
    #define INCLUDE_NLOHMANN_JSON_FWD_HPP_

    #include <cstdint> // int64_t, uint64_t
    #include <map> // map
    #include <memory> // allocator
    #include <string> // string
    #include <vector> // vector

    // #include <nlohmann/detail/abi_macros.hpp>


    /*!
    @brief namespace for Niels Lohmann
    @see https://github.com/nlohmann
    @since version 1.0.0
    */
    NLOHMANN_JSON_NAMESPACE_BEGIN

    /*!
    @brief default JSONSerializer template argument

    This serializer ignores the template arguments and uses ADL
    ([argument-dependent lookup](https://en.cppreference.com/w/cpp/language/adl))
    for serialization.
    */
    template<typename T = void, typename SFINAE = void>
    struct adl_serializer;

    /// a class to store JSON values
    /// @sa https://json.nlohmann.me/api/basic_json/
    template<template<typename U, typename V, typename... Args> class ObjectType =
    std::map,
    template<typename U, typename... Args> class ArrayType = std::vector,
    class StringType = std::string, class BooleanType = bool,
    class NumberIntegerType = std::int64_t,
    class NumberUnsignedType = std::uint64_t,
    class NumberFloatType = double,
    template<typename U> class AllocatorType = std::allocator,
    template<typename T, typename SFINAE = void> class JSONSerializer =
    adl_serializer,
    class BinaryType = std::vector<std::uint8_t>, // cppcheck-suppress syntaxError
    class CustomBaseClass = void>
    class basic_json;

    /// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
    /// @sa https://json.nlohmann.me/api/json_pointer/
    template<typename RefStringType>
    class json_pointer;

    /*!
    @brief default specialization
    @sa https://json.nlohmann.me/api/json/
    */
    using json = basic_json<>;

    /// @brief a minimal map-like container that preserves insertion order
    /// @sa https://json.nlohmann.me/api/ordered_map/
    template<class Key, class T, class IgnoredLess, class Allocator>
    struct ordered_map;

    /// @brief specialization that maintains the insertion order of object keys
    /// @sa https://json.nlohmann.me/api/ordered_json/
    using ordered_json = basic_json<nlohmann::ordered_map>;

    NLOHMANN_JSON_NAMESPACE_END

#endif  // INCLUDE_NLOHMANN_JSON_FWD_HPP_


NLOHMANN_JSON_NAMESPACE_BEGIN
/*!
@brief detail namespace with internal helper functions

This namespace collects functions that should not be exposed,
implementations of some @ref basic_json methods, and meta-programming helpers.

@since version 2.1.0
*/
namespace detail
{

/////////////
// helpers //
/////////////

// Note to maintainers:
//
// Every trait in this file expects a non-CV-qualified type.
// The only exceptions are in the 'aliases for detected' section
// (i.e., those of the form: decltype(T::member_function(std::declval<T>())))
//
// In this case, T has to be properly CV-qualified to constraint the function arguments
// (e.g., to_json(BasicJsonType&, const T&))

template<typename> struct is_basic_json : std::false_type {};

NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type {};

// used by exceptions create() member functions
// true_type for the pointer to possibly cv-qualified basic_json or std::nullptr_t
// false_type otherwise
template<typename BasicJsonContext>
struct is_basic_json_context :
    std::integral_constant < bool,
    is_basic_json<typename std::remove_cv<typename std::remove_pointer<BasicJsonContext>::type>::type>::value
    || std::is_same<BasicJsonContext, std::nullptr_t>::value >
{};

//////////////////////
// json_ref helpers //
//////////////////////

template<typename>
class json_ref;

template<typename>
struct is_json_ref : std::false_type {};

template<typename T>
struct is_json_ref<json_ref<T>> : std::true_type {};

//////////////////////////
// aliases for detected //
//////////////////////////

template<typename T>
using mapped_type_t = typename T::mapped_type;

template<typename T>
using key_type_t = typename T::key_type;

template<typename T>
using value_type_t = typename T::value_type;

template<typename T>
using difference_type_t = typename T::difference_type;

template<typename T>
using pointer_t = typename T::pointer;

template<typename T>
using reference_t = typename T::reference;

template<typename T>
using iterator_category_t = typename T::iterator_category;

template<typename T, typename... Args>
using to_json_function = decltype(T::to_json(std::declval<Args>()...));

template<typename T, typename... Args>
using from_json_function = decltype(T::from_json(std::declval<Args>()...));

template<typename T, typename U>
using get_template_function = decltype(std::declval<T>().template get<U>());

// trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists
template<typename BasicJsonType, typename T, typename = void>
struct has_from_json : std::false_type {};

// trait checking if j.get<T> is valid
// use this trait instead of std::is_constructible or std::is_convertible,
// both rely on, or make use of implicit conversions, and thus fail when T
// has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)
template <typename BasicJsonType, typename T>
struct is_getable
{
    static constexpr bool value = is_detected<get_template_function, const BasicJsonType&, T>::value;
};

template<typename BasicJsonType, typename T>
struct has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, from_json_function, serializer,
        const BasicJsonType&, T&>::value;
};

// This trait checks if JSONSerializer<T>::from_json(json const&) exists
// this overload is used for non-default-constructible user-defined-types
template<typename BasicJsonType, typename T, typename = void>
struct has_non_default_from_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<T, from_json_function, serializer,
        const BasicJsonType&>::value;
};

// This trait checks if BasicJsonType::json_serializer<T>::to_json exists
// Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.
template<typename BasicJsonType, typename T, typename = void>
struct has_to_json : std::false_type {};

template<typename BasicJsonType, typename T>
struct has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>
{
    using serializer = typename BasicJsonType::template json_serializer<T, void>;

    static constexpr bool value =
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,
        T>::value;
};

template<typename T>
using detect_key_compare = typename T::key_compare;

template<typename T>
struct has_key_compare : std::integral_constant<bool, is_detected<detect_key_compare, T>::value> {};

// obtains the actual object key comparator
template<typename BasicJsonType>
struct actual_object_comparator
{
    using object_t = typename BasicJsonType::object_t;
    using object_comparator_t = typename BasicJsonType::default_object_comparator_t;
    using type = typename std::conditional < has_key_compare<object_t>::value,
          typename object_t::key_compare, object_comparator_t>::type;
};

template<typename BasicJsonType>
using actual_object_comparator_t = typename actual_object_comparator<BasicJsonType>::type;

/////////////////
// char_traits //
/////////////////

// Primary template of char_traits calls std char_traits
template<typename T>
struct char_traits : std::char_traits<T>
{};

// Explicitly define char traits for unsigned char since it is not standard
template<>
struct char_traits<unsigned char> : std::char_traits<char>
{
    using char_type = unsigned char;
    using int_type = uint64_t;

    // Redefine to_int_type function
    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(c);
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return static_cast<char_type>(i);
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};

// Explicitly define char traits for signed char since it is not standard
template<>
struct char_traits<signed char> : std::char_traits<char>
{
    using char_type = signed char;
    using int_type = uint64_t;

    // Redefine to_int_type function
    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(c);
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return static_cast<char_type>(i);
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};

#if defined(__cpp_lib_byte) && __cpp_lib_byte >= 201603L
template<>
struct char_traits<std::byte> : std::char_traits<char>
{
    using char_type = std::byte;
    using int_type = uint64_t;

    static int_type to_int_type(char_type c) noexcept
    {
        return static_cast<int_type>(std::to_integer<unsigned char>(c));
    }

    static char_type to_char_type(int_type i) noexcept
    {
        return std::byte(static_cast<unsigned char>(i));
    }

    static constexpr int_type eof() noexcept
    {
        return static_cast<int_type>(std::char_traits<char>::eof());
    }
};
#endif

///////////////////
// is_ functions //
///////////////////

// https://en.cppreference.com/w/cpp/types/conjunction
template<class...> struct conjunction : std::true_type { };
template<class B> struct conjunction<B> : B { };
template<class B, class... Bn>
struct conjunction<B, Bn...>
: std::conditional<static_cast<bool>(B::value), conjunction<Bn...>, B>::type {};

// https://en.cppreference.com/w/cpp/types/negation
template<class B> struct negation : std::integral_constant < bool, !B::value > { };

// Reimplementation of is_constructible and is_default_constructible, due to them being broken for
// std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).
// This causes compile errors in e.g., Clang 3.5 or GCC 4.9.
template <typename T>
struct is_default_constructible : std::is_default_constructible<T> {};

template <typename T1, typename T2>
struct is_default_constructible<std::pair<T1, T2>>
    : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename T1, typename T2>
struct is_default_constructible<const std::pair<T1, T2>>
    : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> {};

template <typename... Ts>
struct is_default_constructible<std::tuple<Ts...>>
    : conjunction<is_default_constructible<Ts>...> {};

template <typename... Ts>
struct is_default_constructible<const std::tuple<Ts...>>
    : conjunction<is_default_constructible<Ts>...> {};

template <typename T, typename... Args>
struct is_constructible : std::is_constructible<T, Args...> {};

template <typename T1, typename T2>
struct is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> {};

template <typename T1, typename T2>
struct is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> {};

template <typename... Ts>
struct is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> {};

template <typename... Ts>
struct is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> {};

template<typename T, typename = void>
struct is_iterator_traits : std::false_type {};

template<typename T>
struct is_iterator_traits<iterator_traits<T>>
{
  private:
    using traits = iterator_traits<T>;

  public:
    static constexpr auto value =
        is_detected<value_type_t, traits>::value &&
        is_detected<difference_type_t, traits>::value &&
        is_detected<pointer_t, traits>::value &&
        is_detected<iterator_category_t, traits>::value &&
        is_detected<reference_t, traits>::value;
};

template<typename T>
struct is_range
{
  private:
    using t_ref = typename std::add_lvalue_reference<T>::type;

    using iterator = detected_t<result_of_begin, t_ref>;
    using sentinel = detected_t<result_of_end, t_ref>;

    // to be 100% correct, it should use https://en.cppreference.com/w/cpp/iterator/input_or_output_iterator
    // and https://en.cppreference.com/w/cpp/iterator/sentinel_for
    // but reimplementing these would be too much work, as a lot of other concepts are used underneath
    static constexpr auto is_iterator_begin =
        is_iterator_traits<iterator_traits<iterator>>::value;

  public:
    static constexpr bool value = !std::is_same<iterator, nonesuch>::value && !std::is_same<sentinel, nonesuch>::value && is_iterator_begin;
};

template<typename R>
using iterator_t = enable_if_t<is_range<R>::value, result_of_begin<decltype(std::declval<R&>())>>;

template<typename T>
using range_value_t = value_type_t<iterator_traits<iterator_t<T>>>;

// The following implementation of is_complete_type is taken from
// https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/
// and is written by Xiang Fan who agreed to use it in this library.

template<typename T, typename = void>
struct is_complete_type : std::false_type {};

template<typename T>
struct is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type {};

template<typename BasicJsonType, typename CompatibleObjectType,
         typename = void>
struct is_compatible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type_impl <
    BasicJsonType, CompatibleObjectType,
    enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&
    is_detected<key_type_t, CompatibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    // macOS's is_constructible does not play well with nonesuch...
    static constexpr bool value =
        is_constructible<typename object_t::key_type,
        typename CompatibleObjectType::key_type>::value &&
        is_constructible<typename object_t::mapped_type,
        typename CompatibleObjectType::mapped_type>::value;
};

template<typename BasicJsonType, typename CompatibleObjectType>
struct is_compatible_object_type
    : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> {};

template<typename BasicJsonType, typename ConstructibleObjectType,
         typename = void>
struct is_constructible_object_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type_impl <
    BasicJsonType, ConstructibleObjectType,
    enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&
    is_detected<key_type_t, ConstructibleObjectType>::value >>
{
    using object_t = typename BasicJsonType::object_t;

    static constexpr bool value =
        (is_default_constructible<ConstructibleObjectType>::value &&
         (std::is_move_assignable<ConstructibleObjectType>::value ||
          std::is_copy_assignable<ConstructibleObjectType>::value) &&
         (is_constructible<typename ConstructibleObjectType::key_type,
          typename object_t::key_type>::value &&
          std::is_same <
          typename object_t::mapped_type,
          typename ConstructibleObjectType::mapped_type >::value)) ||
        (has_from_json<BasicJsonType,
         typename ConstructibleObjectType::mapped_type>::value ||
         has_non_default_from_json <
         BasicJsonType,
         typename ConstructibleObjectType::mapped_type >::value);
};

template<typename BasicJsonType, typename ConstructibleObjectType>
struct is_constructible_object_type
    : is_constructible_object_type_impl<BasicJsonType,
      ConstructibleObjectType> {};

template<typename BasicJsonType, typename CompatibleStringType>
struct is_compatible_string_type
{
    static constexpr auto value =
        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;
};

template<typename BasicJsonType, typename ConstructibleStringType>
struct is_constructible_string_type
{
    // launder type through decltype() to fix compilation failure on ICPC
#ifdef __INTEL_COMPILER
    using laundered_type = decltype(std::declval<ConstructibleStringType>());
#else
    using laundered_type = ConstructibleStringType;
#endif

    static constexpr auto value =
        conjunction <
        is_constructible<laundered_type, typename BasicJsonType::string_t>,
        is_detected_exact<typename BasicJsonType::string_t::value_type,
        value_type_t, laundered_type >>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType, typename = void>
struct is_compatible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type_impl <
    BasicJsonType, CompatibleArrayType,
    enable_if_t <
    is_detected<iterator_t, CompatibleArrayType>::value&&
    is_iterator_traits<iterator_traits<detected_t<iterator_t, CompatibleArrayType>>>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
    !std::is_same<CompatibleArrayType, detected_t<range_value_t, CompatibleArrayType>>::value >>
{
    static constexpr bool value =
        is_constructible<BasicJsonType,
        range_value_t<CompatibleArrayType>>::value;
};

template<typename BasicJsonType, typename CompatibleArrayType>
struct is_compatible_array_type
    : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> {};

template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>
struct is_constructible_array_type_impl : std::false_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t<std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value >>
            : std::true_type {};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type_impl <
    BasicJsonType, ConstructibleArrayType,
    enable_if_t < !std::is_same<ConstructibleArrayType,
    typename BasicJsonType::value_type>::value&&
    !is_compatible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
    is_default_constructible<ConstructibleArrayType>::value&&
(std::is_move_assignable<ConstructibleArrayType>::value ||
 std::is_copy_assignable<ConstructibleArrayType>::value)&&
is_detected<iterator_t, ConstructibleArrayType>::value&&
is_iterator_traits<iterator_traits<detected_t<iterator_t, ConstructibleArrayType>>>::value&&
is_detected<range_value_t, ConstructibleArrayType>::value&&
// special case for types like std::filesystem::path whose iterator's value_type are themselves
// c.f. https://github.com/nlohmann/json/pull/3073
!std::is_same<ConstructibleArrayType, detected_t<range_value_t, ConstructibleArrayType>>::value&&
is_complete_type <
detected_t<range_value_t, ConstructibleArrayType >>::value >>
{
    using value_type = range_value_t<ConstructibleArrayType>;

    static constexpr bool value =
        std::is_same<value_type,
        typename BasicJsonType::array_t::value_type>::value ||
        has_from_json<BasicJsonType,
        value_type>::value ||
        has_non_default_from_json <
        BasicJsonType,
        value_type >::value;
};

template<typename BasicJsonType, typename ConstructibleArrayType>
struct is_constructible_array_type
    : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType,
         typename = void>
struct is_compatible_integer_type_impl : std::false_type {};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type_impl <
    RealIntegerType, CompatibleNumberIntegerType,
    enable_if_t < std::is_integral<RealIntegerType>::value&&
    std::is_integral<CompatibleNumberIntegerType>::value&&
    !std::is_same<bool, CompatibleNumberIntegerType>::value >>
{
    // is there an assert somewhere on overflows?
    using RealLimits = std::numeric_limits<RealIntegerType>;
    using CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;

    static constexpr auto value =
        is_constructible<RealIntegerType,
        CompatibleNumberIntegerType>::value &&
        CompatibleLimits::is_integer &&
        RealLimits::is_signed == CompatibleLimits::is_signed;
};

template<typename RealIntegerType, typename CompatibleNumberIntegerType>
struct is_compatible_integer_type
    : is_compatible_integer_type_impl<RealIntegerType,
      CompatibleNumberIntegerType> {};

template<typename BasicJsonType, typename CompatibleType, typename = void>
struct is_compatible_type_impl: std::false_type {};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type_impl <
    BasicJsonType, CompatibleType,
    enable_if_t<is_complete_type<CompatibleType>::value >>
{
    static constexpr bool value =
        has_to_json<BasicJsonType, CompatibleType>::value;
};

template<typename BasicJsonType, typename CompatibleType>
struct is_compatible_type
    : is_compatible_type_impl<BasicJsonType, CompatibleType> {};

template<typename BasicJsonType, typename CompatibleReferenceType>
struct is_compatible_reference_type_impl
{
    using JsonType = uncvref_t<BasicJsonType>;
    using CVType = typename std::remove_reference<CompatibleReferenceType>::type;
    using Type = typename std::remove_cv<CVType>::type;
    constexpr static bool value = std::is_reference<CompatibleReferenceType>::value &&
                                  (!std::is_const<typename std::remove_reference<BasicJsonType>::type>::value || std::is_const<CVType>::value) &&
                                  (std::is_same<typename JsonType::boolean_t, Type>::value ||
                                   std::is_same<typename JsonType::number_float_t, Type>::value ||
                                   std::is_same<typename JsonType::number_integer_t, Type>::value ||
                                   std::is_same<typename JsonType::number_unsigned_t, Type>::value ||
                                   std::is_same<typename JsonType::string_t, Type>::value ||
                                   std::is_same<typename JsonType::binary_t, Type>::value ||
                                   std::is_same<typename JsonType::object_t, Type>::value ||
                                   std::is_same<typename JsonType::array_t, Type>::value);
};

template<typename BasicJsonType, typename CompatibleReferenceType>
struct is_compatible_reference_type
    : is_compatible_reference_type_impl<BasicJsonType, CompatibleReferenceType> {};

template<typename T1, typename T2>
struct is_constructible_tuple : std::false_type {};

template<typename T1, typename... Args>
struct is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> {};

template<typename BasicJsonType, typename T>
struct is_json_iterator_of : std::false_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::iterator> : std::true_type {};

template<typename BasicJsonType>
struct is_json_iterator_of<BasicJsonType, typename BasicJsonType::const_iterator> : std::true_type
{};

// checks if a given type T is a template specialization of Primary
template<template <typename...> class Primary, typename T>
struct is_specialization_of : std::false_type {};

template<template <typename...> class Primary, typename... Args>
struct is_specialization_of<Primary, Primary<Args...>> : std::true_type {};

template<typename T>
using is_json_pointer = is_specialization_of<::nlohmann::json_pointer, uncvref_t<T>>;

// checks if B is a json_pointer<A>
template <typename A, typename B>
struct is_json_pointer_of : std::false_type {};

template <typename A>
struct is_json_pointer_of<A, ::nlohmann::json_pointer<A>> : std::true_type {};

template <typename A>
struct is_json_pointer_of<A, ::nlohmann::json_pointer<A>&> : std::true_type {};

// checks if A and B are comparable using Compare functor
template<typename Compare, typename A, typename B, typename = void>
struct is_comparable : std::false_type {};

// We exclude json_pointer here, because the checks using Compare(A, B) will
// use json_pointer::operator string_t() which triggers a deprecation warning
// for GCC. See https://github.com/nlohmann/json/issues/4621. The call to
// is_json_pointer_of can be removed once the deprecated function has been
// removed.
template<typename Compare, typename A, typename B>
struct is_comparable < Compare, A, B, enable_if_t < !is_json_pointer_of<A, B>::value
&& std::is_constructible <decltype(std::declval<Compare>()(std::declval<A>(), std::declval<B>()))>::value
&& std::is_constructible <decltype(std::declval<Compare>()(std::declval<B>(), std::declval<A>()))>::value
>> : std::true_type {};

template<typename T>
using detect_is_transparent = typename T::is_transparent;

// type trait to check if KeyType can be used as an object key (without a BasicJsonType)
// see is_usable_as_basic_json_key_type below
template<typename Comparator, typename ObjectKeyType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_key_type = typename std::conditional <
                              is_comparable<Comparator, ObjectKeyType, KeyTypeCVRef>::value
                              && !(ExcludeObjectKeyType && std::is_same<KeyType,
                                   ObjectKeyType>::value)
                              && (!RequireTransparentComparator
                                  || is_detected <detect_is_transparent, Comparator>::value)
                              && !is_json_pointer<KeyType>::value,
                              std::true_type,
                              std::false_type >::type;

// type trait to check if KeyType can be used as an object key
// true if:
//   - KeyType is comparable with BasicJsonType::object_t::key_type
//   - if ExcludeObjectKeyType is true, KeyType is not BasicJsonType::object_t::key_type
//   - the comparator is transparent or RequireTransparentComparator is false
//   - KeyType is not a JSON iterator or json_pointer
template<typename BasicJsonType, typename KeyTypeCVRef, bool RequireTransparentComparator = true,
         bool ExcludeObjectKeyType = RequireTransparentComparator, typename KeyType = uncvref_t<KeyTypeCVRef>>
using is_usable_as_basic_json_key_type = typename std::conditional <
    (is_usable_as_key_type<typename BasicJsonType::object_comparator_t,
     typename BasicJsonType::object_t::key_type, KeyTypeCVRef,
     RequireTransparentComparator, ExcludeObjectKeyType>::value
     && !is_json_iterator_of<BasicJsonType, KeyType>::value)
#ifdef JSON_HAS_CPP_17
    || std::is_convertible<KeyType, std::string_view>::value
#endif
    , std::true_type,
    std::false_type >::type;

template<typename ObjectType, typename KeyType>
using detect_erase_with_key_type = decltype(std::declval<ObjectType&>().erase(std::declval<KeyType>()));

// type trait to check if object_t has an erase() member functions accepting KeyType
template<typename BasicJsonType, typename KeyType>
using has_erase_with_key_type = typename std::conditional <
                                is_detected <
                                detect_erase_with_key_type,
                                typename BasicJsonType::object_t, KeyType >::value,
                                std::true_type,
                                std::false_type >::type;

// a naive helper to check if a type is an ordered_map (exploits the fact that
// ordered_map inherits capacity() from std::vector)
template <typename T>
struct is_ordered_map
{
    using one = char;

    struct two
    {
        char x[2]; // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    };

    template <typename C> static one test( decltype(&C::capacity) ) ;
    template <typename C> static two test(...);

    enum { value = sizeof(test<T>(nullptr)) == sizeof(char) }; // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg,cppcoreguidelines-use-enum-class)
};

// to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)
template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, int > = 0 >
T conditional_static_cast(U value)
{
    return static_cast<T>(value);
}

template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, int> = 0>
T conditional_static_cast(U value)
{
    return value;
}

template<typename... Types>
using all_integral = conjunction<std::is_integral<Types>...>;

template<typename... Types>
using all_signed = conjunction<std::is_signed<Types>...>;

template<typename... Types>
using all_unsigned = conjunction<std::is_unsigned<Types>...>;

// there's a disjunction trait in another PR; replace when merged
template<typename... Types>
using same_sign = std::integral_constant < bool,
      all_signed<Types...>::value || all_unsigned<Types...>::value >;

template<typename OfType, typename T>
using never_out_of_range = std::integral_constant < bool,
      (std::is_signed<OfType>::value && (sizeof(T) < sizeof(OfType)))
      || (same_sign<OfType, T>::value && sizeof(OfType) == sizeof(T)) >;

template<typename OfType, typename T,
         bool OfTypeSigned = std::is_signed<OfType>::value,
         bool TSigned = std::is_signed<T>::value>
struct value_in_range_of_impl2;

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, false>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, false, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return val >= 0 && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl2<OfType, T, true, true>
{
    static constexpr bool test(T val)
    {
        using CommonType = typename std::common_type<OfType, T>::type;
        return static_cast<CommonType>(val) >= static_cast<CommonType>((std::numeric_limits<OfType>::min)())
               && static_cast<CommonType>(val) <= static_cast<CommonType>((std::numeric_limits<OfType>::max)());
    }
};

template<typename OfType, typename T,
         bool NeverOutOfRange = never_out_of_range<OfType, T>::value,
         typename = detail::enable_if_t<all_integral<OfType, T>::value>>
struct value_in_range_of_impl1;

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, false>
{
    static constexpr bool test(T val)
    {
        return value_in_range_of_impl2<OfType, T>::test(val);
    }
};

template<typename OfType, typename T>
struct value_in_range_of_impl1<OfType, T, true>
{
    static constexpr bool test(T /*val*/)
    {
        return true;
    }
};

template<typename OfType, typename T>
constexpr bool value_in_range_of(T val)
{
    return value_in_range_of_impl1<OfType, T>::test(val);
}

template<bool Value>
using bool_constant = std::integral_constant<bool, Value>;

///////////////////////////////////////////////////////////////////////////////
// is_c_string
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
constexpr bool is_c_string()
{
    using TUnExt = typename std::remove_extent<T>::type;
    using TUnCVExt = typename std::remove_cv<TUnExt>::type;
    using TUnPtr = typename std::remove_pointer<T>::type;
    using TUnCVPtr = typename std::remove_cv<TUnPtr>::type;
    return
        (std::is_array<T>::value && std::is_same<TUnCVExt, char>::value)
        || (std::is_pointer<T>::value && std::is_same<TUnCVPtr, char>::value);
}

}  // namespace impl

// checks whether T is a [cv] char */[cv] char[] C string
template<typename T>
struct is_c_string : bool_constant<impl::is_c_string<T>()> {};

template<typename T>
using is_c_string_uncvref = is_c_string<uncvref_t<T>>;

///////////////////////////////////////////////////////////////////////////////
// is_transparent
///////////////////////////////////////////////////////////////////////////////

namespace impl
{

template<typename T>
constexpr bool is_transparent()
{
    return is_detected<detect_is_transparent, T>::value;
}

}  // namespace impl

// checks whether T has a member named is_transparent
template<typename T>
struct is_transparent : bool_constant<impl::is_transparent<T>()> {};

///////////////////////////////////////////////////////////////////////////////

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_concat.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstring> // strlen
#include <string> // string
#include <utility> // forward

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/detected.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

inline std::size_t concat_length()
{
    return 0;
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest);

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest);

template<typename... Args>
inline std::size_t concat_length(const char /*c*/, const Args& ... rest)
{
    return 1 + concat_length(rest...);
}

template<typename... Args>
inline std::size_t concat_length(const char* cstr, const Args& ... rest)
{
    // cppcheck-suppress ignoredReturnValue
    return ::strlen(cstr) + concat_length(rest...);
}

template<typename StringType, typename... Args>
inline std::size_t concat_length(const StringType& str, const Args& ... rest)
{
    return str.size() + concat_length(rest...);
}

template<typename OutStringType>
inline void concat_into(OutStringType& /*out*/)
{}

template<typename StringType, typename Arg>
using string_can_append = decltype(std::declval<StringType&>().append(std::declval < Arg && > ()));

template<typename StringType, typename Arg>
using detect_string_can_append = is_detected<string_can_append, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_op = decltype(std::declval<StringType&>() += std::declval < Arg && > ());

template<typename StringType, typename Arg>
using detect_string_can_append_op = is_detected<string_can_append_op, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_iter = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().begin(), std::declval<const Arg&>().end()));

template<typename StringType, typename Arg>
using detect_string_can_append_iter = is_detected<string_can_append_iter, StringType, Arg>;

template<typename StringType, typename Arg>
using string_can_append_data = decltype(std::declval<StringType&>().append(std::declval<const Arg&>().data(), std::declval<const Arg&>().size()));

template<typename StringType, typename Arg>
using detect_string_can_append_data = is_detected<string_can_append_data, StringType, Arg>;

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > = 0 >
inline void concat_into(OutStringType& out, const Arg& arg, Args && ... rest);

template<typename OutStringType, typename Arg, typename... Args,
         enable_if_t<detect_string_can_append<OutStringType, Arg>::value, int> = 0>
inline void concat_into(OutStringType& out, Arg && arg, Args && ... rest)
{
    out.append(std::forward<Arg>(arg));
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && detect_string_can_append_op<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, Arg&& arg, Args&& ... rest)
{
    out += std::forward<Arg>(arg);
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && detect_string_can_append_iter<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.begin(), arg.end());
    concat_into(out, std::forward<Args>(rest)...);
}

template < typename OutStringType, typename Arg, typename... Args,
           enable_if_t < !detect_string_can_append<OutStringType, Arg>::value
                         && !detect_string_can_append_op<OutStringType, Arg>::value
                         && !detect_string_can_append_iter<OutStringType, Arg>::value
                         && detect_string_can_append_data<OutStringType, Arg>::value, int > >
inline void concat_into(OutStringType& out, const Arg& arg, Args&& ... rest)
{
    out.append(arg.data(), arg.size());
    concat_into(out, std::forward<Args>(rest)...);
}

template<typename OutStringType = std::string, typename... Args>
inline OutStringType concat(Args && ... args)
{
    OutStringType str;
    str.reserve(concat_length(args...));
    concat_into(str, std::forward<Args>(args)...);
    return str;
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


// With -Wweak-vtables, Clang will complain about the exception classes as they
// have no out-of-line virtual method definitions and their vtable will be
// emitted in every translation unit. This issue cannot be fixed with a
// header-only library as there is no implementation file to move these
// functions to. As a result, we suppress this warning here to avoid client
// code stumbling over this. See https://github.com/nlohmann/json/issues/4087
// for a discussion.
#if defined(__clang__)
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wweak-vtables"
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

////////////////
// exceptions //
////////////////

/// @brief general exception of the @ref basic_json class
/// @sa https://json.nlohmann.me/api/basic_json/exception/
class exception : public std::exception
{
  public:
    /// returns the explanatory string
    const char* what() const noexcept override
    {
        return m.what();
    }

    /// the id of the exception
    const int id; // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)

  protected:
    JSON_HEDLEY_NON_NULL(3)
    exception(int id_, const char* what_arg) : id(id_), m(what_arg) {} // NOLINT(bugprone-throw-keyword-missing)

    static std::string name(const std::string& ename, int id_)
    {
        return concat("[json.exception.", ename, '.', std::to_string(id_), "] ");
    }

    static std::string diagnostics(std::nullptr_t /*leaf_element*/)
    {
        return "";
    }

    template<typename BasicJsonType>
    static std::string diagnostics(const BasicJsonType* leaf_element)
    {
#if JSON_DIAGNOSTICS
        std::vector<std::string> tokens;
        for (const auto* current = leaf_element; current != nullptr && current->m_parent != nullptr; current = current->m_parent)
        {
            switch (current->m_parent->type())
            {
                case value_t::array:
                {
                    for (std::size_t i = 0; i < current->m_parent->m_data.m_value.array->size(); ++i)
                    {
                        if (&current->m_parent->m_data.m_value.array->operator[](i) == current)
                        {
                            tokens.emplace_back(std::to_string(i));
                            break;
                        }
                    }
                    break;
                }

                case value_t::object:
                {
                    for (const auto& element : *current->m_parent->m_data.m_value.object)
                    {
                        if (&element.second == current)
                        {
                            tokens.emplace_back(element.first.c_str());
                            break;
                        }
                    }
                    break;
                }

                case value_t::null: // LCOV_EXCL_LINE
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:   // LCOV_EXCL_LINE
                    break; // LCOV_EXCL_LINE
            }
        }

        if (tokens.empty())
        {
            return "";
        }

        auto str = std::accumulate(tokens.rbegin(), tokens.rend(), std::string{},
                                   [](const std::string & a, const std::string & b)
        {
            return concat(a, '/', detail::escape(b));
        });

        return concat('(', str, ") ", get_byte_positions(leaf_element));
#else
        return get_byte_positions(leaf_element);
#endif
    }

  private:
    /// an exception object as storage for error messages
    std::runtime_error m;
#if JSON_DIAGNOSTIC_POSITIONS
    template<typename BasicJsonType>
    static std::string get_byte_positions(const BasicJsonType* leaf_element)
    {
        if ((leaf_element->start_pos() != std::string::npos) && (leaf_element->end_pos() != std::string::npos))
        {
            return concat("(bytes ", std::to_string(leaf_element->start_pos()), "-", std::to_string(leaf_element->end_pos()), ") ");
        }
        return "";
    }
#else
    template<typename BasicJsonType>
    static std::string get_byte_positions(const BasicJsonType* leaf_element)
    {
        static_cast<void>(leaf_element);
        return "";
    }
#endif
};

/// @brief exception indicating a parse error
/// @sa https://json.nlohmann.me/api/basic_json/parse_error/
class parse_error : public exception
{
  public:
    /*!
    @brief create a parse error exception
    @param[in] id_       the id of the exception
    @param[in] pos       the position where the error occurred (or with
                         chars_read_total=0 if the position cannot be
                         determined)
    @param[in] what_arg  the explanatory string
    @return parse_error object
    */
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, const position_t& pos, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     position_string(pos), ": ", exception::diagnostics(context), what_arg);
        return {id_, pos.chars_read_total, w.c_str()};
    }

    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static parse_error create(int id_, std::size_t byte_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("parse_error", id_), "parse error",
                                     (byte_ != 0 ? (concat(" at byte ", std::to_string(byte_))) : ""),
                                     ": ", exception::diagnostics(context), what_arg);
        return {id_, byte_, w.c_str()};
    }

    /*!
    @brief byte index of the parse error

    The byte index of the last read character in the input file.

    @note For an input with n bytes, 1 is the index of the first character and
          n+1 is the index of the terminating null byte or the end of file.
          This also holds true when reading a byte vector (CBOR or MessagePack).
    */
    const std::size_t byte;

  private:
    parse_error(int id_, std::size_t byte_, const char* what_arg)
        : exception(id_, what_arg), byte(byte_) {}

    static std::string position_string(const position_t& pos)
    {
        return concat(" at line ", std::to_string(pos.lines_read + 1),
                      ", column ", std::to_string(pos.chars_read_current_line));
    }
};

/// @brief exception indicating errors with iterators
/// @sa https://json.nlohmann.me/api/basic_json/invalid_iterator/
class invalid_iterator : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static invalid_iterator create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("invalid_iterator", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    invalid_iterator(int id_, const char* what_arg)
        : exception(id_, what_arg) {}
};

/// @brief exception indicating executing a member function with a wrong type
/// @sa https://json.nlohmann.me/api/basic_json/type_error/
class type_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static type_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("type_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    type_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating access out of the defined range
/// @sa https://json.nlohmann.me/api/basic_json/out_of_range/
class out_of_range : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static out_of_range create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("out_of_range", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    out_of_range(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

/// @brief exception indicating other library errors
/// @sa https://json.nlohmann.me/api/basic_json/other_error/
class other_error : public exception
{
  public:
    template<typename BasicJsonContext, enable_if_t<is_basic_json_context<BasicJsonContext>::value, int> = 0>
    static other_error create(int id_, const std::string& what_arg, BasicJsonContext context)
    {
        const std::string w = concat(exception::name("other_error", id_), exception::diagnostics(context), what_arg);
        return {id_, w.c_str()};
    }

  private:
    JSON_HEDLEY_NON_NULL(3)
    other_error(int id_, const char* what_arg) : exception(id_, what_arg) {}
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/identity_tag.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// dispatching helper struct
template <class T> struct identity_tag {};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/std_fs.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>


#if JSON_HAS_EXPERIMENTAL_FILESYSTEM
#include <experimental/filesystem>
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::experimental::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#elif JSON_HAS_FILESYSTEM
#include <filesystem> // NOLINT(build/c++17)
NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
namespace std_fs = std::filesystem;
}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END
#endif

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/meta/logic.hpp>


// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
#ifdef JSON_HAS_CPP_17

template<bool... Booleans>
struct cxpr_or_impl : std::integral_constant < bool, (Booleans || ...) > {};

template<bool... Booleans>
struct cxpr_and_impl : std::integral_constant < bool, (Booleans &&...) > {};

#else

template<bool... Booleans>
struct cxpr_or_impl : std::false_type {};

template<bool... Booleans>
struct cxpr_or_impl<true, Booleans...> : std::true_type {};

template<bool... Booleans>
struct cxpr_or_impl<false, Booleans...> : cxpr_or_impl<Booleans...> {};

template<bool... Booleans>
struct cxpr_and_impl : std::true_type {};

template<bool... Booleans>
struct cxpr_and_impl<true, Booleans...> : cxpr_and_impl<Booleans...> {};

template<bool... Booleans>
struct cxpr_and_impl<false, Booleans...> : std::false_type {};

#endif

template<class Boolean>
struct cxpr_not : std::integral_constant < bool, !Boolean::value > {};

template<class... Booleans>
struct cxpr_or : cxpr_or_impl<Booleans::value...> {};

template<bool... Booleans>
struct cxpr_or_c : cxpr_or_impl<Booleans...> {};

template<class... Booleans>
struct cxpr_and : cxpr_and_impl<Booleans::value...> {};

template<bool... Booleans>
struct cxpr_and_c : cxpr_and_impl<Booleans...> {};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


// include after macro_scope.hpp
#ifdef JSON_HAS_CPP_17
    #include <optional> // optional
#endif

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #include <string_view> // u8string_view
#endif

NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename std::nullptr_t& n)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_null()))
    {
        JSON_THROW(type_error::create(302, concat("type must be null, but is ", j.type_name()), &j));
    }
    n = nullptr;
}

#ifdef JSON_HAS_CPP_17
template < typename BasicJsonType, typename T,
           typename std::enable_if < !nlohmann::detail::is_basic_json<T>::value, int >::type = 0 >
void from_json(const BasicJsonType& j, std::optional<T>& opt)
{
    if (j.is_null())
    {
        opt = std::nullopt;
    }
    else
    {
        opt.emplace(j.template get<T>());
    }
}
#endif // JSON_HAS_CPP_17

// overloads for basic_json template parameters
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t < std::is_arithmetic<ArithmeticType>::value&&
                         !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
                         int > = 0 >
void get_arithmetic_value(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::boolean:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::boolean_t& b)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))
    {
        JSON_THROW(type_error::create(302, concat("type must be boolean, but is ", j.type_name()), &j));
    }
    b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::string_t& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template <
    typename BasicJsonType, typename StringType,
    enable_if_t <
        std::is_assignable<StringType&, const typename BasicJsonType::string_t>::value
        && is_detected_exact<typename BasicJsonType::string_t::value_type, value_type_t, StringType>::value
        && !std::is_same<typename BasicJsonType::string_t, StringType>::value
        && !is_json_ref<StringType>::value, int > = 0 >
inline void from_json(const BasicJsonType& j, StringType& s)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }

    s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_float_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_unsigned_t& val)
{
    get_arithmetic_value(j, val);
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::number_integer_t& val)
{
    get_arithmetic_value(j, val);
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, EnumType& e)
{
    typename std::underlying_type<EnumType>::type val;
    get_arithmetic_value(j, val);
    e = static_cast<EnumType>(val);
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

// forward_list doesn't have an insert method
template<typename BasicJsonType, typename T, typename Allocator,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::forward_list<T, Allocator>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.clear();
    std::transform(j.rbegin(), j.rend(),
                   std::front_inserter(l), [](const BasicJsonType & i)
    {
        return i.template get<T>();
    });
}

// valarray doesn't have an insert method
template<typename BasicJsonType, typename T,
         enable_if_t<is_getable<BasicJsonType, T>::value, int> = 0>
inline void from_json(const BasicJsonType& j, std::valarray<T>& l)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    l.resize(j.size());
    std::transform(j.begin(), j.end(), std::begin(l),
                   [](const BasicJsonType & elem)
    {
        return elem.template get<T>();
    });
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json(const BasicJsonType& j, T (&arr)[N])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            arr[i1][i2] = j.at(i1).at(i2).template get<T>();
        }
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2, std::size_t N3>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2][N3])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            for (std::size_t i3 = 0; i3 < N3; ++i3)
            {
                arr[i1][i2][i3] = j.at(i1).at(i2).at(i3).template get<T>();
            }
        }
    }
}

template<typename BasicJsonType, typename T, std::size_t N1, std::size_t N2, std::size_t N3, std::size_t N4>
auto from_json(const BasicJsonType& j, T (&arr)[N1][N2][N3][N4])  // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i1 = 0; i1 < N1; ++i1)
    {
        for (std::size_t i2 = 0; i2 < N2; ++i2)
        {
            for (std::size_t i3 = 0; i3 < N3; ++i3)
            {
                for (std::size_t i4 = 0; i4 < N4; ++i4)
                {
                    arr[i1][i2][i3][i4] = j.at(i1).at(i2).at(i3).at(i4).template get<T>();
                }
            }
        }
    }
}

template<typename BasicJsonType>
inline void from_json_array_impl(const BasicJsonType& j, typename BasicJsonType::array_t& arr, priority_tag<3> /*unused*/)
{
    arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();
}

template<typename BasicJsonType, typename T, std::size_t N>
auto from_json_array_impl(const BasicJsonType& j, std::array<T, N>& arr,
                          priority_tag<2> /*unused*/)
-> decltype(j.template get<T>(), void())
{
    for (std::size_t i = 0; i < N; ++i)
    {
        arr[i] = j.at(i).template get<T>();
    }
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
auto from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> /*unused*/)
-> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template get<typename ConstructibleArrayType::value_type>(),
    void())
{
    using std::end;

    ConstructibleArrayType ret;
    ret.reserve(j.size());
    std::transform(j.begin(), j.end(),
                   std::inserter(ret, end(ret)), [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template<typename BasicJsonType, typename ConstructibleArrayType,
         enable_if_t<
             std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,
             int> = 0>
inline void from_json_array_impl(const BasicJsonType& j, ConstructibleArrayType& arr,
                                 priority_tag<0> /*unused*/)
{
    using std::end;

    ConstructibleArrayType ret;
    std::transform(
        j.begin(), j.end(), std::inserter(ret, end(ret)),
        [](const BasicJsonType & i)
    {
        // get<BasicJsonType>() returns *this, this won't call a from_json
        // method when value_type is BasicJsonType
        return i.template get<typename ConstructibleArrayType::value_type>();
    });
    arr = std::move(ret);
}

template < typename BasicJsonType, typename ConstructibleArrayType,
           enable_if_t <
               is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&
               !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&
               !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&
               !is_basic_json<ConstructibleArrayType>::value,
               int > = 0 >
auto from_json(const BasicJsonType& j, ConstructibleArrayType& arr)
-> decltype(from_json_array_impl(j, arr, priority_tag<3> {}),
j.template get<typename ConstructibleArrayType::value_type>(),
void())
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    from_json_array_impl(j, arr, priority_tag<3> {});
}

template < typename BasicJsonType, typename T, std::size_t... Idx >
std::array<T, sizeof...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,
                     identity_tag<std::array<T, sizeof...(Idx)>> /*unused*/, index_sequence<Idx...> /*unused*/)
{
    return { { std::forward<BasicJsonType>(j).at(Idx).template get<T>()... } };
}

template < typename BasicJsonType, typename T, std::size_t N >
auto from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)
-> decltype(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> {});
}

template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, typename BasicJsonType::binary_t& bin)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_binary()))
    {
        JSON_THROW(type_error::create(302, concat("type must be binary, but is ", j.type_name()), &j));
    }

    bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();
}

template<typename BasicJsonType, typename ConstructibleObjectType,
         enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, int> = 0>
inline void from_json(const BasicJsonType& j, ConstructibleObjectType& obj)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_object()))
    {
        JSON_THROW(type_error::create(302, concat("type must be object, but is ", j.type_name()), &j));
    }

    ConstructibleObjectType ret;
    const auto* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();
    using value_type = typename ConstructibleObjectType::value_type;
    std::transform(
        inner_object->begin(), inner_object->end(),
        std::inserter(ret, ret.begin()),
        [](typename BasicJsonType::object_t::value_type const & p)
    {
        return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());
    });
    obj = std::move(ret);
}

// overload for arithmetic types, not chosen for basic_json template arguments
// (BooleanType, etc.); note: Is it really necessary to provide explicit
// overloads for boolean_t etc. in case of a custom BooleanType which is not
// an arithmetic type?
template < typename BasicJsonType, typename ArithmeticType,
           enable_if_t <
               std::is_arithmetic<ArithmeticType>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&
               !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,
               int > = 0 >
inline void from_json(const BasicJsonType& j, ArithmeticType& val)
{
    switch (static_cast<value_t>(j))
    {
        case value_t::number_unsigned:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());
            break;
        }
        case value_t::number_integer:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());
            break;
        }
        case value_t::number_float:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());
            break;
        }
        case value_t::boolean:
        {
            val = static_cast<ArithmeticType>(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());
            break;
        }

        case value_t::null:
        case value_t::object:
        case value_t::array:
        case value_t::string:
        case value_t::binary:
        case value_t::discarded:
        default:
            JSON_THROW(type_error::create(302, concat("type must be number, but is ", j.type_name()), &j));
    }
}

template<typename BasicJsonType, typename Type>
detail::uncvref_t<Type> from_json_tuple_get_impl(BasicJsonType&& j, detail::identity_tag<Type> /*unused*/, detail::priority_tag<0> /*unused*/)
{
    return std::forward<BasicJsonType>(j).template get<detail::uncvref_t<Type>>();
}

template<typename BasicJsonType, typename Type,
         detail::enable_if_t<detail::is_compatible_reference_type<BasicJsonType, Type>::value, int> = 0>
Type from_json_tuple_get_impl(BasicJsonType && j, detail::identity_tag<Type> /*unused*/, detail::priority_tag<1> /*unused*/)
{
    return std::forward<BasicJsonType>(j).template get_ref<Type>();
}

template<typename BasicJsonType, typename Type,
         detail::enable_if_t<std::is_arithmetic<uncvref_t<Type>>::value, int> = 0>
detail::uncvref_t<Type> from_json_tuple_get_impl(BasicJsonType && j, detail::identity_tag<Type> /*unused*/, detail::priority_tag<2> /*unused*/)
{
    return std::forward<BasicJsonType>(j).template get<detail::uncvref_t<Type>>();
}

template<std::size_t PTagValue, typename BasicJsonType, typename... Types>
using tuple_type = std::tuple < decltype(from_json_tuple_get_impl(std::declval<BasicJsonType>(), detail::identity_tag<Types> {}, detail::priority_tag<PTagValue> {}))... >;

template<std::size_t PTagValue, typename... Args, typename BasicJsonType, std::size_t... Idx>
tuple_type<PTagValue, BasicJsonType, Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> /*unused*/)
{
    return tuple_type<PTagValue, BasicJsonType, Args...>(from_json_tuple_get_impl(std::forward<BasicJsonType>(j).at(Idx), detail::identity_tag<Args> {}, detail::priority_tag<PTagValue> {})...);
}

template<std::size_t PTagValue, typename BasicJsonType>
std::tuple<> from_json_tuple_impl_base(BasicJsonType& /*unused*/, index_sequence<> /*unused*/)
{
    return {};
}

template < typename BasicJsonType, class A1, class A2 >
std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> /*unused*/, priority_tag<0> /*unused*/)
{
    return {std::forward<BasicJsonType>(j).at(0).template get<A1>(),
            std::forward<BasicJsonType>(j).at(1).template get<A2>()};
}

template<typename BasicJsonType, typename A1, typename A2>
inline void from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> /*unused*/)
{
    p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> {}, priority_tag<0> {});
}

template<typename BasicJsonType, typename... Args>
std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> /*unused*/, priority_tag<2> /*unused*/)
{
    static_assert(cxpr_and<cxpr_or<cxpr_not<std::is_reference<Args>>, is_compatible_reference_type<BasicJsonType, Args>>...>::value,
                  "Can not return a tuple containing references to types not contained in a Json, try Json::get_to()");
    return from_json_tuple_impl_base<1, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename... Args>
inline void from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> /*unused*/)
{
    t = from_json_tuple_impl_base<2, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> {});
}

template<typename BasicJsonType, typename TupleRelated>
auto from_json(BasicJsonType&& j, TupleRelated&& t)
-> decltype(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {}))
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }

    return from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> {});
}

template < typename BasicJsonType, typename Key, typename Value, typename Compare, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

template < typename BasicJsonType, typename Key, typename Value, typename Hash, typename KeyEqual, typename Allocator,
           typename = enable_if_t < !std::is_constructible <
                                        typename BasicJsonType::string_t, Key >::value >>
inline void from_json(const BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_array()))
    {
        JSON_THROW(type_error::create(302, concat("type must be array, but is ", j.type_name()), &j));
    }
    m.clear();
    for (const auto& p : j)
    {
        if (JSON_HEDLEY_UNLIKELY(!p.is_array()))
        {
            JSON_THROW(type_error::create(302, concat("type must be array, but is ", p.type_name()), &j));
        }
        m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());
    }
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
template<typename BasicJsonType>
inline void from_json(const BasicJsonType& j, std_fs::path& p)
{
    if (JSON_HEDLEY_UNLIKELY(!j.is_string()))
    {
        JSON_THROW(type_error::create(302, concat("type must be string, but is ", j.type_name()), &j));
    }
    const auto& s = *j.template get_ptr<const typename BasicJsonType::string_t*>();
    // Checking for C++20 standard or later can be insufficient in case the
    // library support for char8_t is either incomplete or was disabled
    // altogether. Use the __cpp_lib_char8_t feature test instead.
#if defined(__cpp_lib_char8_t) && (__cpp_lib_char8_t >= 201907L)
    p = std_fs::path(std::u8string_view(reinterpret_cast<const char8_t*>(s.data()), s.size()));
#else
    p = std_fs::u8path(s); // accepts UTF-8 encoded std::string in C++17, deprecated in C++20
#endif
}
#endif

struct from_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(const BasicJsonType& j, T&& val) const
    noexcept(noexcept(from_json(j, std::forward<T>(val))))
    -> decltype(from_json(j, std::forward<T>(val)))
    {
        return from_json(j, std::forward<T>(val));
    }
};

}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `from_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& from_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::from_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/conversions/to_json.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/macro_scope.hpp>
// JSON_HAS_CPP_17
#ifdef JSON_HAS_CPP_17
    #include <optional> // optional
#endif

#include <algorithm> // copy
#include <iterator> // begin, end
#include <memory> // allocator_traits
#include <string> //  basic_string, char_traits
#include <tuple> // tuple, get
#include <type_traits> // is_same, is_constructible, is_floating_point, is_enum, underlying_type
#include <utility> // move, forward, declval, pair
#include <valarray> // valarray
#include <vector> // vector

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t
#include <iterator> // forward_iterator_tag
#include <tuple> // tuple_size, get, tuple_element
#include <utility> // move

#if JSON_HAS_RANGES
    #include <ranges> // enable_borrowed_range
#endif

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/string_utils.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // size_t
#include <string> // string, to_string

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename StringType>
void int_to_string(StringType& target, std::size_t value)
{
    // For ADL
    using std::to_string;
    target = to_string(value);
}

template<typename StringType>
StringType to_string(std::size_t value)
{
    StringType result;
    int_to_string(result, value);
    return result;
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename IteratorType> class iteration_proxy_value
{
  public:
    using difference_type = std::ptrdiff_t;
    using value_type = iteration_proxy_value;
    using pointer = value_type *;
    using reference = value_type &;
    using iterator_category = std::forward_iterator_tag;
    using string_type = typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;

  private:
    /// the iterator
    IteratorType anchor{};
    /// an index for arrays (used to create key names)
    std::size_t array_index = 0;
    /// last stringified array index
    mutable std::size_t array_index_last = 0;
    /// a string representation of the array index
    mutable string_type array_index_str = "0";
    /// an empty string (to return a reference for primitive values)
    string_type empty_str{};

  public:
    explicit iteration_proxy_value() = default;
    explicit iteration_proxy_value(IteratorType it, std::size_t array_index_ = 0)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_default_constructible<string_type>::value)
        : anchor(std::move(it))
        , array_index(array_index_)
    {}

    iteration_proxy_value(iteration_proxy_value const&) = default;
    iteration_proxy_value& operator=(iteration_proxy_value const&) = default;
    // older GCCs are a bit fussy and require explicit noexcept specifiers on defaulted functions
    iteration_proxy_value(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_constructible<IteratorType>::value
             && std::is_nothrow_move_constructible<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    iteration_proxy_value& operator=(iteration_proxy_value&&)
    noexcept(std::is_nothrow_move_assignable<IteratorType>::value
             && std::is_nothrow_move_assignable<string_type>::value) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor,cppcoreguidelines-noexcept-move-operations)
    ~iteration_proxy_value() = default;

    /// dereference operator (needed for range-based for)
    const iteration_proxy_value& operator*() const
    {
        return *this;
    }

    /// increment operator (needed for range-based for)
    iteration_proxy_value& operator++()
    {
        ++anchor;
        ++array_index;

        return *this;
    }

    iteration_proxy_value operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto tmp = iteration_proxy_value(anchor, array_index);
        ++anchor;
        ++array_index;
        return tmp;
    }

    /// equality operator (needed for InputIterator)
    bool operator==(const iteration_proxy_value& o) const
    {
        return anchor == o.anchor;
    }

    /// inequality operator (needed for range-based for)
    bool operator!=(const iteration_proxy_value& o) const
    {
        return anchor != o.anchor;
    }

    /// return key of the iterator
    const string_type& key() const
    {
        JSON_ASSERT(anchor.m_object != nullptr);

        switch (anchor.m_object->type())
        {
            // use integer array index as key
            case value_t::array:
            {
                if (array_index != array_index_last)
                {
                    int_to_string( array_index_str, array_index );
                    array_index_last = array_index;
                }
                return array_index_str;
            }

            // use key from the object
            case value_t::object:
                return anchor.key();

            // use an empty key for all primitive types
            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return empty_str;
        }
    }

    /// return value of the iterator
    typename IteratorType::reference value() const
    {
        return anchor.value();
    }
};

/// proxy class for the items() function
template<typename IteratorType> class iteration_proxy
{
  private:
    /// the container to iterate
    typename IteratorType::pointer container = nullptr;

  public:
    explicit iteration_proxy() = default;

    /// construct iteration proxy from a container
    explicit iteration_proxy(typename IteratorType::reference cont) noexcept
        : container(&cont) {}

    iteration_proxy(iteration_proxy const&) = default;
    iteration_proxy& operator=(iteration_proxy const&) = default;
    iteration_proxy(iteration_proxy&&) noexcept = default;
    iteration_proxy& operator=(iteration_proxy&&) noexcept = default;
    ~iteration_proxy() = default;

    /// return iterator begin (needed for range-based for)
    iteration_proxy_value<IteratorType> begin() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->begin());
    }

    /// return iterator end (needed for range-based for)
    iteration_proxy_value<IteratorType> end() const noexcept
    {
        return iteration_proxy_value<IteratorType>(container->end());
    }
};

// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 0, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.key())
{
    return i.key();
}
// Structured Bindings Support
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
template<std::size_t N, typename IteratorType, enable_if_t<N == 1, int> = 0>
auto get(const nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> decltype(i.value())
{
    return i.value();
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// The Addition to the STD Namespace is required to add
// Structured Bindings Support to the iteration_proxy_value class
// For further reference see https://blog.tartanllama.xyz/structured-bindings/
// And see https://github.com/nlohmann/json/pull/1391
namespace std
{

#if defined(__clang__)
    // Fix: https://github.com/nlohmann/json/issues/1401
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wmismatched-tags"
#endif
template<typename IteratorType>
class tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>> // NOLINT(cert-dcl58-cpp)
    : public std::integral_constant<std::size_t, 2> {};

template<std::size_t N, typename IteratorType>
class tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >> // NOLINT(cert-dcl58-cpp)
{
  public:
    using type = decltype(
                     get<N>(std::declval <
                            ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));
};
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

}  // namespace std

#if JSON_HAS_RANGES
    template <typename IteratorType>
    inline constexpr bool ::std::ranges::enable_borrowed_range<::nlohmann::detail::iteration_proxy<IteratorType>> = true;
#endif

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/std_fs.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////
// constructors //
//////////////////

/*
 * Note all external_constructor<>::construct functions need to call
 * j.m_data.m_value.destroy(j.m_data.m_type) to avoid a memory leak in case j contains an
 * allocated value (e.g., a string). See bug issue
 * https://github.com/nlohmann/json/issues/2865 for more information.
 */

template<value_t> struct external_constructor;

template<>
struct external_constructor<value_t::boolean>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::boolean_t b) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::boolean;
        j.m_data.m_value = b;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::string>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::string_t& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = s;
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::string_t&& s)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value = std::move(s);
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleStringType,
               enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleStringType& str)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::string;
        j.m_data.m_value.string = j.template create<typename BasicJsonType::string_t>(str);
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::binary>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::binary_t& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(b);
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::binary_t&& b)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::binary;
        j.m_data.m_value = typename BasicJsonType::binary_t(std::move(b));
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_float>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_float_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_float;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_unsigned>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_unsigned_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_unsigned;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::number_integer>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::number_integer_t val) noexcept
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::number_integer;
        j.m_data.m_value = val;
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::array>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::array_t& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = arr;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = std::move(arr);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleArrayType,
               enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,
                             int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleArrayType& arr)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const std::vector<bool>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->reserve(arr.size());
        for (const bool x : arr)
        {
            j.m_data.m_value.array->push_back(x);
            j.set_parent(j.m_data.m_value.array->back());
        }
        j.assert_invariant();
    }

    template<typename BasicJsonType, typename T,
             enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
    static void construct(BasicJsonType& j, const std::valarray<T>& arr)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::array;
        j.m_data.m_value = value_t::array;
        j.m_data.m_value.array->resize(arr.size());
        if (arr.size() > 0)
        {
            std::copy(std::begin(arr), std::end(arr), j.m_data.m_value.array->begin());
        }
        j.set_parents();
        j.assert_invariant();
    }
};

template<>
struct external_constructor<value_t::object>
{
    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, const typename BasicJsonType::object_t& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = obj;
        j.set_parents();
        j.assert_invariant();
    }

    template<typename BasicJsonType>
    static void construct(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
    {
        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value = std::move(obj);
        j.set_parents();
        j.assert_invariant();
    }

    template < typename BasicJsonType, typename CompatibleObjectType,
               enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, int > = 0 >
    static void construct(BasicJsonType& j, const CompatibleObjectType& obj)
    {
        using std::begin;
        using std::end;

        j.m_data.m_value.destroy(j.m_data.m_type);
        j.m_data.m_type = value_t::object;
        j.m_data.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));
        j.set_parents();
        j.assert_invariant();
    }
};

/////////////
// to_json //
/////////////

#ifdef JSON_HAS_CPP_17
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_constructible<BasicJsonType, T>::value, int> = 0>
void to_json(BasicJsonType& j, const std::optional<T>& opt) noexcept
{
    if (opt.has_value())
    {
        j = *opt;
    }
    else
    {
        j = nullptr;
    }
}
#endif

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, int> = 0>
inline void to_json(BasicJsonType& j, T b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, b);
}

template < typename BasicJsonType, typename BoolRef,
           enable_if_t <
               ((std::is_same<std::vector<bool>::reference, BoolRef>::value
                 && !std::is_same <std::vector<bool>::reference, typename BasicJsonType::boolean_t&>::value)
                || (std::is_same<std::vector<bool>::const_reference, BoolRef>::value
                    && !std::is_same <detail::uncvref_t<std::vector<bool>::const_reference>,
                                      typename BasicJsonType::boolean_t >::value))
               && std::is_convertible<const BoolRef&, typename BasicJsonType::boolean_t>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const BoolRef& b) noexcept
{
    external_constructor<value_t::boolean>::construct(j, static_cast<typename BasicJsonType::boolean_t>(b));
}

template<typename BasicJsonType, typename CompatibleString,
         enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, int> = 0>
inline void to_json(BasicJsonType& j, const CompatibleString& s)
{
    external_constructor<value_t::string>::construct(j, s);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::string_t&& s)
{
    external_constructor<value_t::string>::construct(j, std::move(s));
}

template<typename BasicJsonType, typename FloatType,
         enable_if_t<std::is_floating_point<FloatType>::value, int> = 0>
inline void to_json(BasicJsonType& j, FloatType val) noexcept
{
    external_constructor<value_t::number_float>::construct(j, static_cast<typename BasicJsonType::number_float_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberUnsignedType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) noexcept
{
    external_constructor<value_t::number_unsigned>::construct(j, static_cast<typename BasicJsonType::number_unsigned_t>(val));
}

template<typename BasicJsonType, typename CompatibleNumberIntegerType,
         enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, int> = 0>
inline void to_json(BasicJsonType& j, CompatibleNumberIntegerType val) noexcept
{
    external_constructor<value_t::number_integer>::construct(j, static_cast<typename BasicJsonType::number_integer_t>(val));
}

#if !JSON_DISABLE_ENUM_SERIALIZATION
template<typename BasicJsonType, typename EnumType,
         enable_if_t<std::is_enum<EnumType>::value, int> = 0>
inline void to_json(BasicJsonType& j, EnumType e) noexcept
{
    using underlying_type = typename std::underlying_type<EnumType>::type;
    static constexpr value_t integral_value_t = std::is_unsigned<underlying_type>::value ? value_t::number_unsigned : value_t::number_integer;
    external_constructor<integral_value_t>::construct(j, static_cast<underlying_type>(e));
}
#endif  // JSON_DISABLE_ENUM_SERIALIZATION

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std::vector<bool>& e)
{
    external_constructor<value_t::array>::construct(j, e);
}

template < typename BasicJsonType, typename CompatibleArrayType,
           enable_if_t < is_compatible_array_type<BasicJsonType,
                         CompatibleArrayType>::value&&
                         !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&
                         !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&
                         !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&
                         !is_basic_json<CompatibleArrayType>::value,
                         int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleArrayType& arr)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const typename BasicJsonType::binary_t& bin)
{
    external_constructor<value_t::binary>::construct(j, bin);
}

template<typename BasicJsonType, typename T,
         enable_if_t<std::is_convertible<T, BasicJsonType>::value, int> = 0>
inline void to_json(BasicJsonType& j, const std::valarray<T>& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::array_t&& arr)
{
    external_constructor<value_t::array>::construct(j, std::move(arr));
}

template < typename BasicJsonType, typename CompatibleObjectType,
           enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const CompatibleObjectType& obj)
{
    external_constructor<value_t::object>::construct(j, obj);
}

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, typename BasicJsonType::object_t&& obj)
{
    external_constructor<value_t::object>::construct(j, std::move(obj));
}

template <
    typename BasicJsonType, typename T, std::size_t N,
    enable_if_t < !std::is_constructible<typename BasicJsonType::string_t,
                  const T(&)[N]>::value, // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
                  int > = 0 >
inline void to_json(BasicJsonType& j, const T(&arr)[N]) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    external_constructor<value_t::array>::construct(j, arr);
}

template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, int > = 0 >
inline void to_json(BasicJsonType& j, const std::pair<T1, T2>& p)
{
    j = { p.first, p.second };
}

// for https://github.com/nlohmann/json/pull/1134
template<typename BasicJsonType, typename T,
         enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, int> = 0>
inline void to_json(BasicJsonType& j, const T& b)
{
    j = { {b.key(), b.value()} };
}

template<typename BasicJsonType, typename Tuple, std::size_t... Idx>
inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& t, index_sequence<Idx...> /*unused*/)
{
    j = { std::get<Idx>(t)... };
}

template<typename BasicJsonType, typename Tuple>
inline void to_json_tuple_impl(BasicJsonType& j, const Tuple& /*unused*/, index_sequence<> /*unused*/)
{
    using array_t = typename BasicJsonType::array_t;
    j = array_t();
}

template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, int > = 0>
inline void to_json(BasicJsonType& j, const T& t)
{
    to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> {});
}

#if JSON_HAS_FILESYSTEM || JSON_HAS_EXPERIMENTAL_FILESYSTEM
#if defined(__cpp_lib_char8_t)
template<typename BasicJsonType, typename Tr, typename Allocator>
inline void to_json(BasicJsonType& j, const std::basic_string<char8_t, Tr, Allocator>& s)
{
    using OtherAllocator = typename std::allocator_traits<Allocator>::template rebind_alloc<char>;
    j = std::basic_string<char, std::char_traits<char>, OtherAllocator>(s.begin(), s.end(), s.get_allocator());
}
#endif

template<typename BasicJsonType>
inline void to_json(BasicJsonType& j, const std_fs::path& p)
{
    // Returns either a std::string or a std::u8string depending whether library
    // support for char8_t is enabled.
    j = p.u8string();
}
#endif

struct to_json_fn
{
    template<typename BasicJsonType, typename T>
    auto operator()(BasicJsonType& j, T&& val) const noexcept(noexcept(to_json(j, std::forward<T>(val))))
    -> decltype(to_json(j, std::forward<T>(val)), void())
    {
        return to_json(j, std::forward<T>(val));
    }
};
}  // namespace detail

#ifndef JSON_HAS_CPP_17
/// namespace to hold default `to_json` function
/// to see why this is required:
/// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html
namespace // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)
{
#endif
JSON_INLINE_VARIABLE constexpr const auto& to_json = // NOLINT(misc-definitions-in-headers)
    detail::static_const<detail::to_json_fn>::value;
#ifndef JSON_HAS_CPP_17
}  // namespace
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/identity_tag.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @sa https://json.nlohmann.me/api/adl_serializer/
template<typename ValueType, typename>
struct adl_serializer
{
    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j, TargetType& val) noexcept(
        noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {
        ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);
    }

    /// @brief convert a JSON value to any value type
    /// @sa https://json.nlohmann.me/api/adl_serializer/from_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto from_json(BasicJsonType && j) noexcept(
    noexcept(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {})))
    -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {}))
    {
        return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> {});
    }

    /// @brief convert any value type to a JSON value
    /// @sa https://json.nlohmann.me/api/adl_serializer/to_json/
    template<typename BasicJsonType, typename TargetType = ValueType>
    static auto to_json(BasicJsonType& j, TargetType && val) noexcept(
        noexcept(::nlohmann::to_json(j, std::forward<TargetType>(val))))
    -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
    {
        ::nlohmann::to_json(j, std::forward<TargetType>(val));
    }
};

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/byte_container_with_subtype.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // uint8_t, uint64_t
#include <tuple> // tie
#include <utility> // move

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief an internal type for a backed binary type
/// @sa https://json.nlohmann.me/api/byte_container_with_subtype/
template<typename BinaryType>
class byte_container_with_subtype : public BinaryType
{
  public:
    using container_type = BinaryType;
    using subtype_type = std::uint64_t;

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype() noexcept(noexcept(container_type()))
        : container_type()
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b) noexcept(noexcept(container_type(b)))
        : container_type(b)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(const container_type& b, subtype_type subtype_) noexcept(noexcept(container_type(b)))
        : container_type(b)
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/byte_container_with_subtype/
    byte_container_with_subtype(container_type&& b, subtype_type subtype_) noexcept(noexcept(container_type(std::move(b))))
        : container_type(std::move(b))
        , m_subtype(subtype_)
        , m_has_subtype(true)
    {}

    bool operator==(const byte_container_with_subtype& rhs) const
    {
        return std::tie(static_cast<const BinaryType&>(*this), m_subtype, m_has_subtype) ==
               std::tie(static_cast<const BinaryType&>(rhs), rhs.m_subtype, rhs.m_has_subtype);
    }

    bool operator!=(const byte_container_with_subtype& rhs) const
    {
        return !(rhs == *this);
    }

    /// @brief sets the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/set_subtype/
    void set_subtype(subtype_type subtype_) noexcept
    {
        m_subtype = subtype_;
        m_has_subtype = true;
    }

    /// @brief return the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/subtype/
    constexpr subtype_type subtype() const noexcept
    {
        return m_has_subtype ? m_subtype : static_cast<subtype_type>(-1);
    }

    /// @brief return whether the value has a subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/has_subtype/
    constexpr bool has_subtype() const noexcept
    {
        return m_has_subtype;
    }

    /// @brief clears the binary subtype
    /// @sa https://json.nlohmann.me/api/byte_container_with_subtype/clear_subtype/
    void clear_subtype() noexcept
    {
        m_subtype = 0;
        m_has_subtype = false;
    }

  private:
    subtype_type m_subtype = 0;
    bool m_has_subtype = false;
};

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/conversions/from_json.hpp>

// #include <nlohmann/detail/conversions/to_json.hpp>

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/hash.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // uint8_t
#include <cstddef> // size_t
#include <functional> // hash

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// boost::hash_combine
inline std::size_t combine(std::size_t seed, std::size_t h) noexcept
{
    seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);
    return seed;
}

/*!
@brief hash a JSON value

The hash function tries to rely on std::hash where possible. Furthermore, the
type of the JSON value is taken into account to have different hash values for
null, 0, 0U, and false, etc.

@tparam BasicJsonType basic_json specialization
@param j JSON value to hash
@return hash value of j
*/
template<typename BasicJsonType>
std::size_t hash(const BasicJsonType& j)
{
    using string_t = typename BasicJsonType::string_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;

    const auto type = static_cast<std::size_t>(j.type());
    switch (j.type())
    {
        case BasicJsonType::value_t::null:
        case BasicJsonType::value_t::discarded:
        {
            return combine(type, 0);
        }

        case BasicJsonType::value_t::object:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j.items())
            {
                const auto h = std::hash<string_t> {}(element.key());
                seed = combine(seed, h);
                seed = combine(seed, hash(element.value()));
            }
            return seed;
        }

        case BasicJsonType::value_t::array:
        {
            auto seed = combine(type, j.size());
            for (const auto& element : j)
            {
                seed = combine(seed, hash(element));
            }
            return seed;
        }

        case BasicJsonType::value_t::string:
        {
            const auto h = std::hash<string_t> {}(j.template get_ref<const string_t&>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::boolean:
        {
            const auto h = std::hash<bool> {}(j.template get<bool>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_integer:
        {
            const auto h = std::hash<number_integer_t> {}(j.template get<number_integer_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_unsigned:
        {
            const auto h = std::hash<number_unsigned_t> {}(j.template get<number_unsigned_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::number_float:
        {
            const auto h = std::hash<number_float_t> {}(j.template get<number_float_t>());
            return combine(type, h);
        }

        case BasicJsonType::value_t::binary:
        {
            auto seed = combine(type, j.get_binary().size());
            const auto h = std::hash<bool> {}(j.get_binary().has_subtype());
            seed = combine(seed, h);
            seed = combine(seed, static_cast<std::size_t>(j.get_binary().subtype()));
            for (const auto byte : j.get_binary())
            {
                seed = combine(seed, std::hash<std::uint8_t> {}(byte));
            }
            return seed;
        }

        default:                   // LCOV_EXCL_LINE
            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            return 0;              // LCOV_EXCL_LINE
    }
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/binary_reader.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // generate_n
#include <array> // array
#include <cmath> // ldexp
#include <cstddef> // size_t
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstdio> // snprintf
#include <cstring> // memcpy
#include <iterator> // back_inserter
#include <limits> // numeric_limits
#include <string> // char_traits, string
#include <utility> // make_pair, move
#include <vector> // vector
#ifdef __cpp_lib_byteswap
    #include <bit>  //byteswap
#endif

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cstddef> // size_t
#include <cstring> // strlen
#include <iterator> // begin, end, iterator_traits, random_access_iterator_tag, distance, next
#include <memory> // shared_ptr, make_shared, addressof
#include <numeric> // accumulate
#include <streambuf> // streambuf
#include <string> // string, char_traits
#include <type_traits> // enable_if, is_base_of, is_pointer, is_integral, remove_pointer
#include <utility> // pair, declval

#ifndef JSON_NO_IO
    #include <cstdio>   // FILE *
    #include <istream>  // istream
#endif                  // JSON_NO_IO

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/iterator_traits.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// the supported input formats
enum class input_format_t { json, cbor, msgpack, ubjson, bson, bjdata };

////////////////////
// input adapters //
////////////////////

#ifndef JSON_NO_IO
/*!
Input adapter for stdio file access. This adapter read only 1 byte and do not use any
 buffer. This adapter is a very low level adapter.
*/
class file_input_adapter
{
  public:
    using char_type = char;

    JSON_HEDLEY_NON_NULL(2)
    explicit file_input_adapter(std::FILE* f) noexcept
        : m_file(f)
    {
        JSON_ASSERT(m_file != nullptr);
    }

    // make class move-only
    file_input_adapter(const file_input_adapter&) = delete;
    file_input_adapter(file_input_adapter&&) noexcept = default;
    file_input_adapter& operator=(const file_input_adapter&) = delete;
    file_input_adapter& operator=(file_input_adapter&&) = delete;
    ~file_input_adapter() = default;

    std::char_traits<char>::int_type get_character() noexcept
    {
        return std::fgetc(m_file);
    }

    // returns the number of characters successfully read
    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        return fread(dest, 1, sizeof(T) * count, m_file);
    }

  private:
    /// the file pointer to read from
    std::FILE* m_file;
};

/*!
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at
beginning of input. Does not support changing the underlying std::streambuf
in mid-input. Maintains underlying std::istream and std::streambuf to support
subsequent use of standard std::istream operations to process any input
characters following those used in parsing the JSON input.  Clears the
std::istream flags; any input errors (e.g., EOF) will be detected by the first
subsequent call for input from the std::istream.
*/
class input_stream_adapter
{
  public:
    using char_type = char;

    ~input_stream_adapter()
    {
        // clear stream flags; we use underlying streambuf I/O, do not
        // maintain ifstream flags, except eof
        if (is != nullptr)
        {
            is->clear(is->rdstate() & std::ios::eofbit);
        }
    }

    explicit input_stream_adapter(std::istream& i)
        : is(&i), sb(i.rdbuf())
    {}

    // deleted because of pointer members
    input_stream_adapter(const input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&) = delete;
    input_stream_adapter& operator=(input_stream_adapter&&) = delete;

    input_stream_adapter(input_stream_adapter&& rhs) noexcept
        : is(rhs.is), sb(rhs.sb)
    {
        rhs.is = nullptr;
        rhs.sb = nullptr;
    }

    // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to
    // ensure that std::char_traits<char>::eof() and the character 0xFF do not
    // end up as the same value, e.g., 0xFFFFFFFF.
    std::char_traits<char>::int_type get_character()
    {
        auto res = sb->sbumpc();
        // set eof manually, as we don't use the istream interface.
        if (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        auto res = static_cast<std::size_t>(sb->sgetn(reinterpret_cast<char*>(dest), static_cast<std::streamsize>(count * sizeof(T))));
        if (JSON_HEDLEY_UNLIKELY(res < count * sizeof(T)))
        {
            is->clear(is->rdstate() | std::ios::eofbit);
        }
        return res;
    }

  private:
    /// the associated input stream
    std::istream* is = nullptr;
    std::streambuf* sb = nullptr;
};
#endif  // JSON_NO_IO

// General-purpose iterator-based adapter. It might not be as fast as
// theoretically possible for some containers, but it is extremely versatile.
template<typename IteratorType>
class iterator_input_adapter
{
  public:
    using char_type = typename std::iterator_traits<IteratorType>::value_type;

    iterator_input_adapter(IteratorType first, IteratorType last)
        : current(std::move(first)), end(std::move(last))
    {}

    typename char_traits<char_type>::int_type get_character()
    {
        if (JSON_HEDLEY_LIKELY(current != end))
        {
            auto result = char_traits<char_type>::to_int_type(*current);
            std::advance(current, 1);
            return result;
        }

        return char_traits<char_type>::eof();
    }

    // for general iterators, we cannot really do something better than falling back to processing the range one-by-one
    template<class T>
    std::size_t get_elements(T* dest, std::size_t count = 1)
    {
        auto* ptr = reinterpret_cast<char*>(dest);
        for (std::size_t read_index = 0; read_index < count * sizeof(T); ++read_index)
        {
            if (JSON_HEDLEY_LIKELY(current != end))
            {
                ptr[read_index] = static_cast<char>(*current);
                std::advance(current, 1);
            }
            else
            {
                return read_index;
            }
        }
        return count * sizeof(T);
    }

  private:
    IteratorType current;
    IteratorType end;

    template<typename BaseInputAdapter, size_t T>
    friend struct wide_string_input_helper;

    bool empty() const
    {
        return current == end;
    }
};

template<typename BaseInputAdapter, size_t T>
struct wide_string_input_helper;

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 4>
{
    // UTF-32
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-32 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u) & 0x1Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (wc <= 0xFFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u) & 0x0Fu));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else if (wc <= 0x10FFFF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | ((static_cast<unsigned int>(wc) >> 18u) & 0x07u));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 12u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 4;
            }
            else
            {
                // unknown character
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
        }
    }
};

template<typename BaseInputAdapter>
struct wide_string_input_helper<BaseInputAdapter, 2>
{
    // UTF-16
    static void fill_buffer(BaseInputAdapter& input,
                            std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,
                            size_t& utf8_bytes_index,
                            size_t& utf8_bytes_filled)
    {
        utf8_bytes_index = 0;

        if (JSON_HEDLEY_UNLIKELY(input.empty()))
        {
            utf8_bytes[0] = std::char_traits<char>::eof();
            utf8_bytes_filled = 1;
        }
        else
        {
            // get the current character
            const auto wc = input.get_character();

            // UTF-16 to UTF-8 encoding
            if (wc < 0x80)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                utf8_bytes_filled = 1;
            }
            else if (wc <= 0x7FF)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xC0u | ((static_cast<unsigned int>(wc) >> 6u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 2;
            }
            else if (0xD800 > wc || wc >= 0xE000)
            {
                utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xE0u | ((static_cast<unsigned int>(wc) >> 12u)));
                utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((static_cast<unsigned int>(wc) >> 6u) & 0x3Fu));
                utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | (static_cast<unsigned int>(wc) & 0x3Fu));
                utf8_bytes_filled = 3;
            }
            else
            {
                if (JSON_HEDLEY_UNLIKELY(!input.empty()))
                {
                    const auto wc2 = static_cast<unsigned int>(input.get_character());
                    const auto charcode = 0x10000u + (((static_cast<unsigned int>(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(0xF0u | (charcode >> 18u));
                    utf8_bytes[1] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 12u) & 0x3Fu));
                    utf8_bytes[2] = static_cast<std::char_traits<char>::int_type>(0x80u | ((charcode >> 6u) & 0x3Fu));
                    utf8_bytes[3] = static_cast<std::char_traits<char>::int_type>(0x80u | (charcode & 0x3Fu));
                    utf8_bytes_filled = 4;
                }
                else
                {
                    utf8_bytes[0] = static_cast<std::char_traits<char>::int_type>(wc);
                    utf8_bytes_filled = 1;
                }
            }
        }
    }
};

// Wraps another input adapter to convert wide character types into individual bytes.
template<typename BaseInputAdapter, typename WideCharType>
class wide_string_input_adapter
{
  public:
    using char_type = char;

    wide_string_input_adapter(BaseInputAdapter base)
        : base_adapter(base) {}

    typename std::char_traits<char>::int_type get_character() noexcept
    {
        // check if the buffer needs to be filled
        if (utf8_bytes_index == utf8_bytes_filled)
        {
            fill_buffer<sizeof(WideCharType)>();

            JSON_ASSERT(utf8_bytes_filled > 0);
            JSON_ASSERT(utf8_bytes_index == 0);
        }

        // use buffer
        JSON_ASSERT(utf8_bytes_filled > 0);
        JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);
        return utf8_bytes[utf8_bytes_index++];
    }

    // parsing binary with wchar doesn't make sense, but since the parsing mode can be runtime, we need something here
    template<class T>
    std::size_t get_elements(T* /*dest*/, std::size_t /*count*/ = 1)
    {
        JSON_THROW(parse_error::create(112, 1, "wide string type cannot be interpreted as binary data", nullptr));
    }

  private:
    BaseInputAdapter base_adapter;

    template<size_t T>
    void fill_buffer()
    {
        wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);
    }

    /// a buffer for UTF-8 bytes
    std::array<std::char_traits<char>::int_type, 4> utf8_bytes = {{0, 0, 0, 0}};

    /// index to the utf8_codes array for the next valid byte
    std::size_t utf8_bytes_index = 0;
    /// number of valid bytes in the utf8_codes array
    std::size_t utf8_bytes_filled = 0;
};

template<typename IteratorType, typename Enable = void>
struct iterator_input_adapter_factory
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using adapter_type = iterator_input_adapter<iterator_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(std::move(first), std::move(last));
    }
};

template<typename T>
struct is_iterator_of_multibyte
{
    using value_type = typename std::iterator_traits<T>::value_type;
    enum // NOLINT(cppcoreguidelines-use-enum-class)
    {
        value = sizeof(value_type) > 1
    };
};

template<typename IteratorType>
struct iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>
{
    using iterator_type = IteratorType;
    using char_type = typename std::iterator_traits<iterator_type>::value_type;
    using base_adapter_type = iterator_input_adapter<iterator_type>;
    using adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;

    static adapter_type create(IteratorType first, IteratorType last)
    {
        return adapter_type(base_adapter_type(std::move(first), std::move(last)));
    }
};

// General purpose iterator-based input
template<typename IteratorType>
typename iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)
{
    using factory_type = iterator_input_adapter_factory<IteratorType>;
    return factory_type::create(first, last);
}

// Convenience shorthand from container to iterator
// Enables ADL on begin(container) and end(container)
// Encloses the using declarations in namespace for not to leak them to outside scope

namespace container_input_adapter_factory_impl
{

using std::begin;
using std::end;

template<typename ContainerType, typename Enable = void>
struct container_input_adapter_factory {};

template<typename ContainerType>
struct container_input_adapter_factory< ContainerType,
       void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>
       {
           using adapter_type = decltype(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));

           static adapter_type create(const ContainerType& container)
{
    return input_adapter(begin(container), end(container));
}
       };

}  // namespace container_input_adapter_factory_impl

template<typename ContainerType>
typename container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter(const ContainerType& container)
{
    return container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);
}

// specialization for std::string
using string_input_adapter_type = decltype(input_adapter(std::declval<std::string>()));

#ifndef JSON_NO_IO
// Special cases with fast paths
inline file_input_adapter input_adapter(std::FILE* file)
{
    if (file == nullptr)
    {
        JSON_THROW(parse_error::create(101, 0, "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
    }
    return file_input_adapter(file);
}

inline input_stream_adapter input_adapter(std::istream& stream)
{
    return input_stream_adapter(stream);
}

inline input_stream_adapter input_adapter(std::istream&& stream)
{
    return input_stream_adapter(stream);
}
#endif  // JSON_NO_IO

using contiguous_bytes_input_adapter = decltype(input_adapter(std::declval<const char*>(), std::declval<const char*>()));

// Null-delimited strings, and the like.
template < typename CharT,
           typename std::enable_if <
               std::is_pointer<CharT>::value&&
               !std::is_array<CharT>::value&&
               std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
               sizeof(typename std::remove_pointer<CharT>::type) == 1,
               int >::type = 0 >
contiguous_bytes_input_adapter input_adapter(CharT b)
{
    if (b == nullptr)
    {
        JSON_THROW(parse_error::create(101, 0, "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
    }
    auto length = std::strlen(reinterpret_cast<const char*>(b));
    const auto* ptr = reinterpret_cast<const char*>(b);
    return input_adapter(ptr, ptr + length); // cppcheck-suppress[nullPointerArithmeticRedundantCheck]
}

template<typename T, std::size_t N>
auto input_adapter(T (&array)[N]) -> decltype(input_adapter(array, array + N)) // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
{
    return input_adapter(array, array + N);
}

// This class only handles inputs of input_buffer_adapter type.
// It's required so that expressions like {ptr, len} can be implicitly cast
// to the correct adapter.
class span_input_adapter
{
  public:
    template < typename CharT,
               typename std::enable_if <
                   std::is_pointer<CharT>::value&&
                   std::is_integral<typename std::remove_pointer<CharT>::type>::value&&
                   sizeof(typename std::remove_pointer<CharT>::type) == 1,
                   int >::type = 0 >
    span_input_adapter(CharT b, std::size_t l)
        : ia(reinterpret_cast<const char*>(b), reinterpret_cast<const char*>(b) + l) {}

    template<class IteratorType,
             typename std::enable_if<
                 std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,
                 int>::type = 0>
    span_input_adapter(IteratorType first, IteratorType last)
        : ia(input_adapter(first, last)) {}

    contiguous_bytes_input_adapter&& get()
    {
        return std::move(ia); // NOLINT(hicpp-move-const-arg,performance-move-const-arg)
    }

  private:
    contiguous_bytes_input_adapter ia;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/json_sax.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef>
#include <string> // string
#include <type_traits> // enable_if_t
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/lexer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <clocale> // localeconv
#include <cstddef> // size_t
#include <cstdio> // snprintf
#include <cstdlib> // strtof, strtod, strtold, strtoll, strtoull
#include <initializer_list> // initializer_list
#include <string> // char_traits, string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/position_t.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////
// lexer //
///////////

template<typename BasicJsonType>
class lexer_base
{
  public:
    /// token types for the parser
    enum class token_type
    {
        uninitialized,    ///< indicating the scanner is uninitialized
        literal_true,     ///< the `true` literal
        literal_false,    ///< the `false` literal
        literal_null,     ///< the `null` literal
        value_string,     ///< a string -- use get_string() for actual value
        value_unsigned,   ///< an unsigned integer -- use get_number_unsigned() for actual value
        value_integer,    ///< a signed integer -- use get_number_integer() for actual value
        value_float,      ///< an floating point number -- use get_number_float() for actual value
        begin_array,      ///< the character for array begin `[`
        begin_object,     ///< the character for object begin `{`
        end_array,        ///< the character for array end `]`
        end_object,       ///< the character for object end `}`
        name_separator,   ///< the name separator `:`
        value_separator,  ///< the value separator `,`
        parse_error,      ///< indicating a parse error
        end_of_input,     ///< indicating the end of the input buffer
        literal_or_value  ///< a literal or the begin of a value (only for diagnostics)
    };

    /// return name of values of type token_type (only used for errors)
    JSON_HEDLEY_RETURNS_NON_NULL
    JSON_HEDLEY_CONST
    static const char* token_type_name(const token_type t) noexcept
    {
        switch (t)
        {
            case token_type::uninitialized:
                return "<uninitialized>";
            case token_type::literal_true:
                return "true literal";
            case token_type::literal_false:
                return "false literal";
            case token_type::literal_null:
                return "null literal";
            case token_type::value_string:
                return "string literal";
            case token_type::value_unsigned:
            case token_type::value_integer:
            case token_type::value_float:
                return "number literal";
            case token_type::begin_array:
                return "'['";
            case token_type::begin_object:
                return "'{'";
            case token_type::end_array:
                return "']'";
            case token_type::end_object:
                return "'}'";
            case token_type::name_separator:
                return "':'";
            case token_type::value_separator:
                return "','";
            case token_type::parse_error:
                return "<parse error>";
            case token_type::end_of_input:
                return "end of input";
            case token_type::literal_or_value:
                return "'[', '{', or a literal";
            // LCOV_EXCL_START
            default: // catch non-enum values
                return "unknown token";
                // LCOV_EXCL_STOP
        }
    }
};
/*!
@brief lexical analysis

This class organizes the lexical analysis during JSON deserialization.
*/
template<typename BasicJsonType, typename InputAdapterType>
class lexer : public lexer_base<BasicJsonType>
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename char_traits<char_type>::int_type;

  public:
    using token_type = typename lexer_base<BasicJsonType>::token_type;

    explicit lexer(InputAdapterType&& adapter, bool ignore_comments_ = false) noexcept
        : ia(std::move(adapter))
        , ignore_comments(ignore_comments_)
        , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))
    {}

    // deleted because of pointer members
    lexer(const lexer&) = delete;
    lexer(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    lexer& operator=(lexer&) = delete;
    lexer& operator=(lexer&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~lexer() = default;

  private:
    /////////////////////
    // locales
    /////////////////////

    /// return the locale-dependent decimal point
    JSON_HEDLEY_PURE
    static char get_decimal_point() noexcept
    {
        const auto* loc = localeconv();
        JSON_ASSERT(loc != nullptr);
        return (loc->decimal_point == nullptr) ? '.' : *(loc->decimal_point);
    }

    /////////////////////
    // scan functions
    /////////////////////

    /*!
    @brief get codepoint from 4 hex characters following `\u`

    For input "\u c1 c2 c3 c4" the codepoint is:
      (c1 * 0x1000) + (c2 * 0x0100) + (c3 * 0x0010) + c4
    = (c1 << 12) + (c2 << 8) + (c3 << 4) + (c4 << 0)

    Furthermore, the possible characters '0'..'9', 'A'..'F', and 'a'..'f'
    must be converted to the integers 0x0..0x9, 0xA..0xF, 0xA..0xF, resp. The
    conversion is done by subtracting the offset (0x30, 0x37, and 0x57)
    between the ASCII value of the character and the desired integer value.

    @return codepoint (0x0000..0xFFFF) or -1 in case of an error (e.g. EOF or
            non-hex character)
    */
    int get_codepoint()
    {
        // this function only makes sense after reading `\u`
        JSON_ASSERT(current == 'u');
        int codepoint = 0;

        const auto factors = { 12u, 8u, 4u, 0u };
        for (const auto factor : factors)
        {
            get();

            if (current >= '0' && current <= '9')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x30u) << factor);
            }
            else if (current >= 'A' && current <= 'F')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x37u) << factor);
            }
            else if (current >= 'a' && current <= 'f')
            {
                codepoint += static_cast<int>((static_cast<unsigned int>(current) - 0x57u) << factor);
            }
            else
            {
                return -1;
            }
        }

        JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);
        return codepoint;
    }

    /*!
    @brief check if the next byte(s) are inside a given range

    Adds the current byte and, for each passed range, reads a new byte and
    checks if it is inside the range. If a violation was detected, set up an
    error message and return false. Otherwise, return true.

    @param[in] ranges  list of integers; interpreted as list of pairs of
                       inclusive lower and upper bound, respectively

    @pre The passed list @a ranges must have 2, 4, or 6 elements; that is,
         1, 2, or 3 pairs. This precondition is enforced by an assertion.

    @return true if and only if no range violation was detected
    */
    bool next_byte_in_range(std::initializer_list<char_int_type> ranges)
    {
        JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);
        add(current);

        for (auto range = ranges.begin(); range != ranges.end(); ++range)
        {
            get();
            if (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range))) // NOLINT(bugprone-inc-dec-in-conditions)
            {
                add(current);
            }
            else
            {
                error_message = "invalid string: ill-formed UTF-8 byte";
                return false;
            }
        }

        return true;
    }

    /*!
    @brief scan a string literal

    This function scans a string according to Sect. 7 of RFC 8259. While
    scanning, bytes are escaped and copied into buffer token_buffer. Then the
    function returns successfully, token_buffer is *not* null-terminated (as it
    may contain \0 bytes), and token_buffer.size() is the number of bytes in the
    string.

    @return token_type::value_string if string could be successfully scanned,
            token_type::parse_error otherwise

    @note In case of errors, variable error_message contains a textual
          description.
    */
    token_type scan_string()
    {
        // reset token_buffer (ignore opening quote)
        reset();

        // we entered the function by reading an open quote
        JSON_ASSERT(current == '\"');

        while (true)
        {
            // get the next character
            switch (get())
            {
                // end of file while parsing the string
                case char_traits<char_type>::eof():
                {
                    error_message = "invalid string: missing closing quote";
                    return token_type::parse_error;
                }

                // closing quote
                case '\"':
                {
                    return token_type::value_string;
                }

                // escapes
                case '\\':
                {
                    switch (get())
                    {
                        // quotation mark
                        case '\"':
                            add('\"');
                            break;
                        // reverse solidus
                        case '\\':
                            add('\\');
                            break;
                        // solidus
                        case '/':
                            add('/');
                            break;
                        // backspace
                        case 'b':
                            add('\b');
                            break;
                        // form feed
                        case 'f':
                            add('\f');
                            break;
                        // line feed
                        case 'n':
                            add('\n');
                            break;
                        // carriage return
                        case 'r':
                            add('\r');
                            break;
                        // tab
                        case 't':
                            add('\t');
                            break;

                        // unicode escapes
                        case 'u':
                        {
                            const int codepoint1 = get_codepoint();
                            int codepoint = codepoint1; // start with codepoint1

                            if (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))
                            {
                                error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                return token_type::parse_error;
                            }

                            // check if code point is a high surrogate
                            if (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)
                            {
                                // expect next \uxxxx entry
                                if (JSON_HEDLEY_LIKELY(get() == '\\' && get() == 'u'))
                                {
                                    const int codepoint2 = get_codepoint();

                                    if (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))
                                    {
                                        error_message = "invalid string: '\\u' must be followed by 4 hex digits";
                                        return token_type::parse_error;
                                    }

                                    // check if codepoint2 is a low surrogate
                                    if (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))
                                    {
                                        // overwrite codepoint
                                        codepoint = static_cast<int>(
                                                        // high surrogate occupies the most significant 22 bits
                                                        (static_cast<unsigned int>(codepoint1) << 10u)
                                                        // low surrogate occupies the least significant 15 bits
                                                        + static_cast<unsigned int>(codepoint2)
                                                        // there is still the 0xD800, 0xDC00, and 0x10000 noise
                                                        // in the result, so we have to subtract with:
                                                        // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00
                                                        - 0x35FDC00u);
                                    }
                                    else
                                    {
                                        error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                        return token_type::parse_error;
                                    }
                                }
                                else
                                {
                                    error_message = "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF";
                                    return token_type::parse_error;
                                }
                            }
                            else
                            {
                                if (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))
                                {
                                    error_message = "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF";
                                    return token_type::parse_error;
                                }
                            }

                            // the result of the above calculation yields a proper codepoint
                            JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);

                            // translate codepoint into bytes
                            if (codepoint < 0x80)
                            {
                                // 1-byte characters: 0xxxxxxx (ASCII)
                                add(static_cast<char_int_type>(codepoint));
                            }
                            else if (codepoint <= 0x7FF)
                            {
                                // 2-byte characters: 110xxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xC0u | (static_cast<unsigned int>(codepoint) >> 6u)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else if (codepoint <= 0xFFFF)
                            {
                                // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xE0u | (static_cast<unsigned int>(codepoint) >> 12u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }
                            else
                            {
                                // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
                                add(static_cast<char_int_type>(0xF0u | (static_cast<unsigned int>(codepoint) >> 18u)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 12u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | ((static_cast<unsigned int>(codepoint) >> 6u) & 0x3Fu)));
                                add(static_cast<char_int_type>(0x80u | (static_cast<unsigned int>(codepoint) & 0x3Fu)));
                            }

                            break;
                        }

                        // other characters after escape
                        default:
                            error_message = "invalid string: forbidden character after backslash";
                            return token_type::parse_error;
                    }

                    break;
                }

                // invalid control characters
                case 0x00:
                {
                    error_message = "invalid string: control character U+0000 (NUL) must be escaped to \\u0000";
                    return token_type::parse_error;
                }

                case 0x01:
                {
                    error_message = "invalid string: control character U+0001 (SOH) must be escaped to \\u0001";
                    return token_type::parse_error;
                }

                case 0x02:
                {
                    error_message = "invalid string: control character U+0002 (STX) must be escaped to \\u0002";
                    return token_type::parse_error;
                }

                case 0x03:
                {
                    error_message = "invalid string: control character U+0003 (ETX) must be escaped to \\u0003";
                    return token_type::parse_error;
                }

                case 0x04:
                {
                    error_message = "invalid string: control character U+0004 (EOT) must be escaped to \\u0004";
                    return token_type::parse_error;
                }

                case 0x05:
                {
                    error_message = "invalid string: control character U+0005 (ENQ) must be escaped to \\u0005";
                    return token_type::parse_error;
                }

                case 0x06:
                {
                    error_message = "invalid string: control character U+0006 (ACK) must be escaped to \\u0006";
                    return token_type::parse_error;
                }

                case 0x07:
                {
                    error_message = "invalid string: control character U+0007 (BEL) must be escaped to \\u0007";
                    return token_type::parse_error;
                }

                case 0x08:
                {
                    error_message = "invalid string: control character U+0008 (BS) must be escaped to \\u0008 or \\b";
                    return token_type::parse_error;
                }

                case 0x09:
                {
                    error_message = "invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t";
                    return token_type::parse_error;
                }

                case 0x0A:
                {
                    error_message = "invalid string: control character U+000A (LF) must be escaped to \\u000A or \\n";
                    return token_type::parse_error;
                }

                case 0x0B:
                {
                    error_message = "invalid string: control character U+000B (VT) must be escaped to \\u000B";
                    return token_type::parse_error;
                }

                case 0x0C:
                {
                    error_message = "invalid string: control character U+000C (FF) must be escaped to \\u000C or \\f";
                    return token_type::parse_error;
                }

                case 0x0D:
                {
                    error_message = "invalid string: control character U+000D (CR) must be escaped to \\u000D or \\r";
                    return token_type::parse_error;
                }

                case 0x0E:
                {
                    error_message = "invalid string: control character U+000E (SO) must be escaped to \\u000E";
                    return token_type::parse_error;
                }

                case 0x0F:
                {
                    error_message = "invalid string: control character U+000F (SI) must be escaped to \\u000F";
                    return token_type::parse_error;
                }

                case 0x10:
                {
                    error_message = "invalid string: control character U+0010 (DLE) must be escaped to \\u0010";
                    return token_type::parse_error;
                }

                case 0x11:
                {
                    error_message = "invalid string: control character U+0011 (DC1) must be escaped to \\u0011";
                    return token_type::parse_error;
                }

                case 0x12:
                {
                    error_message = "invalid string: control character U+0012 (DC2) must be escaped to \\u0012";
                    return token_type::parse_error;
                }

                case 0x13:
                {
                    error_message = "invalid string: control character U+0013 (DC3) must be escaped to \\u0013";
                    return token_type::parse_error;
                }

                case 0x14:
                {
                    error_message = "invalid string: control character U+0014 (DC4) must be escaped to \\u0014";
                    return token_type::parse_error;
                }

                case 0x15:
                {
                    error_message = "invalid string: control character U+0015 (NAK) must be escaped to \\u0015";
                    return token_type::parse_error;
                }

                case 0x16:
                {
                    error_message = "invalid string: control character U+0016 (SYN) must be escaped to \\u0016";
                    return token_type::parse_error;
                }

                case 0x17:
                {
                    error_message = "invalid string: control character U+0017 (ETB) must be escaped to \\u0017";
                    return token_type::parse_error;
                }

                case 0x18:
                {
                    error_message = "invalid string: control character U+0018 (CAN) must be escaped to \\u0018";
                    return token_type::parse_error;
                }

                case 0x19:
                {
                    error_message = "invalid string: control character U+0019 (EM) must be escaped to \\u0019";
                    return token_type::parse_error;
                }

                case 0x1A:
                {
                    error_message = "invalid string: control character U+001A (SUB) must be escaped to \\u001A";
                    return token_type::parse_error;
                }

                case 0x1B:
                {
                    error_message = "invalid string: control character U+001B (ESC) must be escaped to \\u001B";
                    return token_type::parse_error;
                }

                case 0x1C:
                {
                    error_message = "invalid string: control character U+001C (FS) must be escaped to \\u001C";
                    return token_type::parse_error;
                }

                case 0x1D:
                {
                    error_message = "invalid string: control character U+001D (GS) must be escaped to \\u001D";
                    return token_type::parse_error;
                }

                case 0x1E:
                {
                    error_message = "invalid string: control character U+001E (RS) must be escaped to \\u001E";
                    return token_type::parse_error;
                }

                case 0x1F:
                {
                    error_message = "invalid string: control character U+001F (US) must be escaped to \\u001F";
                    return token_type::parse_error;
                }

                // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))
                case 0x20:
                case 0x21:
                case 0x23:
                case 0x24:
                case 0x25:
                case 0x26:
                case 0x27:
                case 0x28:
                case 0x29:
                case 0x2A:
                case 0x2B:
                case 0x2C:
                case 0x2D:
                case 0x2E:
                case 0x2F:
                case 0x30:
                case 0x31:
                case 0x32:
                case 0x33:
                case 0x34:
                case 0x35:
                case 0x36:
                case 0x37:
                case 0x38:
                case 0x39:
                case 0x3A:
                case 0x3B:
                case 0x3C:
                case 0x3D:
                case 0x3E:
                case 0x3F:
                case 0x40:
                case 0x41:
                case 0x42:
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                case 0x4C:
                case 0x4D:
                case 0x4E:
                case 0x4F:
                case 0x50:
                case 0x51:
                case 0x52:
                case 0x53:
                case 0x54:
                case 0x55:
                case 0x56:
                case 0x57:
                case 0x58:
                case 0x59:
                case 0x5A:
                case 0x5B:
                case 0x5D:
                case 0x5E:
                case 0x5F:
                case 0x60:
                case 0x61:
                case 0x62:
                case 0x63:
                case 0x64:
                case 0x65:
                case 0x66:
                case 0x67:
                case 0x68:
                case 0x69:
                case 0x6A:
                case 0x6B:
                case 0x6C:
                case 0x6D:
                case 0x6E:
                case 0x6F:
                case 0x70:
                case 0x71:
                case 0x72:
                case 0x73:
                case 0x74:
                case 0x75:
                case 0x76:
                case 0x77:
                case 0x78:
                case 0x79:
                case 0x7A:
                case 0x7B:
                case 0x7C:
                case 0x7D:
                case 0x7E:
                case 0x7F:
                {
                    add(current);
                    break;
                }

                // U+0080..U+07FF: bytes C2..DF 80..BF
                case 0xC2:
                case 0xC3:
                case 0xC4:
                case 0xC5:
                case 0xC6:
                case 0xC7:
                case 0xC8:
                case 0xC9:
                case 0xCA:
                case 0xCB:
                case 0xCC:
                case 0xCD:
                case 0xCE:
                case 0xCF:
                case 0xD0:
                case 0xD1:
                case 0xD2:
                case 0xD3:
                case 0xD4:
                case 0xD5:
                case 0xD6:
                case 0xD7:
                case 0xD8:
                case 0xD9:
                case 0xDA:
                case 0xDB:
                case 0xDC:
                case 0xDD:
                case 0xDE:
                case 0xDF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!next_byte_in_range({0x80, 0xBF})))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+0800..U+0FFF: bytes E0 A0..BF 80..BF
                case 0xE0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0xA0, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF
                // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF
                case 0xE1:
                case 0xE2:
                case 0xE3:
                case 0xE4:
                case 0xE5:
                case 0xE6:
                case 0xE7:
                case 0xE8:
                case 0xE9:
                case 0xEA:
                case 0xEB:
                case 0xEC:
                case 0xEE:
                case 0xEF:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+D000..U+D7FF: bytes ED 80..9F 80..BF
                case 0xED:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x9F, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF
                case 0xF0:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF
                case 0xF1:
                case 0xF2:
                case 0xF3:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF
                case 0xF4:
                {
                    if (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range({0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF}))))
                    {
                        return token_type::parse_error;
                    }
                    break;
                }

                // the remaining bytes (80..C1 and F5..FF) are ill-formed
                default:
                {
                    error_message = "invalid string: ill-formed UTF-8 byte";
                    return token_type::parse_error;
                }
            }
        }
    }

    /*!
     * @brief scan a comment
     * @return whether comment could be scanned successfully
     */
    bool scan_comment()
    {
        switch (get())
        {
            // single-line comments skip input until a newline or EOF is read
            case '/':
            {
                while (true)
                {
                    switch (get())
                    {
                        case '\n':
                        case '\r':
                        case char_traits<char_type>::eof():
                        case '\0':
                            return true;

                        default:
                            break;
                    }
                }

                JSON_HEDLEY_UNREACHABLE();
            }

            // multi-line comments skip input until */ is read
            case '*':
            {
                while (true)
                {
                    switch (get())
                    {
                        case char_traits<char_type>::eof():
                        case '\0':
                        {
                            error_message = "invalid comment; missing closing '*/'";
                            return false;
                        }

                        case '*':
                        {
                            switch (get())
                            {
                                case '/':
                                    return true;

                                default:
                                {
                                    unget();
                                    continue;
                                }
                            }
                        }

                        default:
                            continue;
                    }
                }

                JSON_HEDLEY_UNREACHABLE();
            }

            // unexpected character after reading '/'
            default:
            {
                error_message = "invalid comment; expecting '/' or '*' after '/'";
                return false;
            }
        }
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(float& f, const char* str, char** endptr) noexcept
    {
        f = std::strtof(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtod(str, endptr);
    }

    JSON_HEDLEY_NON_NULL(2)
    static void strtof(long double& f, const char* str, char** endptr) noexcept
    {
        f = std::strtold(str, endptr);
    }

    /*!
    @brief scan a number literal

    This function scans a string according to Sect. 6 of RFC 8259.

    The function is realized with a deterministic finite state machine derived
    from the grammar described in RFC 8259. Starting in state "init", the
    input is read and used to determined the next state. Only state "done"
    accepts the number. State "error" is a trap state to model errors. In the
    table below, "anything" means any character but the ones listed before.

    state    | 0        | 1-9      | e E      | +       | -       | .        | anything
    ---------|----------|----------|----------|---------|---------|----------|-----------
    init     | zero     | any1     | [error]  | [error] | minus   | [error]  | [error]
    minus    | zero     | any1     | [error]  | [error] | [error] | [error]  | [error]
    zero     | done     | done     | exponent | done    | done    | decimal1 | done
    any1     | any1     | any1     | exponent | done    | done    | decimal1 | done
    decimal1 | decimal2 | decimal2 | [error]  | [error] | [error] | [error]  | [error]
    decimal2 | decimal2 | decimal2 | exponent | done    | done    | done     | done
    exponent | any2     | any2     | [error]  | sign    | sign    | [error]  | [error]
    sign     | any2     | any2     | [error]  | [error] | [error] | [error]  | [error]
    any2     | any2     | any2     | done     | done    | done    | done     | done

    The state machine is realized with one label per state (prefixed with
    "scan_number_") and `goto` statements between them. The state machine
    contains cycles, but any cycle can be left when EOF is read. Therefore,
    the function is guaranteed to terminate.

    During scanning, the read bytes are stored in token_buffer. This string is
    then converted to a signed integer, an unsigned integer, or a
    floating-point number.

    @return token_type::value_unsigned, token_type::value_integer, or
            token_type::value_float if number could be successfully scanned,
            token_type::parse_error otherwise

    @note The scanner is independent of the current locale. Internally, the
          locale's decimal point is used instead of `.` to work with the
          locale-dependent converters.
    */
    token_type scan_number()  // lgtm [cpp/use-of-goto] `goto` is used in this function to implement the number-parsing state machine described above. By design, any finite input will eventually reach the "done" state or return token_type::parse_error. In each intermediate state, 1 byte of the input is appended to the token_buffer vector, and only the already initialized variables token_buffer, number_type, and error_message are manipulated.
    {
        // reset token_buffer to store the number's bytes
        reset();

        // the type of the parsed number; initially set to unsigned; will be
        // changed if minus sign, decimal point, or exponent is read
        token_type number_type = token_type::value_unsigned;

        // state (init): we just found out we need to scan a number
        switch (current)
        {
            case '-':
            {
                add(current);
                goto scan_number_minus;
            }

            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            // all other characters are rejected outside scan_number()
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

scan_number_minus:
        // state: we just parsed a leading minus sign
        number_type = token_type::value_integer;
        switch (get())
        {
            case '0':
            {
                add(current);
                goto scan_number_zero;
            }

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            default:
            {
                error_message = "invalid number; expected digit after '-'";
                return token_type::parse_error;
            }
        }

scan_number_zero:
        // state: we just parse a zero (maybe with a leading minus sign)
        switch (get())
        {
            case '.':
            {
                add(decimal_point_char);
                decimal_point_position = token_buffer.size() - 1;
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_any1:
        // state: we just parsed a number 0-9 (maybe with a leading minus sign)
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any1;
            }

            case '.':
            {
                add(decimal_point_char);
                decimal_point_position = token_buffer.size() - 1;
                goto scan_number_decimal1;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_decimal1:
        // state: we just parsed a decimal point
        number_type = token_type::value_float;
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            default:
            {
                error_message = "invalid number; expected digit after '.'";
                return token_type::parse_error;
            }
        }

scan_number_decimal2:
        // we just parsed at least one number after a decimal point
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_decimal2;
            }

            case 'e':
            case 'E':
            {
                add(current);
                goto scan_number_exponent;
            }

            default:
                goto scan_number_done;
        }

scan_number_exponent:
        // we just parsed an exponent
        number_type = token_type::value_float;
        switch (get())
        {
            case '+':
            case '-':
            {
                add(current);
                goto scan_number_sign;
            }

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message =
                    "invalid number; expected '+', '-', or digit after exponent";
                return token_type::parse_error;
            }
        }

scan_number_sign:
        // we just parsed an exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
            {
                error_message = "invalid number; expected digit after exponent sign";
                return token_type::parse_error;
            }
        }

scan_number_any2:
        // we just parsed a number after the exponent or exponent sign
        switch (get())
        {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            {
                add(current);
                goto scan_number_any2;
            }

            default:
                goto scan_number_done;
        }

scan_number_done:
        // unget the character after the number (we only read it to know that
        // we are done scanning a number)
        unget();

        char* endptr = nullptr; // NOLINT(misc-const-correctness,cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        errno = 0;

        // try to parse integers first and fall back to floats
        if (number_type == token_type::value_unsigned)
        {
            const auto x = std::strtoull(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno != ERANGE)
            {
                value_unsigned = static_cast<number_unsigned_t>(x);
                if (value_unsigned == x)
                {
                    return token_type::value_unsigned;
                }
            }
        }
        else if (number_type == token_type::value_integer)
        {
            const auto x = std::strtoll(token_buffer.data(), &endptr, 10);

            // we checked the number format before
            JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

            if (errno != ERANGE)
            {
                value_integer = static_cast<number_integer_t>(x);
                if (value_integer == x)
                {
                    return token_type::value_integer;
                }
            }
        }

        // this code is reached if we parse a floating-point number or if an
        // integer conversion above failed
        strtof(value_float, token_buffer.data(), &endptr);

        // we checked the number format before
        JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());

        return token_type::value_float;
    }

    /*!
    @param[in] literal_text  the literal text to expect
    @param[in] length        the length of the passed literal text
    @param[in] return_type   the token type to return on success
    */
    JSON_HEDLEY_NON_NULL(2)
    token_type scan_literal(const char_type* literal_text, const std::size_t length,
                            token_type return_type)
    {
        JSON_ASSERT(char_traits<char_type>::to_char_type(current) == literal_text[0]);
        for (std::size_t i = 1; i < length; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(char_traits<char_type>::to_char_type(get()) != literal_text[i]))
            {
                error_message = "invalid literal";
                return token_type::parse_error;
            }
        }
        return return_type;
    }

    /////////////////////
    // input management
    /////////////////////

    /// reset token_buffer; current character is beginning of token
    void reset() noexcept
    {
        token_buffer.clear();
        token_string.clear();
        decimal_point_position = std::string::npos;
        token_string.push_back(char_traits<char_type>::to_char_type(current));
    }

    /*
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a
    `char_traits<char>::eof()` in that case.  Stores the scanned characters
    for use in error messages.

    @return character read from the input
    */
    char_int_type get()
    {
        ++position.chars_read_total;
        ++position.chars_read_current_line;

        if (next_unget)
        {
            // only reset the next_unget variable and work with current
            next_unget = false;
        }
        else
        {
            current = ia.get_character();
        }

        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
        {
            token_string.push_back(char_traits<char_type>::to_char_type(current));
        }

        if (current == '\n')
        {
            ++position.lines_read;
            position.chars_read_current_line = 0;
        }

        return current;
    }

    /*!
    @brief unget current character (read it again on next get)

    We implement unget by setting variable next_unget to true. The input is not
    changed - we just simulate ungetting by modifying chars_read_total,
    chars_read_current_line, and token_string. The next call to get() will
    behave as if the unget character is read again.
    */
    void unget()
    {
        next_unget = true;

        --position.chars_read_total;

        // in case we "unget" a newline, we have to also decrement the lines_read
        if (position.chars_read_current_line == 0)
        {
            if (position.lines_read > 0)
            {
                --position.lines_read;
            }
        }
        else
        {
            --position.chars_read_current_line;
        }

        if (JSON_HEDLEY_LIKELY(current != char_traits<char_type>::eof()))
        {
            JSON_ASSERT(!token_string.empty());
            token_string.pop_back();
        }
    }

    /// add a character to token_buffer
    void add(char_int_type c)
    {
        token_buffer.push_back(static_cast<typename string_t::value_type>(c));
    }

  public:
    /////////////////////
    // value getters
    /////////////////////

    /// return integer value
    constexpr number_integer_t get_number_integer() const noexcept
    {
        return value_integer;
    }

    /// return unsigned integer value
    constexpr number_unsigned_t get_number_unsigned() const noexcept
    {
        return value_unsigned;
    }

    /// return floating-point value
    constexpr number_float_t get_number_float() const noexcept
    {
        return value_float;
    }

    /// return current string value (implicitly resets the token; useful only once)
    string_t& get_string()
    {
        // translate decimal points from locale back to '.' (#4084)
        if (decimal_point_char != '.' && decimal_point_position != std::string::npos)
        {
            token_buffer[decimal_point_position] = '.';
        }
        return token_buffer;
    }

    /////////////////////
    // diagnostics
    /////////////////////

    /// return position of last read token
    constexpr position_t get_position() const noexcept
    {
        return position;
    }

    /// return the last read token (for errors only).  Will never contain EOF
    /// (an arbitrary value that is not a valid char value, often -1), because
    /// 255 may legitimately occur.  May contain NUL, which should be escaped.
    std::string get_token_string() const
    {
        // escape control characters
        std::string result;
        for (const auto c : token_string)
        {
            if (static_cast<unsigned char>(c) <= '\x1F')
            {
                // escape control characters
                std::array<char, 9> cs{{}};
                static_cast<void>((std::snprintf)(cs.data(), cs.size(), "<U+%.4X>", static_cast<unsigned char>(c))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                result += cs.data();
            }
            else
            {
                // add character as is
                result.push_back(static_cast<std::string::value_type>(c));
            }
        }

        return result;
    }

    /// return syntax error message
    JSON_HEDLEY_RETURNS_NON_NULL
    constexpr const char* get_error_message() const noexcept
    {
        return error_message;
    }

    /////////////////////
    // actual scanner
    /////////////////////

    /*!
    @brief skip the UTF-8 byte order mark
    @return true iff there is no BOM or the correct BOM has been skipped
    */
    bool skip_bom()
    {
        if (get() == 0xEF)
        {
            // check if we completely parse the BOM
            return get() == 0xBB && get() == 0xBF;
        }

        // the first character is not the beginning of the BOM; unget it to
        // process is later
        unget();
        return true;
    }

    void skip_whitespace()
    {
        do
        {
            get();
        }
        while (current == ' ' || current == '\t' || current == '\n' || current == '\r');
    }

    token_type scan()
    {
        // initially, skip the BOM
        if (position.chars_read_total == 0 && !skip_bom())
        {
            error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
            return token_type::parse_error;
        }

        // read the next character and ignore whitespace
        skip_whitespace();

        // ignore comments
        while (ignore_comments && current == '/')
        {
            if (!scan_comment())
            {
                return token_type::parse_error;
            }

            // skip following whitespace
            skip_whitespace();
        }

        switch (current)
        {
            // structural characters
            case '[':
                return token_type::begin_array;
            case ']':
                return token_type::end_array;
            case '{':
                return token_type::begin_object;
            case '}':
                return token_type::end_object;
            case ':':
                return token_type::name_separator;
            case ',':
                return token_type::value_separator;

            // literals
            case 't':
            {
                std::array<char_type, 4> true_literal = {{static_cast<char_type>('t'), static_cast<char_type>('r'), static_cast<char_type>('u'), static_cast<char_type>('e')}};
                return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
            }
            case 'f':
            {
                std::array<char_type, 5> false_literal = {{static_cast<char_type>('f'), static_cast<char_type>('a'), static_cast<char_type>('l'), static_cast<char_type>('s'), static_cast<char_type>('e')}};
                return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
            }
            case 'n':
            {
                std::array<char_type, 4> null_literal = {{static_cast<char_type>('n'), static_cast<char_type>('u'), static_cast<char_type>('l'), static_cast<char_type>('l')}};
                return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
            }

            // string
            case '\"':
                return scan_string();

            // number
            case '-':
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                return scan_number();

            // end of input (the null byte is needed when parsing from
            // string literals)
            case '\0':
            case char_traits<char_type>::eof():
                return token_type::end_of_input;

            // error
            default:
                error_message = "invalid literal";
                return token_type::parse_error;
        }
    }

  private:
    /// input adapter
    InputAdapterType ia;

    /// whether comments should be ignored (true) or signaled as errors (false)
    const bool ignore_comments = false;

    /// the current character
    char_int_type current = char_traits<char_type>::eof();

    /// whether the next get() call should just return current
    bool next_unget = false;

    /// the start position of the current token
    position_t position {};

    /// raw input token string (for error messages)
    std::vector<char_type> token_string {};

    /// buffer for variable-length tokens (numbers, strings)
    string_t token_buffer {};

    /// a description of occurred lexer errors
    const char* error_message = "";

    // number values
    number_integer_t value_integer = 0;
    number_unsigned_t value_unsigned = 0;
    number_float_t value_float = 0;

    /// the decimal point
    const char_int_type decimal_point_char = '.';
    /// the position of the decimal point in the input
    std::size_t decimal_point_position = std::string::npos;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief SAX interface

This class describes the SAX interface used by @ref nlohmann::json::sax_parse.
Each function is called in different situations while the input is parsed. The
boolean return value informs the parser whether to continue processing the
input.
*/
template<typename BasicJsonType>
struct json_sax
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    /*!
    @brief a null value was read
    @return whether parsing should proceed
    */
    virtual bool null() = 0;

    /*!
    @brief a boolean value was read
    @param[in] val  boolean value
    @return whether parsing should proceed
    */
    virtual bool boolean(bool val) = 0;

    /*!
    @brief an integer number was read
    @param[in] val  integer value
    @return whether parsing should proceed
    */
    virtual bool number_integer(number_integer_t val) = 0;

    /*!
    @brief an unsigned integer number was read
    @param[in] val  unsigned integer value
    @return whether parsing should proceed
    */
    virtual bool number_unsigned(number_unsigned_t val) = 0;

    /*!
    @brief a floating-point number was read
    @param[in] val  floating-point value
    @param[in] s    raw token value
    @return whether parsing should proceed
    */
    virtual bool number_float(number_float_t val, const string_t& s) = 0;

    /*!
    @brief a string value was read
    @param[in] val  string value
    @return whether parsing should proceed
    @note It is safe to move the passed string value.
    */
    virtual bool string(string_t& val) = 0;

    /*!
    @brief a binary value was read
    @param[in] val  binary value
    @return whether parsing should proceed
    @note It is safe to move the passed binary value.
    */
    virtual bool binary(binary_t& val) = 0;

    /*!
    @brief the beginning of an object was read
    @param[in] elements  number of object elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_object(std::size_t elements) = 0;

    /*!
    @brief an object key was read
    @param[in] val  object key
    @return whether parsing should proceed
    @note It is safe to move the passed string.
    */
    virtual bool key(string_t& val) = 0;

    /*!
    @brief the end of an object was read
    @return whether parsing should proceed
    */
    virtual bool end_object() = 0;

    /*!
    @brief the beginning of an array was read
    @param[in] elements  number of array elements or -1 if unknown
    @return whether parsing should proceed
    @note binary formats may report the number of elements
    */
    virtual bool start_array(std::size_t elements) = 0;

    /*!
    @brief the end of an array was read
    @return whether parsing should proceed
    */
    virtual bool end_array() = 0;

    /*!
    @brief a parse error occurred
    @param[in] position    the position in the input where the error occurs
    @param[in] last_token  the last read token
    @param[in] ex          an exception object describing the error
    @return whether parsing should proceed (must return false)
    */
    virtual bool parse_error(std::size_t position,
                             const std::string& last_token,
                             const detail::exception& ex) = 0;

    json_sax() = default;
    json_sax(const json_sax&) = default;
    json_sax(json_sax&&) noexcept = default;
    json_sax& operator=(const json_sax&) = default;
    json_sax& operator=(json_sax&&) noexcept = default;
    virtual ~json_sax() = default;
};

namespace detail
{
constexpr std::size_t unknown_size()
{
    return (std::numeric_limits<std::size_t>::max)();
}

/*!
@brief SAX implementation to create a JSON value from SAX events

This class implements the @ref json_sax interface and processes the SAX events
to create a JSON value which makes it basically a DOM parser. The structure or
hierarchy of the JSON value is managed by the stack `ref_stack` which contains
a pointer to the respective array or object for each recursion depth.

After successful parsing, the value that is passed by reference to the
constructor contains the parsed value.

@tparam BasicJsonType  the JSON type
*/
template<typename BasicJsonType, typename InputAdapterType>
class json_sax_dom_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;

    /*!
    @param[in,out] r  reference to a JSON value that is manipulated while
                       parsing
    @param[in] allow_exceptions_  whether parse errors yield exceptions
    */
    explicit json_sax_dom_parser(BasicJsonType& r, const bool allow_exceptions_ = true, lexer_t* lexer_ = nullptr)
        : root(r), allow_exceptions(allow_exceptions_), m_lexer_ref(lexer_)
    {}

    // make class move-only
    json_sax_dom_parser(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_parser& operator=(const json_sax_dom_parser&) = delete;
    json_sax_dom_parser& operator=(json_sax_dom_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::object));

#if JSON_DIAGNOSTIC_POSITIONS
        // Manually set the start position of the object here.
        // Ensure this is after the call to handle_value to ensure correct start position.
        if (m_lexer_ref)
        {
            // Lexer has read the first character of the object, so
            // subtract 1 from the position to get the correct start position.
            ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
        }
#endif

        if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool key(string_t& val)
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

        // add null at the given key and store the reference for later
        object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val));
        return true;
    }

    bool end_object()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_object());

#if JSON_DIAGNOSTIC_POSITIONS
        if (m_lexer_ref)
        {
            // Lexer's position is past the closing brace, so set that as the end position.
            ref_stack.back()->end_position = m_lexer_ref->get_position();
        }
#endif

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    bool start_array(std::size_t len)
    {
        ref_stack.push_back(handle_value(BasicJsonType::value_t::array));

#if JSON_DIAGNOSTIC_POSITIONS
        // Manually set the start position of the array here.
        // Ensure this is after the call to handle_value to ensure correct start position.
        if (m_lexer_ref)
        {
            ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
        }
#endif

        if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
        {
            JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
        }

        return true;
    }

    bool end_array()
    {
        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(ref_stack.back()->is_array());

#if JSON_DIAGNOSTIC_POSITIONS
        if (m_lexer_ref)
        {
            // Lexer's position is past the closing bracket, so set that as the end position.
            ref_stack.back()->end_position = m_lexer_ref->get_position();
        }
#endif

        ref_stack.back()->set_parents();
        ref_stack.pop_back();
        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:

#if JSON_DIAGNOSTIC_POSITIONS
    void handle_diagnostic_positions_for_json_value(BasicJsonType& v)
    {
        if (m_lexer_ref)
        {
            // Lexer has read past the current field value, so set the end position to the current position.
            // The start position will be set below based on the length of the string representation
            // of the value.
            v.end_position = m_lexer_ref->get_position();

            switch (v.type())
            {
                case value_t::boolean:
                {
                    // 4 and 5 are the string length of "true" and "false"
                    v.start_position = v.end_position - (v.m_data.m_value.boolean ? 4 : 5);
                    break;
                }

                case value_t::null:
                {
                    // 4 is the string length of "null"
                    v.start_position = v.end_position - 4;
                    break;
                }

                case value_t::string:
                {
                    // include the length of the quotes, which is 2
                    v.start_position = v.end_position - v.m_data.m_value.string->size() - 2;
                    break;
                }

                // As we handle the start and end positions for values created during parsing,
                // we do not expect the following value type to be called. Regardless, set the positions
                // in case this is created manually or through a different constructor. Exclude from lcov
                // since the exact condition of this switch is esoteric.
                // LCOV_EXCL_START
                case value_t::discarded:
                {
                    v.end_position = std::string::npos;
                    v.start_position = v.end_position;
                    break;
                }
                // LCOV_EXCL_STOP
                case value_t::binary:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                {
                    v.start_position = v.end_position - m_lexer_ref->get_string().size();
                    break;
                }
                case value_t::object:
                case value_t::array:
                {
                    // object and array are handled in start_object() and start_array() handlers
                    // skip setting the values here.
                    break;
                }
                default: // LCOV_EXCL_LINE
                    // Handle all possible types discretely, default handler should never be reached.
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert,-warnings-as-errors) LCOV_EXCL_LINE
            }
        }
    }
#endif

    /*!
    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements
    */
    template<typename Value>
    JSON_HEDLEY_RETURNS_NON_NULL
    BasicJsonType* handle_value(Value&& v)
    {
        if (ref_stack.empty())
        {
            root = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
            handle_diagnostic_positions_for_json_value(root);
#endif

            return &root;
        }

        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
            handle_diagnostic_positions_for_json_value(ref_stack.back()->m_data.m_value.array->back());
#endif

            return &(ref_stack.back()->m_data.m_value.array->back());
        }

        JSON_ASSERT(ref_stack.back()->is_object());
        JSON_ASSERT(object_element);
        *object_element = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
        handle_diagnostic_positions_for_json_value(*object_element);
#endif

        return object_element;
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// the lexer reference to obtain the current position
    lexer_t* m_lexer_ref = nullptr;
};

template<typename BasicJsonType, typename InputAdapterType>
class json_sax_dom_callback_parser
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using parser_callback_t = typename BasicJsonType::parser_callback_t;
    using parse_event_t = typename BasicJsonType::parse_event_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;

    json_sax_dom_callback_parser(BasicJsonType& r,
                                 parser_callback_t cb,
                                 const bool allow_exceptions_ = true,
                                 lexer_t* lexer_ = nullptr)
        : root(r), callback(std::move(cb)), allow_exceptions(allow_exceptions_), m_lexer_ref(lexer_)
    {
        keep_stack.push_back(true);
    }

    // make class move-only
    json_sax_dom_callback_parser(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    json_sax_dom_callback_parser& operator=(const json_sax_dom_callback_parser&) = delete;
    json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~json_sax_dom_callback_parser() = default;

    bool null()
    {
        handle_value(nullptr);
        return true;
    }

    bool boolean(bool val)
    {
        handle_value(val);
        return true;
    }

    bool number_integer(number_integer_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_unsigned(number_unsigned_t val)
    {
        handle_value(val);
        return true;
    }

    bool number_float(number_float_t val, const string_t& /*unused*/)
    {
        handle_value(val);
        return true;
    }

    bool string(string_t& val)
    {
        handle_value(val);
        return true;
    }

    bool binary(binary_t& val)
    {
        handle_value(std::move(val));
        return true;
    }

    bool start_object(std::size_t len)
    {
        // check callback for object start
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::object_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::object, true);
        ref_stack.push_back(val.second);

        if (ref_stack.back())
        {

#if JSON_DIAGNOSTIC_POSITIONS
            // Manually set the start position of the object here.
            // Ensure this is after the call to handle_value to ensure correct start position.
            if (m_lexer_ref)
            {
                // Lexer has read the first character of the object, so
                // subtract 1 from the position to get the correct start position.
                ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
            }
#endif

            // check object limit
            if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
            {
                JSON_THROW(out_of_range::create(408, concat("excessive object size: ", std::to_string(len)), ref_stack.back()));
            }
        }
        return true;
    }

    bool key(string_t& val)
    {
        BasicJsonType k = BasicJsonType(val);

        // check callback for the key
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::key, k);
        key_keep_stack.push_back(keep);

        // add discarded value at the given key and store the reference for later
        if (keep && ref_stack.back())
        {
            object_element = &(ref_stack.back()->m_data.m_value.object->operator[](val) = discarded);
        }

        return true;
    }

    bool end_object()
    {
        if (ref_stack.back())
        {
            if (!callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))
            {
                // discard object
                *ref_stack.back() = discarded;

#if JSON_DIAGNOSTIC_POSITIONS
                // Set start/end positions for discarded object.
                handle_diagnostic_positions_for_json_value(*ref_stack.back());
#endif
            }
            else
            {

#if JSON_DIAGNOSTIC_POSITIONS
                if (m_lexer_ref)
                {
                    // Lexer's position is past the closing brace, so set that as the end position.
                    ref_stack.back()->end_position = m_lexer_ref->get_position();
                }
#endif

                ref_stack.back()->set_parents();
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        if (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())
        {
            // remove discarded value
            for (auto it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)
            {
                if (it->is_discarded())
                {
                    ref_stack.back()->erase(it);
                    break;
                }
            }
        }

        return true;
    }

    bool start_array(std::size_t len)
    {
        const bool keep = callback(static_cast<int>(ref_stack.size()), parse_event_t::array_start, discarded);
        keep_stack.push_back(keep);

        auto val = handle_value(BasicJsonType::value_t::array, true);
        ref_stack.push_back(val.second);

        if (ref_stack.back())
        {

#if JSON_DIAGNOSTIC_POSITIONS
            // Manually set the start position of the array here.
            // Ensure this is after the call to handle_value to ensure correct start position.
            if (m_lexer_ref)
            {
                // Lexer has read the first character of the array, so
                // subtract 1 from the position to get the correct start position.
                ref_stack.back()->start_position = m_lexer_ref->get_position() - 1;
            }
#endif

            // check array limit
            if (JSON_HEDLEY_UNLIKELY(len != detail::unknown_size() && len > ref_stack.back()->max_size()))
            {
                JSON_THROW(out_of_range::create(408, concat("excessive array size: ", std::to_string(len)), ref_stack.back()));
            }
        }

        return true;
    }

    bool end_array()
    {
        bool keep = true;

        if (ref_stack.back())
        {
            keep = callback(static_cast<int>(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());
            if (keep)
            {

#if JSON_DIAGNOSTIC_POSITIONS
                if (m_lexer_ref)
                {
                    // Lexer's position is past the closing bracket, so set that as the end position.
                    ref_stack.back()->end_position = m_lexer_ref->get_position();
                }
#endif

                ref_stack.back()->set_parents();
            }
            else
            {
                // discard array
                *ref_stack.back() = discarded;

#if JSON_DIAGNOSTIC_POSITIONS
                // Set start/end positions for discarded array.
                handle_diagnostic_positions_for_json_value(*ref_stack.back());
#endif
            }
        }

        JSON_ASSERT(!ref_stack.empty());
        JSON_ASSERT(!keep_stack.empty());
        ref_stack.pop_back();
        keep_stack.pop_back();

        // remove discarded value
        if (!keep && !ref_stack.empty() && ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->pop_back();
        }

        return true;
    }

    template<class Exception>
    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/,
                     const Exception& ex)
    {
        errored = true;
        static_cast<void>(ex);
        if (allow_exceptions)
        {
            JSON_THROW(ex);
        }
        return false;
    }

    constexpr bool is_errored() const
    {
        return errored;
    }

  private:

#if JSON_DIAGNOSTIC_POSITIONS
    void handle_diagnostic_positions_for_json_value(BasicJsonType& v)
    {
        if (m_lexer_ref)
        {
            // Lexer has read past the current field value, so set the end position to the current position.
            // The start position will be set below based on the length of the string representation
            // of the value.
            v.end_position = m_lexer_ref->get_position();

            switch (v.type())
            {
                case value_t::boolean:
                {
                    // 4 and 5 are the string length of "true" and "false"
                    v.start_position = v.end_position - (v.m_data.m_value.boolean ? 4 : 5);
                    break;
                }

                case value_t::null:
                {
                    // 4 is the string length of "null"
                    v.start_position = v.end_position - 4;
                    break;
                }

                case value_t::string:
                {
                    // include the length of the quotes, which is 2
                    v.start_position = v.end_position - v.m_data.m_value.string->size() - 2;
                    break;
                }

                case value_t::discarded:
                {
                    v.end_position = std::string::npos;
                    v.start_position = v.end_position;
                    break;
                }

                case value_t::binary:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                {
                    v.start_position = v.end_position - m_lexer_ref->get_string().size();
                    break;
                }

                case value_t::object:
                case value_t::array:
                {
                    // object and array are handled in start_object() and start_array() handlers
                    // skip setting the values here.
                    break;
                }
                default: // LCOV_EXCL_LINE
                    // Handle all possible types discretely, default handler should never be reached.
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert,-warnings-as-errors) LCOV_EXCL_LINE
            }
        }
    }
#endif

    /*!
    @param[in] v  value to add to the JSON value we build during parsing
    @param[in] skip_callback  whether we should skip calling the callback
               function; this is required after start_array() and
               start_object() SAX events, because otherwise we would call the
               callback function with an empty array or object, respectively.

    @invariant If the ref stack is empty, then the passed value will be the new
               root.
    @invariant If the ref stack contains a value, then it is an array or an
               object to which we can add elements

    @return pair of boolean (whether value should be kept) and pointer (to the
            passed value in the ref_stack hierarchy; nullptr if not kept)
    */
    template<typename Value>
    std::pair<bool, BasicJsonType*> handle_value(Value&& v, const bool skip_callback = false)
    {
        JSON_ASSERT(!keep_stack.empty());

        // do not handle this value if we know it would be added to a discarded
        // container
        if (!keep_stack.back())
        {
            return {false, nullptr};
        }

        // create value
        auto value = BasicJsonType(std::forward<Value>(v));

#if JSON_DIAGNOSTIC_POSITIONS
        handle_diagnostic_positions_for_json_value(value);
#endif

        // check callback
        const bool keep = skip_callback || callback(static_cast<int>(ref_stack.size()), parse_event_t::value, value);

        // do not handle this value if we just learnt it shall be discarded
        if (!keep)
        {
            return {false, nullptr};
        }

        if (ref_stack.empty())
        {
            root = std::move(value);
            return {true, & root};
        }

        // skip this value if we already decided to skip the parent
        // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)
        if (!ref_stack.back())
        {
            return {false, nullptr};
        }

        // we now only expect arrays and objects
        JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());

        // array
        if (ref_stack.back()->is_array())
        {
            ref_stack.back()->m_data.m_value.array->emplace_back(std::move(value));
            return {true, & (ref_stack.back()->m_data.m_value.array->back())};
        }

        // object
        JSON_ASSERT(ref_stack.back()->is_object());
        // check if we should store an element for the current key
        JSON_ASSERT(!key_keep_stack.empty());
        const bool store_element = key_keep_stack.back();
        key_keep_stack.pop_back();

        if (!store_element)
        {
            return {false, nullptr};
        }

        JSON_ASSERT(object_element);
        *object_element = std::move(value);
        return {true, object_element};
    }

    /// the parsed JSON value
    BasicJsonType& root;
    /// stack to model hierarchy of values
    std::vector<BasicJsonType*> ref_stack {};
    /// stack to manage which values to keep
    std::vector<bool> keep_stack {}; // NOLINT(readability-redundant-member-init)
    /// stack to manage which object keys to keep
    std::vector<bool> key_keep_stack {}; // NOLINT(readability-redundant-member-init)
    /// helper to hold the reference for the next object element
    BasicJsonType* object_element = nullptr;
    /// whether a syntax error occurred
    bool errored = false;
    /// callback function
    const parser_callback_t callback = nullptr;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// a discarded value for the callback
    BasicJsonType discarded = BasicJsonType::value_t::discarded;
    /// the lexer reference to obtain the current position
    lexer_t* m_lexer_ref = nullptr;
};

template<typename BasicJsonType>
class json_sax_acceptor
{
  public:
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;

    bool null()
    {
        return true;
    }

    bool boolean(bool /*unused*/)
    {
        return true;
    }

    bool number_integer(number_integer_t /*unused*/)
    {
        return true;
    }

    bool number_unsigned(number_unsigned_t /*unused*/)
    {
        return true;
    }

    bool number_float(number_float_t /*unused*/, const string_t& /*unused*/)
    {
        return true;
    }

    bool string(string_t& /*unused*/)
    {
        return true;
    }

    bool binary(binary_t& /*unused*/)
    {
        return true;
    }

    bool start_object(std::size_t /*unused*/ = detail::unknown_size())
    {
        return true;
    }

    bool key(string_t& /*unused*/)
    {
        return true;
    }

    bool end_object()
    {
        return true;
    }

    bool start_array(std::size_t /*unused*/ = detail::unknown_size())
    {
        return true;
    }

    bool end_array()
    {
        return true;
    }

    bool parse_error(std::size_t /*unused*/, const std::string& /*unused*/, const detail::exception& /*unused*/)
    {
        return false;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstdint> // size_t
#include <utility> // declval
#include <string> // string

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/detected.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename T>
using null_function_t = decltype(std::declval<T&>().null());

template<typename T>
using boolean_function_t =
    decltype(std::declval<T&>().boolean(std::declval<bool>()));

template<typename T, typename Integer>
using number_integer_function_t =
    decltype(std::declval<T&>().number_integer(std::declval<Integer>()));

template<typename T, typename Unsigned>
using number_unsigned_function_t =
    decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));

template<typename T, typename Float, typename String>
using number_float_function_t = decltype(std::declval<T&>().number_float(
                                    std::declval<Float>(), std::declval<const String&>()));

template<typename T, typename String>
using string_function_t =
    decltype(std::declval<T&>().string(std::declval<String&>()));

template<typename T, typename Binary>
using binary_function_t =
    decltype(std::declval<T&>().binary(std::declval<Binary&>()));

template<typename T>
using start_object_function_t =
    decltype(std::declval<T&>().start_object(std::declval<std::size_t>()));

template<typename T, typename String>
using key_function_t =
    decltype(std::declval<T&>().key(std::declval<String&>()));

template<typename T>
using end_object_function_t = decltype(std::declval<T&>().end_object());

template<typename T>
using start_array_function_t =
    decltype(std::declval<T&>().start_array(std::declval<std::size_t>()));

template<typename T>
using end_array_function_t = decltype(std::declval<T&>().end_array());

template<typename T, typename Exception>
using parse_error_function_t = decltype(std::declval<T&>().parse_error(
        std::declval<std::size_t>(), std::declval<const std::string&>(),
        std::declval<const Exception&>()));

template<typename SAX, typename BasicJsonType>
struct is_sax
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static constexpr bool value =
        is_detected_exact<bool, null_function_t, SAX>::value &&
        is_detected_exact<bool, boolean_function_t, SAX>::value &&
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&
        is_detected_exact<bool, start_object_function_t, SAX>::value &&
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&
        is_detected_exact<bool, end_object_function_t, SAX>::value &&
        is_detected_exact<bool, start_array_function_t, SAX>::value &&
        is_detected_exact<bool, end_array_function_t, SAX>::value &&
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;
};

template<typename SAX, typename BasicJsonType>
struct is_sax_static_asserts
{
  private:
    static_assert(is_basic_json<BasicJsonType>::value,
                  "BasicJsonType must be of type basic_json<...>");

    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using exception_t = typename BasicJsonType::exception;

  public:
    static_assert(is_detected_exact<bool, null_function_t, SAX>::value,
                  "Missing/invalid function: bool null()");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(is_detected_exact<bool, boolean_function_t, SAX>::value,
                  "Missing/invalid function: bool boolean(bool)");
    static_assert(
        is_detected_exact<bool, number_integer_function_t, SAX,
        number_integer_t>::value,
        "Missing/invalid function: bool number_integer(number_integer_t)");
    static_assert(
        is_detected_exact<bool, number_unsigned_function_t, SAX,
        number_unsigned_t>::value,
        "Missing/invalid function: bool number_unsigned(number_unsigned_t)");
    static_assert(is_detected_exact<bool, number_float_function_t, SAX,
                  number_float_t, string_t>::value,
                  "Missing/invalid function: bool number_float(number_float_t, const string_t&)");
    static_assert(
        is_detected_exact<bool, string_function_t, SAX, string_t>::value,
        "Missing/invalid function: bool string(string_t&)");
    static_assert(
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,
        "Missing/invalid function: bool binary(binary_t&)");
    static_assert(is_detected_exact<bool, start_object_function_t, SAX>::value,
                  "Missing/invalid function: bool start_object(std::size_t)");
    static_assert(is_detected_exact<bool, key_function_t, SAX, string_t>::value,
                  "Missing/invalid function: bool key(string_t&)");
    static_assert(is_detected_exact<bool, end_object_function_t, SAX>::value,
                  "Missing/invalid function: bool end_object()");
    static_assert(is_detected_exact<bool, start_array_function_t, SAX>::value,
                  "Missing/invalid function: bool start_array(std::size_t)");
    static_assert(is_detected_exact<bool, end_array_function_t, SAX>::value,
                  "Missing/invalid function: bool end_array()");
    static_assert(
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,
        "Missing/invalid function: bool parse_error(std::size_t, const "
        "std::string&, const exception&)");
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// how to treat CBOR tags
enum class cbor_tag_handler_t
{
    error,   ///< throw a parse_error exception in case of a tag
    ignore,  ///< ignore tags
    store    ///< store tags as binary type
};

/*!
@brief determine system byte order

@return true if and only if system's byte order is little endian

@note from https://stackoverflow.com/a/1001328/266378
*/
inline bool little_endianness(int num = 1) noexcept
{
    return *reinterpret_cast<char*>(&num) == 1;
}

///////////////////
// binary reader //
///////////////////

/*!
@brief deserialization of CBOR, MessagePack, and UBJSON values
*/
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType, InputAdapterType>>
class binary_reader
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using json_sax_t = SAX;
    using char_type = typename InputAdapterType::char_type;
    using char_int_type = typename char_traits<char_type>::int_type;

  public:
    /*!
    @brief create a binary reader

    @param[in] adapter  input adapter to read from
    */
    explicit binary_reader(InputAdapterType&& adapter, const input_format_t format = input_format_t::json) noexcept : ia(std::move(adapter)), input_format(format)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
    }

    // make class move-only
    binary_reader(const binary_reader&) = delete;
    binary_reader(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    binary_reader& operator=(const binary_reader&) = delete;
    binary_reader& operator=(binary_reader&&) = default; // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)
    ~binary_reader() = default;

    /*!
    @param[in] format  the binary format to parse
    @param[in] sax_    a SAX event processor
    @param[in] strict  whether to expect the input to be consumed completed
    @param[in] tag_handler  how to treat CBOR tags

    @return whether parsing was successful
    */
    JSON_HEDLEY_NON_NULL(3)
    bool sax_parse(const input_format_t format,
                   json_sax_t* sax_,
                   const bool strict = true,
                   const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        sax = sax_;
        bool result = false;

        switch (format)
        {
            case input_format_t::bson:
                result = parse_bson_internal();
                break;

            case input_format_t::cbor:
                result = parse_cbor_internal(true, tag_handler);
                break;

            case input_format_t::msgpack:
                result = parse_msgpack_internal();
                break;

            case input_format_t::ubjson:
            case input_format_t::bjdata:
                result = parse_ubjson_internal();
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        // strict mode: next byte must be EOF
        if (result && strict)
        {
            if (input_format == input_format_t::ubjson || input_format == input_format_t::bjdata)
            {
                get_ignore_noop();
            }
            else
            {
                get();
            }

            if (JSON_HEDLEY_UNLIKELY(current != char_traits<char_type>::eof()))
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(110, chars_read,
                                        exception_message(input_format, concat("expected end of input; last byte: 0x", get_token_string()), "value"), nullptr));
            }
        }

        return result;
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @brief Reads in a BSON-object and passes it to the SAX-parser.
    @return whether a valid BSON-value was passed to the SAX parser
    */
    bool parse_bson_internal()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/false)))
        {
            return false;
        }

        return sax->end_object();
    }

    /*!
    @brief Parses a C-style string from the BSON input.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @return `true` if the \x00-byte indicating the end of the string was
             encountered before the EOF; false` indicates an unexpected EOF.
    */
    bool get_bson_cstr(string_t& result)
    {
        auto out = std::back_inserter(result);
        while (true)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "cstring")))
            {
                return false;
            }
            if (current == 0x00)
            {
                return true;
            }
            *out++ = static_cast<typename string_t::value_type>(current);
        }
    }

    /*!
    @brief Parses a zero-terminated string of length @a len from the BSON
           input.
    @param[in] len  The length (including the zero-byte at the end) of the
                    string to be read.
    @param[in,out] result  A reference to the string variable where the read
                            string is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 1
    @return `true` if the string was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_string(const NumberType len, string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 1))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("string length must be at least 1, is ", std::to_string(len)), "string"), nullptr));
        }

        return get_string(input_format_t::bson, len - static_cast<NumberType>(1), result) && get() != char_traits<char_type>::eof();
    }

    /*!
    @brief Parses a byte array input of length @a len from the BSON input.
    @param[in] len  The length of the byte array to be read.
    @param[in,out] result  A reference to the binary variable where the read
                            array is to be stored.
    @tparam NumberType The type of the length @a len
    @pre len >= 0
    @return `true` if the byte array was successfully parsed
    */
    template<typename NumberType>
    bool get_bson_binary(const NumberType len, binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(len < 0))
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format_t::bson, concat("byte array length cannot be negative, is ", std::to_string(len)), "binary"), nullptr));
        }

        // All BSON binary values have a subtype
        std::uint8_t subtype{};
        get_number<std::uint8_t>(input_format_t::bson, subtype);
        result.set_subtype(subtype);

        return get_binary(input_format_t::bson, len, result);
    }

    /*!
    @brief Read a BSON document element of the given @a element_type.
    @param[in] element_type The BSON element type, c.f. http://bsonspec.org/spec.html
    @param[in] element_type_parse_position The position in the input stream,
               where the `element_type` was read.
    @warning Not all BSON element types are supported yet. An unsupported
             @a element_type will give rise to a parse_error.114:
             Unsupported BSON record type 0x...
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_internal(const char_int_type element_type,
                                     const std::size_t element_type_parse_position)
    {
        switch (element_type)
        {
            case 0x01: // double
            {
                double number{};
                return get_number<double, true>(input_format_t::bson, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0x02: // string
            {
                std::int32_t len{};
                string_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);
            }

            case 0x03: // object
            {
                return parse_bson_internal();
            }

            case 0x04: // array
            {
                return parse_bson_array();
            }

            case 0x05: // binary
            {
                std::int32_t len{};
                binary_t value;
                return get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);
            }

            case 0x08: // boolean
            {
                return sax->boolean(get() != 0);
            }

            case 0x0A: // null
            {
                return sax->null();
            }

            case 0x10: // int32
            {
                std::int32_t value{};
                return get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x12: // int64
            {
                std::int64_t value{};
                return get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);
            }

            case 0x11: // uint64
            {
                std::uint64_t value{};
                return get_number<std::uint64_t, true>(input_format_t::bson, value) && sax->number_unsigned(value);
            }

            default: // anything else is not supported (yet)
            {
                std::array<char, 3> cr{{}};
                static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(element_type))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                const std::string cr_str{cr.data()};
                return sax->parse_error(element_type_parse_position, cr_str,
                                        parse_error::create(114, element_type_parse_position, concat("Unsupported BSON record type 0x", cr_str), nullptr));
            }
        }
    }

    /*!
    @brief Read a BSON element list (as specified in the BSON-spec)

    The same binary layout is used for objects and arrays, hence it must be
    indicated with the argument @a is_array which one is expected
    (true --> array, false --> object).

    @param[in] is_array Determines if the element list being read is to be
                        treated as an object (@a is_array == false), or as an
                        array (@a is_array == true).
    @return whether a valid BSON-object/array was passed to the SAX parser
    */
    bool parse_bson_element_list(const bool is_array)
    {
        string_t key;

        while (auto element_type = get())
        {
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, "element list")))
            {
                return false;
            }

            const std::size_t element_type_parse_position = chars_read;
            if (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))
            {
                return false;
            }

            if (!is_array && !sax->key(key))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))
            {
                return false;
            }

            // get_bson_cstr only appends
            key.clear();
        }

        return true;
    }

    /*!
    @brief Reads an array from the BSON input and passes it to the SAX-parser.
    @return whether a valid BSON-array was passed to the SAX parser
    */
    bool parse_bson_array()
    {
        std::int32_t document_size{};
        get_number<std::int32_t, true>(input_format_t::bson, document_size);

        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
        {
            return false;
        }

        if (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list(/*is_array*/true)))
        {
            return false;
        }

        return sax->end_array();
    }

    //////////
    // CBOR //
    //////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true) or whether the last read character should
                         be considered instead (false)
    @param[in] tag_handler how CBOR tags should be treated

    @return whether a valid CBOR value was passed to the SAX parser
    */

    template<typename NumberType>
    bool get_cbor_negative_integer()
    {
        NumberType number{};
        if (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::cbor, number)))
        {
            return false;
        }
        const auto max_val = static_cast<NumberType>((std::numeric_limits<number_integer_t>::max)());
        if (number > max_val)
        {
            return sax->parse_error(chars_read, get_token_string(),
                                    parse_error::create(112, chars_read,
                                            exception_message(input_format_t::cbor, "negative integer overflow", "value"), nullptr));
        }
        return sax->number_integer(static_cast<number_integer_t>(-1) - static_cast<number_integer_t>(number));
    }

    bool parse_cbor_internal(const bool get_char,
                             const cbor_tag_handler_t tag_handler)
    {
        switch (get_char ? get() : current)
        {
            // EOF
            case char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::cbor, "value");

            // Integer 0x00..0x17 (0..23)
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            case 0x18: // Unsigned integer (one-byte uint8_t follows)
            {
                std::uint8_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x19: // Unsigned integer (two-byte uint16_t follows)
            {
                std::uint16_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1A: // Unsigned integer (four-byte uint32_t follows)
            {
                std::uint32_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            case 0x1B: // Unsigned integer (eight-byte uint64_t follows)
            {
                std::uint64_t number{};
                return get_number(input_format_t::cbor, number) && sax->number_unsigned(number);
            }

            // Negative integer -1-0x00..-1-0x17 (-1..-24)
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
                return sax->number_integer(static_cast<std::int8_t>(0x20 - 1 - current));

            case 0x38: // Negative integer (one-byte uint8_t follows)
                return get_cbor_negative_integer<std::uint8_t>();

            case 0x39: // Negative integer -1-n (two-byte uint16_t follows)
                return get_cbor_negative_integer<std::uint16_t>();

            case 0x3A: // Negative integer -1-n (four-byte uint32_t follows)
                return get_cbor_negative_integer<std::uint32_t>();

            case 0x3B: // Negative integer -1-n (eight-byte uint64_t follows)
                return get_cbor_negative_integer<std::uint64_t>();

            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58: // Binary data (one-byte uint8_t for n follows)
            case 0x59: // Binary data (two-byte uint16_t for n follow)
            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            case 0x5F: // Binary data (indefinite length)
            {
                binary_t b;
                return get_cbor_binary(b) && sax->binary(b);
            }

            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            case 0x7F: // UTF-8 string (indefinite length)
            {
                string_t s;
                return get_cbor_string(s) && sax->string(s);
            }

            // array (0x00..0x17 data items follow)
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
                return get_cbor_array(
                           conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0x98: // array (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x99: // array (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9A: // array (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9B: // array (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_array(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0x9F: // array (indefinite length)
                return get_cbor_array(detail::unknown_size(), tag_handler);

            // map (0x00..0x17 pairs of data items follow)
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
                return get_cbor_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x1Fu), tag_handler);

            case 0xB8: // map (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xB9: // map (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBA: // map (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBB: // map (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_cbor_object(conditional_static_cast<std::size_t>(len), tag_handler);
            }

            case 0xBF: // map (indefinite length)
                return get_cbor_object(detail::unknown_size(), tag_handler);

            case 0xC6: // tagged item
            case 0xC7:
            case 0xC8:
            case 0xC9:
            case 0xCA:
            case 0xCB:
            case 0xCC:
            case 0xCD:
            case 0xCE:
            case 0xCF:
            case 0xD0:
            case 0xD1:
            case 0xD2:
            case 0xD3:
            case 0xD4:
            case 0xD8: // tagged item (1 byte follows)
            case 0xD9: // tagged item (2 bytes follow)
            case 0xDA: // tagged item (4 bytes follow)
            case 0xDB: // tagged item (8 bytes follow)
            {
                switch (tag_handler)
                {
                    case cbor_tag_handler_t::error:
                    {
                        auto last_token = get_token_string();
                        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                                exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
                    }

                    case cbor_tag_handler_t::ignore:
                    {
                        // ignore binary subtype
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype_to_ignore{};
                                get_number(input_format_t::cbor, subtype_to_ignore);
                                break;
                            }
                            default:
                                break;
                        }
                        return parse_cbor_internal(true, tag_handler);
                    }

                    case cbor_tag_handler_t::store:
                    {
                        binary_t b;
                        // use binary subtype and store in a binary container
                        switch (current)
                        {
                            case 0xD8:
                            {
                                std::uint8_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xD9:
                            {
                                std::uint16_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDA:
                            {
                                std::uint32_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            case 0xDB:
                            {
                                std::uint64_t subtype{};
                                get_number(input_format_t::cbor, subtype);
                                b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));
                                break;
                            }
                            default:
                                return parse_cbor_internal(true, tag_handler);
                        }
                        get();
                        return get_cbor_binary(b) && sax->binary(b);
                    }

                    default:                 // LCOV_EXCL_LINE
                        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                        return false;        // LCOV_EXCL_LINE
                }
            }

            case 0xF4: // false
                return sax->boolean(false);

            case 0xF5: // true
                return sax->boolean(true);

            case 0xF6: // null
                return sax->null();

            case 0xF9: // Half-Precision Float (two-byte IEEE 754)
            {
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // Code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte1 << 8u) + byte2);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 0xFA: // Single-Precision Float (four-byte IEEE 754)
            {
                float number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xFB: // Double-Precision Float (eight-byte IEEE 754)
            {
                double number{};
                return get_number(input_format_t::cbor, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            default: // anything else (0xFF is handled inside the other types)
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::cbor, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.
    Additionally, CBOR's strings with indefinite lengths are supported.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_cbor_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "string")))
        {
            return false;
        }

        switch (current)
        {
            // UTF-8 string (0x00..0x17 bytes follow)
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            {
                return get_string(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x78: // UTF-8 string (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x79: // UTF-8 string (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7A: // UTF-8 string (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7B: // UTF-8 string (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);
            }

            case 0x7F: // UTF-8 string (indefinite length)
            {
                while (get() != 0xFF)
                {
                    string_t chunk;
                    if (!get_cbor_string(chunk))
                    {
                        return false;
                    }
                    result.append(chunk);
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a CBOR byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into the byte array.
    Additionally, CBOR's byte arrays with indefinite lengths are supported.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_cbor_binary(binary_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, "binary")))
        {
            return false;
        }

        switch (current)
        {
            // Binary data (0x00..0x17 bytes follow)
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            {
                return get_binary(input_format_t::cbor, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0x58: // Binary data (one-byte uint8_t for n follows)
            {
                std::uint8_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x59: // Binary data (two-byte uint16_t for n follow)
            {
                std::uint16_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5A: // Binary data (four-byte uint32_t for n follow)
            {
                std::uint32_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5B: // Binary data (eight-byte uint64_t for n follow)
            {
                std::uint64_t len{};
                return get_number(input_format_t::cbor, len) &&
                       get_binary(input_format_t::cbor, len, result);
            }

            case 0x5F: // Binary data (indefinite length)
            {
                while (get() != 0xFF)
                {
                    binary_t chunk;
                    if (!get_cbor_binary(chunk))
                    {
                        return false;
                    }
                    result.insert(result.end(), chunk.begin(), chunk.end());
                }
                return true;
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::cbor, concat("expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x", last_token), "binary"), nullptr));
            }
        }
    }

    /*!
    @param[in] len  the length of the array or detail::unknown_size() for an
                    array of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether array creation completed
    */
    bool get_cbor_array(const std::size_t len,
                        const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        if (len != detail::unknown_size())
        {
            for (std::size_t i = 0; i < len; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                {
                    return false;
                }
            }
        }
        else
        {
            while (get() != 0xFF)
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(false, tag_handler)))
                {
                    return false;
                }
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object or detail::unknown_size() for an
                    object of indefinite size
    @param[in] tag_handler how CBOR tags should be treated
    @return whether object creation completed
    */
    bool get_cbor_object(const std::size_t len,
                         const cbor_tag_handler_t tag_handler)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        if (len != 0)
        {
            string_t key;
            if (len != detail::unknown_size())
            {
                for (std::size_t i = 0; i < len; ++i)
                {
                    get();
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                while (get() != 0xFF)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))
                    {
                        return false;
                    }

                    if (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal(true, tag_handler)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }

        return sax->end_object();
    }

    /////////////
    // MsgPack //
    /////////////

    /*!
    @return whether a valid MessagePack value was passed to the SAX parser
    */
    bool parse_msgpack_internal()
    {
        switch (get())
        {
            // EOF
            case char_traits<char_type>::eof():
                return unexpect_eof(input_format_t::msgpack, "value");

            // positive fixint
            case 0x00:
            case 0x01:
            case 0x02:
            case 0x03:
            case 0x04:
            case 0x05:
            case 0x06:
            case 0x07:
            case 0x08:
            case 0x09:
            case 0x0A:
            case 0x0B:
            case 0x0C:
            case 0x0D:
            case 0x0E:
            case 0x0F:
            case 0x10:
            case 0x11:
            case 0x12:
            case 0x13:
            case 0x14:
            case 0x15:
            case 0x16:
            case 0x17:
            case 0x18:
            case 0x19:
            case 0x1A:
            case 0x1B:
            case 0x1C:
            case 0x1D:
            case 0x1E:
            case 0x1F:
            case 0x20:
            case 0x21:
            case 0x22:
            case 0x23:
            case 0x24:
            case 0x25:
            case 0x26:
            case 0x27:
            case 0x28:
            case 0x29:
            case 0x2A:
            case 0x2B:
            case 0x2C:
            case 0x2D:
            case 0x2E:
            case 0x2F:
            case 0x30:
            case 0x31:
            case 0x32:
            case 0x33:
            case 0x34:
            case 0x35:
            case 0x36:
            case 0x37:
            case 0x38:
            case 0x39:
            case 0x3A:
            case 0x3B:
            case 0x3C:
            case 0x3D:
            case 0x3E:
            case 0x3F:
            case 0x40:
            case 0x41:
            case 0x42:
            case 0x43:
            case 0x44:
            case 0x45:
            case 0x46:
            case 0x47:
            case 0x48:
            case 0x49:
            case 0x4A:
            case 0x4B:
            case 0x4C:
            case 0x4D:
            case 0x4E:
            case 0x4F:
            case 0x50:
            case 0x51:
            case 0x52:
            case 0x53:
            case 0x54:
            case 0x55:
            case 0x56:
            case 0x57:
            case 0x58:
            case 0x59:
            case 0x5A:
            case 0x5B:
            case 0x5C:
            case 0x5D:
            case 0x5E:
            case 0x5F:
            case 0x60:
            case 0x61:
            case 0x62:
            case 0x63:
            case 0x64:
            case 0x65:
            case 0x66:
            case 0x67:
            case 0x68:
            case 0x69:
            case 0x6A:
            case 0x6B:
            case 0x6C:
            case 0x6D:
            case 0x6E:
            case 0x6F:
            case 0x70:
            case 0x71:
            case 0x72:
            case 0x73:
            case 0x74:
            case 0x75:
            case 0x76:
            case 0x77:
            case 0x78:
            case 0x79:
            case 0x7A:
            case 0x7B:
            case 0x7C:
            case 0x7D:
            case 0x7E:
            case 0x7F:
                return sax->number_unsigned(static_cast<number_unsigned_t>(current));

            // fixmap
            case 0x80:
            case 0x81:
            case 0x82:
            case 0x83:
            case 0x84:
            case 0x85:
            case 0x86:
            case 0x87:
            case 0x88:
            case 0x89:
            case 0x8A:
            case 0x8B:
            case 0x8C:
            case 0x8D:
            case 0x8E:
            case 0x8F:
                return get_msgpack_object(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixarray
            case 0x90:
            case 0x91:
            case 0x92:
            case 0x93:
            case 0x94:
            case 0x95:
            case 0x96:
            case 0x97:
            case 0x98:
            case 0x99:
            case 0x9A:
            case 0x9B:
            case 0x9C:
            case 0x9D:
            case 0x9E:
            case 0x9F:
                return get_msgpack_array(conditional_static_cast<std::size_t>(static_cast<unsigned int>(current) & 0x0Fu));

            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            case 0xD9: // str 8
            case 0xDA: // str 16
            case 0xDB: // str 32
            {
                string_t s;
                return get_msgpack_string(s) && sax->string(s);
            }

            case 0xC0: // nil
                return sax->null();

            case 0xC2: // false
                return sax->boolean(false);

            case 0xC3: // true
                return sax->boolean(true);

            case 0xC4: // bin 8
            case 0xC5: // bin 16
            case 0xC6: // bin 32
            case 0xC7: // ext 8
            case 0xC8: // ext 16
            case 0xC9: // ext 32
            case 0xD4: // fixext 1
            case 0xD5: // fixext 2
            case 0xD6: // fixext 4
            case 0xD7: // fixext 8
            case 0xD8: // fixext 16
            {
                binary_t b;
                return get_msgpack_binary(b) && sax->binary(b);
            }

            case 0xCA: // float 32
            {
                float number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCB: // float 64
            {
                double number{};
                return get_number(input_format_t::msgpack, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 0xCC: // uint 8
            {
                std::uint8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCD: // uint 16
            {
                std::uint16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCE: // uint 32
            {
                std::uint32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xCF: // uint 64
            {
                std::uint64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);
            }

            case 0xD0: // int 8
            {
                std::int8_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD1: // int 16
            {
                std::int16_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD2: // int 32
            {
                std::int32_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xD3: // int 64
            {
                std::int64_t number{};
                return get_number(input_format_t::msgpack, number) && sax->number_integer(number);
            }

            case 0xDC: // array 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(static_cast<std::size_t>(len));
            }

            case 0xDD: // array 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_array(conditional_static_cast<std::size_t>(len));
            }

            case 0xDE: // map 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(static_cast<std::size_t>(len));
            }

            case 0xDF: // map 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_msgpack_object(conditional_static_cast<std::size_t>(len));
            }

            // negative fixint
            case 0xE0:
            case 0xE1:
            case 0xE2:
            case 0xE3:
            case 0xE4:
            case 0xE5:
            case 0xE6:
            case 0xE7:
            case 0xE8:
            case 0xE9:
            case 0xEA:
            case 0xEB:
            case 0xEC:
            case 0xED:
            case 0xEE:
            case 0xEF:
            case 0xF0:
            case 0xF1:
            case 0xF2:
            case 0xF3:
            case 0xF4:
            case 0xF5:
            case 0xF6:
            case 0xF7:
            case 0xF8:
            case 0xF9:
            case 0xFA:
            case 0xFB:
            case 0xFC:
            case 0xFD:
            case 0xFE:
            case 0xFF:
                return sax->number_integer(static_cast<std::int8_t>(current));

            default: // anything else
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format_t::msgpack, concat("invalid byte: 0x", last_token), "value"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack string

    This function first reads starting bytes to determine the expected
    string length and then copies this number of bytes into a string.

    @param[out] result  created string

    @return whether string creation completed
    */
    bool get_msgpack_string(string_t& result)
    {
        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, "string")))
        {
            return false;
        }

        switch (current)
        {
            // fixstr
            case 0xA0:
            case 0xA1:
            case 0xA2:
            case 0xA3:
            case 0xA4:
            case 0xA5:
            case 0xA6:
            case 0xA7:
            case 0xA8:
            case 0xA9:
            case 0xAA:
            case 0xAB:
            case 0xAC:
            case 0xAD:
            case 0xAE:
            case 0xAF:
            case 0xB0:
            case 0xB1:
            case 0xB2:
            case 0xB3:
            case 0xB4:
            case 0xB5:
            case 0xB6:
            case 0xB7:
            case 0xB8:
            case 0xB9:
            case 0xBA:
            case 0xBB:
            case 0xBC:
            case 0xBD:
            case 0xBE:
            case 0xBF:
            {
                return get_string(input_format_t::msgpack, static_cast<unsigned int>(current) & 0x1Fu, result);
            }

            case 0xD9: // str 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDA: // str 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            case 0xDB: // str 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);
            }

            default:
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                        exception_message(input_format_t::msgpack, concat("expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x", last_token), "string"), nullptr));
            }
        }
    }

    /*!
    @brief reads a MessagePack byte array

    This function first reads starting bytes to determine the expected
    byte array length and then copies this number of bytes into a byte array.

    @param[out] result  created byte array

    @return whether byte array creation completed
    */
    bool get_msgpack_binary(binary_t& result)
    {
        // helper function to set the subtype
        auto assign_and_return_true = [&result](std::int8_t subtype)
        {
            result.set_subtype(static_cast<std::uint8_t>(subtype));
            return true;
        };

        switch (current)
        {
            case 0xC4: // bin 8
            {
                std::uint8_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC5: // bin 16
            {
                std::uint16_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC6: // bin 32
            {
                std::uint32_t len{};
                return get_number(input_format_t::msgpack, len) &&
                       get_binary(input_format_t::msgpack, len, result);
            }

            case 0xC7: // ext 8
            {
                std::uint8_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC8: // ext 16
            {
                std::uint16_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xC9: // ext 32
            {
                std::uint32_t len{};
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, len) &&
                       get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, len, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD4: // fixext 1
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 1, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD5: // fixext 2
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 2, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD6: // fixext 4
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 4, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD7: // fixext 8
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 8, result) &&
                       assign_and_return_true(subtype);
            }

            case 0xD8: // fixext 16
            {
                std::int8_t subtype{};
                return get_number(input_format_t::msgpack, subtype) &&
                       get_binary(input_format_t::msgpack, 16, result) &&
                       assign_and_return_true(subtype);
            }

            default:           // LCOV_EXCL_LINE
                return false;  // LCOV_EXCL_LINE
        }
    }

    /*!
    @param[in] len  the length of the array
    @return whether array creation completed
    */
    bool get_msgpack_array(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))
        {
            return false;
        }

        for (std::size_t i = 0; i < len; ++i)
        {
            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
        }

        return sax->end_array();
    }

    /*!
    @param[in] len  the length of the object
    @return whether object creation completed
    */
    bool get_msgpack_object(const std::size_t len)
    {
        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))
        {
            return false;
        }

        string_t key;
        for (std::size_t i = 0; i < len; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))
            {
                return false;
            }

            if (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))
            {
                return false;
            }
            key.clear();
        }

        return sax->end_object();
    }

    ////////////
    // UBJSON //
    ////////////

    /*!
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether a valid UBJSON value was passed to the SAX parser
    */
    bool parse_ubjson_internal(const bool get_char = true)
    {
        return get_ubjson_value(get_char ? get_ignore_noop() : current);
    }

    /*!
    @brief reads a UBJSON string

    This function is either called after reading the 'S' byte explicitly
    indicating a string, or in case of an object key where the 'S' byte can be
    left out.

    @param[out] result   created string
    @param[in] get_char  whether a new character should be retrieved from the
                         input (true, default) or whether the last read
                         character should be considered instead

    @return whether string creation completed
    */
    bool get_ubjson_string(string_t& result, const bool get_char = true)
    {
        if (get_char)
        {
            get();  // TODO(niels): may we ignore N here?
        }

        if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
        {
            return false;
        }

        switch (current)
        {
            case 'U':
            {
                std::uint8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'i':
            {
                std::int8_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'I':
            {
                std::int16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'l':
            {
                std::int32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'L':
            {
                std::int64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t len{};
                return get_number(input_format, len) && get_string(input_format, len, result);
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L); last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L); last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "string"), nullptr));
    }

    /*!
    @param[out] dim  an integer vector storing the ND array dimensions
    @return whether reading ND array size vector is successful
    */
    bool get_ubjson_ndarray_size(std::vector<size_t>& dim)
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        size_t dimlen = 0;
        bool no_ndarray = true;

        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type, no_ndarray)))
        {
            return false;
        }

        if (size_and_type.first != npos)
        {
            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, size_and_type.second)))
                        {
                            return false;
                        }
                        dim.push_back(dimlen);
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray)))
                    {
                        return false;
                    }
                    dim.push_back(dimlen);
                }
            }
        }
        else
        {
            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_value(dimlen, no_ndarray, current)))
                {
                    return false;
                }
                dim.push_back(dimlen);
                get_ignore_noop();
            }
        }
        return true;
    }

    /*!
    @param[out] result  determined size
    @param[in,out] is_ndarray  for input, `true` means already inside an ndarray vector
                               or ndarray dimension is not allowed; `false` means ndarray
                               is allowed; for output, `true` means an ndarray is found;
                               is_ndarray can only return `true` when its initial value
                               is `false`
    @param[in] prefix  type marker if already read, otherwise set to 0

    @return whether size determination completed
    */
    bool get_ubjson_size_value(std::size_t& result, bool& is_ndarray, char_int_type prefix = 0)
    {
        if (prefix == 0)
        {
            prefix = get_ignore_noop();
        }

        switch (prefix)
        {
            case 'U':
            {
                std::uint8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'i':
            {
                std::int8_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number); // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char
                return true;
            }

            case 'I':
            {
                std::int16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'l':
            {
                std::int32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'L':
            {
                std::int64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (number < 0)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read,
                                            exception_message(input_format, "count in an optimized container must be positive", "size"), nullptr));
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = static_cast<std::size_t>(number);
                return true;
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                result = conditional_static_cast<std::size_t>(number);
                return true;
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                if (JSON_HEDLEY_UNLIKELY(!get_number(input_format, number)))
                {
                    return false;
                }
                if (!value_in_range_of<std::size_t>(number))
                {
                    return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408,
                                            exception_message(input_format, "integer value overflow", "size"), nullptr));
                }
                result = detail::conditional_static_cast<std::size_t>(number);
                return true;
            }

            case '[':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                if (is_ndarray) // ndarray dimensional vector can only contain integers and cannot embed another array
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(113, chars_read, exception_message(input_format, "ndarray dimensional vector is not allowed", "size"), nullptr));
                }
                std::vector<size_t> dim;
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_ndarray_size(dim)))
                {
                    return false;
                }
                if (dim.size() == 1 || (dim.size() == 2 && dim.at(0) == 1)) // return normal array size if 1D row vector
                {
                    result = dim.at(dim.size() - 1);
                    return true;
                }
                if (!dim.empty())  // if ndarray, convert to an object in JData annotated array format
                {
                    for (auto i : dim) // test if any dimension in an ndarray is 0, if so, return a 1D empty container
                    {
                        if ( i == 0 )
                        {
                            result = 0;
                            return true;
                        }
                    }

                    string_t key = "_ArraySize_";
                    if (JSON_HEDLEY_UNLIKELY(!sax->start_object(3) || !sax->key(key) || !sax->start_array(dim.size())))
                    {
                        return false;
                    }
                    result = 1;
                    for (auto i : dim)
                    {
                        // Pre-multiplication overflow check: if i > 0 and result > SIZE_MAX/i, then result*i would overflow.
                        // This check must happen before multiplication since overflow detection after the fact is unreliable
                        // as modular arithmetic can produce any value, not just 0 or SIZE_MAX.
                        if (JSON_HEDLEY_UNLIKELY(i > 0 && result > (std::numeric_limits<std::size_t>::max)() / i))
                        {
                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
                        }
                        result *= i;
                        // Additional post-multiplication check to catch any edge cases the pre-check might miss
                        if (result == 0 || result == npos)
                        {
                            return sax->parse_error(chars_read, get_token_string(), out_of_range::create(408, exception_message(input_format, "excessive ndarray size caused overflow", "size"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(static_cast<number_unsigned_t>(i))))
                        {
                            return false;
                        }
                    }
                    is_ndarray = true;
                    return sax->end_array();
                }
                result = 0;
                return true;
            }

            default:
                break;
        }
        auto last_token = get_token_string();
        std::string message;

        if (input_format != input_format_t::bjdata)
        {
            message = "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x" + last_token;
        }
        else
        {
            message = "expected length type specification (U, i, u, I, m, l, M, L) after '#'; last byte: 0x" + last_token;
        }
        return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format, message, "size"), nullptr));
    }

    /*!
    @brief determine the type and size for a container

    In the optimized UBJSON format, a type and a size can be provided to allow
    for a more compact representation.

    @param[out] result  pair of the size and the type
    @param[in] inside_ndarray  whether the parser is parsing an ND array dimensional vector

    @return whether pair creation completed
    */
    bool get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result, bool inside_ndarray = false)
    {
        result.first = npos; // size
        result.second = 0; // type
        bool is_ndarray = false;

        get_ignore_noop();

        if (current == '$')
        {
            result.second = get();  // must not ignore 'N', because 'N' maybe the type
            if (input_format == input_format_t::bjdata
                    && JSON_HEDLEY_UNLIKELY(std::binary_search(bjd_optimized_type_markers.begin(), bjd_optimized_type_markers.end(), result.second)))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("marker 0x", last_token, " is not a permitted optimized array type"), "type"), nullptr));
            }

            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "type")))
            {
                return false;
            }

            get_ignore_noop();
            if (JSON_HEDLEY_UNLIKELY(current != '#'))
            {
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "value")))
                {
                    return false;
                }
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, concat("expected '#' after type information; last byte: 0x", last_token), "size"), nullptr));
            }

            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                if (inside_ndarray)
                {
                    return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                            exception_message(input_format, "ndarray can not be recursive", "size"), nullptr));
                }
                result.second |= (1 << 8); // use bit 8 to indicate ndarray, all UBJSON and BJData markers should be ASCII letters
            }
            return is_error;
        }

        if (current == '#')
        {
            const bool is_error = get_ubjson_size_value(result.first, is_ndarray);
            if (input_format == input_format_t::bjdata && is_ndarray)
            {
                return sax->parse_error(chars_read, get_token_string(), parse_error::create(112, chars_read,
                                        exception_message(input_format, "ndarray requires both type and size", "size"), nullptr));
            }
            return is_error;
        }

        return true;
    }

    /*!
    @param prefix  the previously read or set type prefix
    @return whether value creation completed
    */
    bool get_ubjson_value(const char_int_type prefix)
    {
        switch (prefix)
        {
            case char_traits<char_type>::eof():  // EOF
                return unexpect_eof(input_format, "value");

            case 'T':  // true
                return sax->boolean(true);
            case 'F':  // false
                return sax->boolean(false);

            case 'Z':  // null
                return sax->null();

            case 'B':  // byte
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint8_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'U':
            {
                std::uint8_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'i':
            {
                std::int8_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'I':
            {
                std::int16_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'l':
            {
                std::int32_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'L':
            {
                std::int64_t number{};
                return get_number(input_format, number) && sax->number_integer(number);
            }

            case 'u':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint16_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'm':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint32_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'M':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                std::uint64_t number{};
                return get_number(input_format, number) && sax->number_unsigned(number);
            }

            case 'h':
            {
                if (input_format != input_format_t::bjdata)
                {
                    break;
                }
                const auto byte1_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }
                const auto byte2_raw = get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
                {
                    return false;
                }

                const auto byte1 = static_cast<unsigned char>(byte1_raw);
                const auto byte2 = static_cast<unsigned char>(byte2_raw);

                // Code from RFC 7049, Appendix D, Figure 3:
                // As half-precision floating-point numbers were only added
                // to IEEE 754 in 2008, today's programming platforms often
                // still only have limited support for them. It is very
                // easy to include at least decoding support for them even
                // without such support. An example of a small decoder for
                // half-precision floating-point numbers in the C language
                // is shown in Fig. 3.
                const auto half = static_cast<unsigned int>((byte2 << 8u) + byte1);
                const double val = [&half]
                {
                    const int exp = (half >> 10u) & 0x1Fu;
                    const unsigned int mant = half & 0x3FFu;
                    JSON_ASSERT(0 <= exp&& exp <= 32);
                    JSON_ASSERT(mant <= 1024);
                    switch (exp)
                    {
                        case 0:
                            return std::ldexp(mant, -24);
                        case 31:
                            return (mant == 0)
                            ? std::numeric_limits<double>::infinity()
                            : std::numeric_limits<double>::quiet_NaN();
                        default:
                            return std::ldexp(mant + 1024, exp - 25);
                    }
                }();
                return sax->number_float((half & 0x8000u) != 0
                                         ? static_cast<number_float_t>(-val)
                                         : static_cast<number_float_t>(val), "");
            }

            case 'd':
            {
                float number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'D':
            {
                double number{};
                return get_number(input_format, number) && sax->number_float(static_cast<number_float_t>(number), "");
            }

            case 'H':
            {
                return get_ubjson_high_precision_number();
            }

            case 'C':  // char
            {
                get();
                if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "char")))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(current > 127))
                {
                    auto last_token = get_token_string();
                    return sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read,
                                            exception_message(input_format, concat("byte after 'C' must be in range 0x00..0x7F; last byte: 0x", last_token), "char"), nullptr));
                }
                string_t s(1, static_cast<typename string_t::value_type>(current));
                return sax->string(s);
            }

            case 'S':  // string
            {
                string_t s;
                return get_ubjson_string(s) && sax->string(s);
            }

            case '[':  // array
                return get_ubjson_array();

            case '{':  // object
                return get_ubjson_object();

            default: // anything else
                break;
        }
        auto last_token = get_token_string();
        return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format, "invalid byte: 0x" + last_token, "value"), nullptr));
    }

    /*!
    @return whether array creation completed
    */
    bool get_ubjson_array()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // if bit-8 of size_and_type.second is set to 1, encode bjdata ndarray as an object in JData annotated array format (https://github.com/NeuroJSON/jdata):
        // {"_ArrayType_" : "typeid", "_ArraySize_" : [n1, n2, ...], "_ArrayData_" : [v1, v2, ...]}

        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            size_and_type.second &= ~(static_cast<char_int_type>(1) << 8);  // use bit 8 to indicate ndarray, here we remove the bit to restore the type marker
            auto it = std::lower_bound(bjd_types_map.begin(), bjd_types_map.end(), size_and_type.second, [](const bjd_type & p, char_int_type t)
            {
                return p.first < t;
            });
            string_t key = "_ArrayType_";
            if (JSON_HEDLEY_UNLIKELY(it == bjd_types_map.end() || it->first != size_and_type.second))
            {
                auto last_token = get_token_string();
                return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                        exception_message(input_format, "invalid byte: 0x" + last_token, "type"), nullptr));
            }

            string_t type = it->second; // sax->string() takes a reference
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->string(type)))
            {
                return false;
            }

            if (size_and_type.second == 'C' || size_and_type.second == 'B')
            {
                size_and_type.second = 'U';
            }

            key = "_ArrayData_";
            if (JSON_HEDLEY_UNLIKELY(!sax->key(key) || !sax->start_array(size_and_type.first) ))
            {
                return false;
            }

            for (std::size_t i = 0; i < size_and_type.first; ++i)
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                {
                    return false;
                }
            }

            return (sax->end_array() && sax->end_object());
        }

        // If BJData type marker is 'B' decode as binary
        if (input_format == input_format_t::bjdata && size_and_type.first != npos && size_and_type.second == 'B')
        {
            binary_t result;
            return get_binary(input_format, size_and_type.first, result) && sax->binary(result);
        }

        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                if (size_and_type.second != 'N')
                {
                    for (std::size_t i = 0; i < size_and_type.first; ++i)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                        {
                            return false;
                        }
                    }
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
            {
                return false;
            }

            while (current != ']')
            {
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal(false)))
                {
                    return false;
                }
                get_ignore_noop();
            }
        }

        return sax->end_array();
    }

    /*!
    @return whether object creation completed
    */
    bool get_ubjson_object()
    {
        std::pair<std::size_t, char_int_type> size_and_type;
        if (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))
        {
            return false;
        }

        // do not accept ND-array size in objects in BJData
        if (input_format == input_format_t::bjdata && size_and_type.first != npos && (size_and_type.second & (1 << 8)) != 0)
        {
            auto last_token = get_token_string();
            return sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read,
                                    exception_message(input_format, "BJData object does not support ND-array size in optimized format", "object"), nullptr));
        }

        string_t key;
        if (size_and_type.first != npos)
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))
            {
                return false;
            }

            if (size_and_type.second != 0)
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
            else
            {
                for (std::size_t i = 0; i < size_and_type.first; ++i)
                {
                    if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))
                    {
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                    {
                        return false;
                    }
                    key.clear();
                }
            }
        }
        else
        {
            if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
            {
                return false;
            }

            while (current != '}')
            {
                if (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, false) || !sax->key(key)))
                {
                    return false;
                }
                if (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))
                {
                    return false;
                }
                get_ignore_noop();
                key.clear();
            }
        }

        return sax->end_object();
    }

    // Note, no reader for UBJSON binary types is implemented because they do
    // not exist

    bool get_ubjson_high_precision_number()
    {
        // get the size of the following number string
        std::size_t size{};
        bool no_ndarray = true;
        auto res = get_ubjson_size_value(size, no_ndarray);
        if (JSON_HEDLEY_UNLIKELY(!res))
        {
            return res;
        }

        // get number string
        std::vector<char> number_vector;
        for (std::size_t i = 0; i < size; ++i)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format, "number")))
            {
                return false;
            }
            number_vector.push_back(static_cast<char>(current));
        }

        // parse number string
        using ia_type = decltype(detail::input_adapter(number_vector));
        auto number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), false);
        const auto result_number = number_lexer.scan();
        const auto number_string = number_lexer.get_token_string();
        const auto result_remainder = number_lexer.scan();

        using token_type = typename detail::lexer_base<BasicJsonType>::token_type;

        if (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))
        {
            return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                    exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }

        switch (result_number)
        {
            case token_type::value_integer:
                return sax->number_integer(number_lexer.get_number_integer());
            case token_type::value_unsigned:
                return sax->number_unsigned(number_lexer.get_number_unsigned());
            case token_type::value_float:
                return sax->number_float(number_lexer.get_number_float(), std::move(number_string));
            case token_type::uninitialized:
            case token_type::literal_true:
            case token_type::literal_false:
            case token_type::literal_null:
            case token_type::value_string:
            case token_type::begin_array:
            case token_type::begin_object:
            case token_type::end_array:
            case token_type::end_object:
            case token_type::name_separator:
            case token_type::value_separator:
            case token_type::parse_error:
            case token_type::end_of_input:
            case token_type::literal_or_value:
            default:
                return sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read,
                                        exception_message(input_format, concat("invalid number text: ", number_lexer.get_token_string()), "high-precision number"), nullptr));
        }
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*!
    @brief get next character from the input

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns a -'ve valued
    `char_traits<char_type>::eof()` in that case.

    @return character read from the input
    */
    char_int_type get()
    {
        ++chars_read;
        return current = ia.get_character();
    }

    /*!
    @brief get_to read into a primitive type

    This function provides the interface to the used input adapter. It does
    not throw in case the input reached EOF, but returns false instead

    @return bool, whether the read was successful
    */
    template<class T>
    bool get_to(T& dest, const input_format_t format, const char* context)
    {
        auto new_chars_read = ia.get_elements(&dest);
        chars_read += new_chars_read;
        if (JSON_HEDLEY_UNLIKELY(new_chars_read < sizeof(T)))
        {
            // in case of failure, advance position by 1 to report the failing location
            ++chars_read;
            sax->parse_error(chars_read, "<end of file>", parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
            return false;
        }
        return true;
    }

    /*!
    @return character read from the input after ignoring all 'N' entries
    */
    char_int_type get_ignore_noop()
    {
        do
        {
            get();
        }
        while (current == 'N');

        return current;
    }

    template<class NumberType>
    static void byte_swap(NumberType& number)
    {
        constexpr std::size_t sz = sizeof(number);
#ifdef __cpp_lib_byteswap
        if constexpr (sz == 1)
        {
            return;
        }
        else if constexpr(std::is_integral_v<NumberType>)
        {
            number = std::byteswap(number);
            return;
        }
        else
        {
#endif
            auto* ptr = reinterpret_cast<std::uint8_t*>(&number);
            for (std::size_t i = 0; i < sz / 2; ++i)
            {
                std::swap(ptr[i], ptr[sz - i - 1]);
            }
#ifdef __cpp_lib_byteswap
        }
#endif
    }

    /*
    @brief read a number from the input

    @tparam NumberType the type of the number
    @param[in] format   the current format (for diagnostics)
    @param[out] result  number of type @a NumberType

    @return whether conversion completed

    @note This function needs to respect the system's endianness, because
          bytes in CBOR, MessagePack, and UBJSON are stored in network order
          (big endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType, bool InputIsLittleEndian = false>
    bool get_number(const input_format_t format, NumberType& result)
    {
        // read in the original format

        if (JSON_HEDLEY_UNLIKELY(!get_to(result, format, "number")))
        {
            return false;
        }
        if (is_little_endian != (InputIsLittleEndian || format == input_format_t::bjdata))
        {
            byte_swap(result);
        }
        return true;
    }

    /*!
    @brief create a string by reading characters from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of characters to read
    @param[out] result string created by reading @a len bytes

    @return whether string creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of string memory.
    */
    template<typename NumberType>
    bool get_string(const input_format_t format,
                    const NumberType len,
                    string_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "string")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename string_t::value_type>(current));
        }
        return success;
    }

    /*!
    @brief create a byte array by reading bytes from the input

    @tparam NumberType the type of the number
    @param[in] format the current format (for diagnostics)
    @param[in] len number of bytes to read
    @param[out] result byte array created by reading @a len bytes

    @return whether byte array creation completed

    @note We can not reserve @a len bytes for the result, because @a len
          may be too large. Usually, @ref unexpect_eof() detects the end of
          the input before we run out of memory.
    */
    template<typename NumberType>
    bool get_binary(const input_format_t format,
                    const NumberType len,
                    binary_t& result)
    {
        bool success = true;
        for (NumberType i = 0; i < len; i++)
        {
            get();
            if (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, "binary")))
            {
                success = false;
                break;
            }
            result.push_back(static_cast<typename binary_t::value_type>(current));
        }
        return success;
    }

    /*!
    @param[in] format   the current format (for diagnostics)
    @param[in] context  further context information (for diagnostics)
    @return whether the last read character is not EOF
    */
    JSON_HEDLEY_NON_NULL(3)
    bool unexpect_eof(const input_format_t format, const char* context) const
    {
        if (JSON_HEDLEY_UNLIKELY(current == char_traits<char_type>::eof()))
        {
            return sax->parse_error(chars_read, "<end of file>",
                                    parse_error::create(110, chars_read, exception_message(format, "unexpected end of input", context), nullptr));
        }
        return true;
    }

    /*!
    @return a string representation of the last read byte
    */
    std::string get_token_string() const
    {
        std::array<char, 3> cr{{}};
        static_cast<void>((std::snprintf)(cr.data(), cr.size(), "%.2hhX", static_cast<unsigned char>(current))); // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        return std::string{cr.data()};
    }

    /*!
    @param[in] format   the current format
    @param[in] detail   a detailed error message
    @param[in] context  further context information
    @return a message string to use in the parse_error exceptions
    */
    std::string exception_message(const input_format_t format,
                                  const std::string& detail,
                                  const std::string& context) const
    {
        std::string error_msg = "syntax error while parsing ";

        switch (format)
        {
            case input_format_t::cbor:
                error_msg += "CBOR";
                break;

            case input_format_t::msgpack:
                error_msg += "MessagePack";
                break;

            case input_format_t::ubjson:
                error_msg += "UBJSON";
                break;

            case input_format_t::bson:
                error_msg += "BSON";
                break;

            case input_format_t::bjdata:
                error_msg += "BJData";
                break;

            case input_format_t::json: // LCOV_EXCL_LINE
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }

        return concat(error_msg, ' ', context, ": ", detail);
    }

  private:
    static JSON_INLINE_VARIABLE constexpr std::size_t npos = detail::unknown_size();

    /// input adapter
    InputAdapterType ia;

    /// the current character
    char_int_type current = char_traits<char_type>::eof();

    /// the number of characters read
    std::size_t chars_read = 0;

    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// input format
    const input_format_t input_format = input_format_t::json;

    /// the SAX parser
    json_sax_t* sax = nullptr;

    // excluded markers in bjdata optimized type
#define JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_ \
    make_array<char_int_type>('F', 'H', 'N', 'S', 'T', 'Z', '[', '{')

#define JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_ \
    make_array<bjd_type>(                      \
    bjd_type{'B', "byte"},                     \
    bjd_type{'C', "char"},                     \
    bjd_type{'D', "double"},                   \
    bjd_type{'I', "int16"},                    \
    bjd_type{'L', "int64"},                    \
    bjd_type{'M', "uint64"},                   \
    bjd_type{'U', "uint8"},                    \
    bjd_type{'d', "single"},                   \
    bjd_type{'i', "int8"},                     \
    bjd_type{'l', "int32"},                    \
    bjd_type{'m', "uint32"},                   \
    bjd_type{'u', "uint16"})

  JSON_PRIVATE_UNLESS_TESTED:
    // lookup tables
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_) bjd_optimized_type_markers =
        JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_;

    using bjd_type = std::pair<char_int_type, string_t>;
    // NOLINTNEXTLINE(cppcoreguidelines-non-private-member-variables-in-classes)
    const decltype(JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_) bjd_types_map =
        JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_;

#undef JSON_BINARY_READER_MAKE_BJD_OPTIMIZED_TYPE_MARKERS_
#undef JSON_BINARY_READER_MAKE_BJD_TYPES_MAP_
};

#ifndef JSON_HAS_CPP_17
    template<typename BasicJsonType, typename InputAdapterType, typename SAX>
    constexpr std::size_t binary_reader<BasicJsonType, InputAdapterType, SAX>::npos;
#endif

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/input/parser.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cmath> // isfinite
#include <cstdint> // uint8_t
#include <functional> // function
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/input/input_adapters.hpp>

// #include <nlohmann/detail/input/json_sax.hpp>

// #include <nlohmann/detail/input/lexer.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/is_sax.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{
////////////
// parser //
////////////

enum class parse_event_t : std::uint8_t
{
    /// the parser read `{` and started to process a JSON object
    object_start,
    /// the parser read `}` and finished processing a JSON object
    object_end,
    /// the parser read `[` and started to process a JSON array
    array_start,
    /// the parser read `]` and finished processing a JSON array
    array_end,
    /// the parser read a key of a value in an object
    key,
    /// the parser finished reading a JSON value
    value
};

template<typename BasicJsonType>
using parser_callback_t =
    std::function<bool(int /*depth*/, parse_event_t /*event*/, BasicJsonType& /*parsed*/)>;

/*!
@brief syntax analysis

This class implements a recursive descent parser.
*/
template<typename BasicJsonType, typename InputAdapterType>
class parser
{
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using string_t = typename BasicJsonType::string_t;
    using lexer_t = lexer<BasicJsonType, InputAdapterType>;
    using token_type = typename lexer_t::token_type;

  public:
    /// a parser reading from an input adapter
    explicit parser(InputAdapterType&& adapter,
                    parser_callback_t<BasicJsonType> cb = nullptr,
                    const bool allow_exceptions_ = true,
                    const bool ignore_comments = false,
                    const bool ignore_trailing_commas_ = false)
        : callback(std::move(cb))
        , m_lexer(std::move(adapter), ignore_comments)
        , allow_exceptions(allow_exceptions_)
        , ignore_trailing_commas(ignore_trailing_commas_)
    {
        // read first token
        get_token();
    }

    /*!
    @brief public parser interface

    @param[in] strict      whether to expect the last token to be EOF
    @param[in,out] result  parsed JSON value

    @throw parse_error.101 in case of an unexpected token
    @throw parse_error.102 if to_unicode fails or surrogate error
    @throw parse_error.103 if to_unicode fails
    */
    void parse(const bool strict, BasicJsonType& result)
    {
        if (callback)
        {
            json_sax_dom_callback_parser<BasicJsonType, InputAdapterType> sdp(result, callback, allow_exceptions, &m_lexer);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(),
                                                    exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return a discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }

            // set top-level value to null if it was discarded by the callback
            // function
            if (result.is_discarded())
            {
                result = nullptr;
            }
        }
        else
        {
            json_sax_dom_parser<BasicJsonType, InputAdapterType> sdp(result, allow_exceptions, &m_lexer);
            sax_parse_internal(&sdp);

            // in strict mode, input must be completely read
            if (strict && (get_token() != token_type::end_of_input))
            {
                sdp.parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
            }

            // in case of an error, return a discarded value
            if (sdp.is_errored())
            {
                result = value_t::discarded;
                return;
            }
        }

        result.assert_invariant();
    }

    /*!
    @brief public accept interface

    @param[in] strict  whether to expect the last token to be EOF
    @return whether the input is a proper JSON text
    */
    bool accept(const bool strict = true)
    {
        json_sax_acceptor<BasicJsonType> sax_acceptor;
        return sax_parse(&sax_acceptor, strict);
    }

    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse(SAX* sax, const bool strict = true)
    {
        (void)detail::is_sax_static_asserts<SAX, BasicJsonType> {};
        const bool result = sax_parse_internal(sax);

        // strict mode: next byte must be EOF
        if (result && strict && (get_token() != token_type::end_of_input))
        {
            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
        }

        return result;
    }

  private:
    template<typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    bool sax_parse_internal(SAX* sax)
    {
        // stack to remember the hierarchy of structured values we are parsing
        // true = array; false = object
        std::vector<bool> states;
        // value to avoid a goto (see comment where set to true)
        bool skip_to_state_evaluation = false;

        while (true)
        {
            if (!skip_to_state_evaluation)
            {
                // invariant: get_token() was called before each iteration
                switch (last_token)
                {
                    case token_type::begin_object:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_object(detail::unknown_size())))
                        {
                            return false;
                        }

                        // closing } -> we are done
                        if (get_token() == token_type::end_object)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                            {
                                return false;
                            }
                            break;
                        }

                        // parse key
                        if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                        }
                        if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                        {
                            return false;
                        }

                        // parse separator (:)
                        if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                        }

                        // remember we are now inside an object
                        states.push_back(false);

                        // parse values
                        get_token();
                        continue;
                    }

                    case token_type::begin_array:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->start_array(detail::unknown_size())))
                        {
                            return false;
                        }

                        // closing ] -> we are done
                        if (get_token() == token_type::end_array)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                            {
                                return false;
                            }
                            break;
                        }

                        // remember we are now inside an array
                        states.push_back(true);

                        // parse values (no need to call get_token)
                        continue;
                    }

                    case token_type::value_float:
                    {
                        const auto res = m_lexer.get_number_float();

                        if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
                        }

                        if (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))
                        {
                            return false;
                        }

                        break;
                    }

                    case token_type::literal_false:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(false)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_null:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->null()))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::literal_true:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->boolean(true)))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_integer:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_string:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::value_unsigned:
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))
                        {
                            return false;
                        }
                        break;
                    }

                    case token_type::parse_error:
                    {
                        // using "uninitialized" to avoid an "expected" message
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
                    }
                    case token_type::end_of_input:
                    {
                        if (JSON_HEDLEY_UNLIKELY(m_lexer.get_position().chars_read_total == 1))
                        {
                            return sax->parse_error(m_lexer.get_position(),
                                                    m_lexer.get_token_string(),
                                                    parse_error::create(101, m_lexer.get_position(),
                                                            "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
                        }

                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                    case token_type::uninitialized:
                    case token_type::end_array:
                    case token_type::end_object:
                    case token_type::name_separator:
                    case token_type::value_separator:
                    case token_type::literal_or_value:
                    default: // the last token was unexpected
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                    }
                }
            }
            else
            {
                skip_to_state_evaluation = false;
            }

            // we reached this line after we successfully parsed a value
            if (states.empty())
            {
                // empty stack: we reached the end of the hierarchy: done
                return true;
            }

            if (states.back())  // array
            {
                // comma -> next value
                // or end of array (ignore_trailing_commas = true)
                if (get_token() == token_type::value_separator)
                {
                    // parse a new value
                    get_token();

                    // if ignore_trailing_commas and last_token is ], we can continue to "closing ]"
                    if (!(ignore_trailing_commas && last_token == token_type::end_array))
                    {
                        continue;
                    }
                }

                // closing ]
                if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax->end_array()))
                    {
                        return false;
                    }

                    // We are done with this array. Before we can parse a
                    // new value, we need to evaluate the new state first.
                    // By setting skip_to_state_evaluation to false, we
                    // are effectively jumping to the beginning of this if.
                    JSON_ASSERT(!states.empty());
                    states.pop_back();
                    skip_to_state_evaluation = true;
                    continue;
                }

                return sax->parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
            }

            // states.back() is false -> object

            // comma -> next value
            // or end of object (ignore_trailing_commas = true)
            if (get_token() == token_type::value_separator)
            {
                get_token();

                // if ignore_trailing_commas and last_token is }, we can continue to "closing }"
                if (!(ignore_trailing_commas && last_token == token_type::end_object))
                {
                    // parse key
                    if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                    }

                    if (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax->parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                    }

                    // parse values
                    get_token();
                    continue;
                }
            }

            // closing }
            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
            {
                if (JSON_HEDLEY_UNLIKELY(!sax->end_object()))
                {
                    return false;
                }

                // We are done with this object. Before we can parse a
                // new value, we need to evaluate the new state first.
                // By setting skip_to_state_evaluation to false, we
                // are effectively jumping to the beginning of this if.
                JSON_ASSERT(!states.empty());
                states.pop_back();
                skip_to_state_evaluation = true;
                continue;
            }

            return sax->parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
        }
    }

    /// get next token from lexer
    token_type get_token()
    {
        return last_token = m_lexer.scan();
    }

    std::string exception_message(const token_type expected, const std::string& context)
    {
        std::string error_msg = "syntax error ";

        if (!context.empty())
        {
            error_msg += concat("while parsing ", context, ' ');
        }

        error_msg += "- ";

        if (last_token == token_type::parse_error)
        {
            error_msg += concat(m_lexer.get_error_message(), "; last read: '",
                                m_lexer.get_token_string(), '\'');
        }
        else
        {
            error_msg += concat("unexpected ", lexer_t::token_type_name(last_token));
        }

        if (expected != token_type::uninitialized)
        {
            error_msg += concat("; expected ", lexer_t::token_type_name(expected));
        }

        return error_msg;
    }

  private:
    /// callback function
    const parser_callback_t<BasicJsonType> callback = nullptr;
    /// the type of the last read token
    token_type last_token = token_type::uninitialized;
    /// the lexer
    lexer_t m_lexer;
    /// whether to throw exceptions in case of errors
    const bool allow_exceptions = true;
    /// whether trailing commas in objects and arrays should be ignored (true) or signaled as errors (false)
    const bool ignore_trailing_commas = false;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/internal_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // ptrdiff_t
#include <limits>  // numeric_limits

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*
@brief an iterator for primitive JSON types

This class models an iterator for primitive JSON types (boolean, number,
string). Its only purpose is to allow the iterator/const_iterator classes
to "iterate" over primitive values. Internally, the iterator is modeled by
a `difference_type` variable. Value begin_value (`0`) models the begin and
end_value (`1`) models past the end.
*/
class primitive_iterator_t
{
  private:
    using difference_type = std::ptrdiff_t;
    static constexpr difference_type begin_value = 0;
    static constexpr difference_type end_value = begin_value + 1;

  JSON_PRIVATE_UNLESS_TESTED:
    /// iterator as signed integer type
    difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();

  public:
    constexpr difference_type get_value() const noexcept
    {
        return m_it;
    }

    /// set iterator to a defined beginning
    void set_begin() noexcept
    {
        m_it = begin_value;
    }

    /// set iterator to a defined past the end
    void set_end() noexcept
    {
        m_it = end_value;
    }

    /// return whether the iterator can be dereferenced
    constexpr bool is_begin() const noexcept
    {
        return m_it == begin_value;
    }

    /// return whether the iterator is at end
    constexpr bool is_end() const noexcept
    {
        return m_it == end_value;
    }

    friend constexpr bool operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it == rhs.m_it;
    }

    friend constexpr bool operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it < rhs.m_it;
    }

    primitive_iterator_t operator+(difference_type n) noexcept
    {
        auto result = *this;
        result += n;
        return result;
    }

    friend constexpr difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) noexcept
    {
        return lhs.m_it - rhs.m_it;
    }

    primitive_iterator_t& operator++() noexcept
    {
        ++m_it;
        return *this;
    }

    primitive_iterator_t operator++(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++m_it;
        return result;
    }

    primitive_iterator_t& operator--() noexcept
    {
        --m_it;
        return *this;
    }

    primitive_iterator_t operator--(int)& noexcept // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --m_it;
        return result;
    }

    primitive_iterator_t& operator+=(difference_type n) noexcept
    {
        m_it += n;
        return *this;
    }

    primitive_iterator_t& operator-=(difference_type n) noexcept
    {
        m_it -= n;
        return *this;
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief an iterator value

@note This structure could easily be a union, but MSVC currently does not allow
unions members with complex constructors, see https://github.com/nlohmann/json/pull/105.
*/
template<typename BasicJsonType> struct internal_iterator
{
    /// iterator for JSON objects
    typename BasicJsonType::object_t::iterator object_iterator {};
    /// iterator for JSON arrays
    typename BasicJsonType::array_t::iterator array_iterator {};
    /// generic iterator for all other types
    primitive_iterator_t primitive_iterator {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/iter_impl.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <iterator> // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next
#include <type_traits> // conditional, is_const, remove_const

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/iterators/internal_iterator.hpp>

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

// forward declare to be able to friend it later on
template<typename IteratorType> class iteration_proxy;
template<typename IteratorType> class iteration_proxy_value;

/*!
@brief a template for a bidirectional iterator for the @ref basic_json class
This class implements a both iterators (iterator and const_iterator) for the
@ref basic_json class.
@note An iterator is called *initialized* when a pointer to a JSON value has
      been set (e.g., by a constructor or a copy assignment). If the iterator is
      default-constructed, it is *uninitialized* and most methods are undefined.
      **The library uses assertions to detect calls on uninitialized iterators.**
@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
@since version 1.0.0, simplified in version 2.0.9, change to bidirectional
       iterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)
*/
template<typename BasicJsonType>
class iter_impl // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
{
    /// the iterator with BasicJsonType of different const-ness
    using other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, typename std::remove_const<BasicJsonType>::type, const BasicJsonType>::type>;
    /// allow basic_json to access private members
    friend other_iter_impl;
    friend BasicJsonType;
    friend iteration_proxy<iter_impl>;
    friend iteration_proxy_value<iter_impl>;

    using object_t = typename BasicJsonType::object_t;
    using array_t = typename BasicJsonType::array_t;
    // make sure BasicJsonType is basic_json or const basic_json
    static_assert(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,
                  "iter_impl only accepts (const) basic_json");
    // superficial check for the LegacyBidirectionalIterator named requirement
    static_assert(std::is_base_of<std::bidirectional_iterator_tag, std::bidirectional_iterator_tag>::value
                  &&  std::is_base_of<std::bidirectional_iterator_tag, typename std::iterator_traits<typename array_t::iterator>::iterator_category>::value,
                  "basic_json iterator assumes array and object type iterators satisfy the LegacyBidirectionalIterator named requirement.");

  public:
    /// The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.
    /// The C++ Standard has never required user-defined iterators to derive from std::iterator.
    /// A user-defined iterator should provide publicly accessible typedefs named
    /// iterator_category, value_type, difference_type, pointer, and reference.
    /// Note that value_type is required to be non-const, even for constant iterators.
    using iterator_category = std::bidirectional_iterator_tag;

    /// the type of the values when the iterator is dereferenced
    using value_type = typename BasicJsonType::value_type;
    /// a type to represent differences between iterators
    using difference_type = typename BasicJsonType::difference_type;
    /// defines a pointer to the type iterated over (value_type)
    using pointer = typename std::conditional<std::is_const<BasicJsonType>::value,
          typename BasicJsonType::const_pointer,
          typename BasicJsonType::pointer>::type;
    /// defines a reference to the type iterated over (value_type)
    using reference =
        typename std::conditional<std::is_const<BasicJsonType>::value,
        typename BasicJsonType::const_reference,
        typename BasicJsonType::reference>::type;

    iter_impl() = default;
    ~iter_impl() = default;
    iter_impl(iter_impl&&) noexcept = default;
    iter_impl& operator=(iter_impl&&) noexcept = default;

    /*!
    @brief constructor for a given JSON instance
    @param[in] object  pointer to a JSON object for this iterator
    @pre object != nullptr
    @post The iterator is initialized; i.e. `m_object != nullptr`.
    */
    explicit iter_impl(pointer object) noexcept : m_object(object)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = typename object_t::iterator();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = typename array_t::iterator();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator = primitive_iterator_t();
                break;
            }
        }
    }

    /*!
    @note The conventional copy constructor and copy assignment are implicitly
          defined. Combined with the following converting constructor and
          assignment, they support: (1) copy from iterator to iterator, (2)
          copy from const iterator to const iterator, and (3) conversion from
          iterator to const iterator. However conversion from const iterator
          to iterator is not defined.
    */

    /*!
    @brief const copy constructor
    @param[in] other const iterator to copy from
    @note This copy constructor had to be defined explicitly to circumvent a bug
          occurring on msvc v19.0 compiler (VS 2015) debug build. For more
          information refer to: https://github.com/nlohmann/json/issues/1608
    */
    iter_impl(const iter_impl<const BasicJsonType>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<const BasicJsonType>& other) noexcept
    {
        if (&other != this)
        {
            m_object = other.m_object;
            m_it = other.m_it;
        }
        return *this;
    }

    /*!
    @brief converting constructor
    @param[in] other  non-const iterator to copy from
    @note It is not checked whether @a other is initialized.
    */
    iter_impl(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept
        : m_object(other.m_object), m_it(other.m_it)
    {}

    /*!
    @brief converting assignment
    @param[in] other  non-const iterator to copy from
    @return const/non-const iterator
    @note It is not checked whether @a other is initialized.
    */
    iter_impl& operator=(const iter_impl<typename std::remove_const<BasicJsonType>::type>& other) noexcept // NOLINT(cert-oop54-cpp)
    {
        m_object = other.m_object;
        m_it = other.m_it;
        return *this;
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief set the iterator to the first value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_begin() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->begin();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->begin();
                break;
            }

            case value_t::null:
            {
                // set to end so begin()==end() is true: null is empty
                m_it.primitive_iterator.set_end();
                break;
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_begin();
                break;
            }
        }
    }

    /*!
    @brief set the iterator past the last value
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    void set_end() noexcept
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                m_it.object_iterator = m_object->m_data.m_value.object->end();
                break;
            }

            case value_t::array:
            {
                m_it.array_iterator = m_object->m_data.m_value.array->end();
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator.set_end();
                break;
            }
        }
    }

  public:
    /*!
    @brief return a reference to the value pointed to by the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator*() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return m_it.object_iterator->second;
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return *m_it.array_iterator;
            }

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief dereference the iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    pointer operator->() const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                JSON_ASSERT(m_it.object_iterator != m_object->m_data.m_value.object->end());
                return &(m_it.object_iterator->second);
            }

            case value_t::array:
            {
                JSON_ASSERT(m_it.array_iterator != m_object->m_data.m_value.array->end());
                return &*m_it.array_iterator;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))
                {
                    return m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief post-increment (it++)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        ++(*this);
        return result;
    }

    /*!
    @brief pre-increment (++it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator++()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, 1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, 1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                ++m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief post-decrement (it--)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        auto result = *this;
        --(*this);
        return result;
    }

    /*!
    @brief pre-decrement (--it)
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator--()
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
            {
                std::advance(m_it.object_iterator, -1);
                break;
            }

            case value_t::array:
            {
                std::advance(m_it.array_iterator, -1);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                --m_it.primitive_iterator;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief comparison: equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator==(const IterImpl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        // value-initialized forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type #4493
        if (m_object == nullptr)
        {
            return true;
        }

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                return (m_it.object_iterator == other.m_it.object_iterator);

            case value_t::array:
                return (m_it.array_iterator == other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator == other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: not equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    template < typename IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::nullptr_t > = nullptr >
    bool operator!=(const IterImpl& other) const
    {
        return !operator==(other);
    }

    /*!
    @brief comparison: smaller
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator<(const iter_impl& other) const
    {
        // if objects are not the same, the comparison is undefined
        if (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))
        {
            JSON_THROW(invalid_iterator::create(212, "cannot compare iterators of different containers", m_object));
        }

        // value-initialized forward iterators can be compared, and must compare equal to other value-initialized iterators of the same type #4493
        if (m_object == nullptr)
        {
            // the iterators are both value-initialized and are to be considered equal, but this function checks for smaller, so we return false
            return false;
        }

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(213, "cannot compare order of object iterators", m_object));

            case value_t::array:
                return (m_it.array_iterator < other.m_it.array_iterator);

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return (m_it.primitive_iterator < other.m_it.primitive_iterator);
        }
    }

    /*!
    @brief comparison: less than or equal
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator<=(const iter_impl& other) const
    {
        return !other.operator < (*this);
    }

    /*!
    @brief comparison: greater than
    @pre (1) Both iterators are initialized to point to the same object, or (2) both iterators are value-initialized.
    */
    bool operator>(const iter_impl& other) const
    {
        return !operator<=(other);
    }

    /*!
    @brief comparison: greater than or equal
    @pre (1) The iterator is initialized; i.e. `m_object != nullptr`, or (2) both iterators are value-initialized.
    */
    bool operator>=(const iter_impl& other) const
    {
        return !operator<(other);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator+=(difference_type i)
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
            {
                std::advance(m_it.array_iterator, i);
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                m_it.primitive_iterator += i;
                break;
            }
        }

        return *this;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl& operator-=(difference_type i)
    {
        return operator+=(-i);
    }

    /*!
    @brief add to iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator+(difference_type i) const
    {
        auto result = *this;
        result += i;
        return result;
    }

    /*!
    @brief addition of distance and iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    friend iter_impl operator+(difference_type i, const iter_impl& it)
    {
        auto result = it;
        result += i;
        return result;
    }

    /*!
    @brief subtract from iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    iter_impl operator-(difference_type i) const
    {
        auto result = *this;
        result -= i;
        return result;
    }

    /*!
    @brief return difference
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    difference_type operator-(const iter_impl& other) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(209, "cannot use offsets with object iterators", m_object));

            case value_t::array:
                return m_it.array_iterator - other.m_it.array_iterator;

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                return m_it.primitive_iterator - other.m_it.primitive_iterator;
        }
    }

    /*!
    @brief access to successor
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference operator[](difference_type n) const
    {
        JSON_ASSERT(m_object != nullptr);

        switch (m_object->m_data.m_type)
        {
            case value_t::object:
                JSON_THROW(invalid_iterator::create(208, "cannot use operator[] for object iterators", m_object));

            case value_t::array:
                return *std::next(m_it.array_iterator, n);

            case value_t::null:
                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                if (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))
                {
                    return *m_object;
                }

                JSON_THROW(invalid_iterator::create(214, "cannot get value", m_object));
            }
        }
    }

    /*!
    @brief return the key of an object iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    const typename object_t::key_type& key() const
    {
        JSON_ASSERT(m_object != nullptr);

        if (JSON_HEDLEY_LIKELY(m_object->is_object()))
        {
            return m_it.object_iterator->first;
        }

        JSON_THROW(invalid_iterator::create(207, "cannot use key() for non-object iterators", m_object));
    }

    /*!
    @brief return the value of an iterator
    @pre The iterator is initialized; i.e. `m_object != nullptr`.
    */
    reference value() const
    {
        return operator*();
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /// associated JSON instance
    pointer m_object = nullptr;
    /// the actual iterator of the associated instance
    internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it {};
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/iteration_proxy.hpp>

// #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <cstddef> // ptrdiff_t
#include <iterator> // reverse_iterator
#include <utility> // declval

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

//////////////////////
// reverse_iterator //
//////////////////////

/*!
@brief a template for a reverse iterator class

@tparam Base the base iterator type to reverse. Valid types are @ref
iterator (to create @ref reverse_iterator) and @ref const_iterator (to
create @ref const_reverse_iterator).

@requirement The class satisfies the following concept requirements:
-
[BidirectionalIterator](https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator):
  The iterator that can be moved can be moved in both directions (i.e.
  incremented and decremented).
- [OutputIterator](https://en.cppreference.com/w/cpp/named_req/OutputIterator):
  It is possible to write to the pointed-to element (only if @a Base is
  @ref iterator).

@since version 1.0.0
*/
template<typename Base>
class json_reverse_iterator : public std::reverse_iterator<Base>
{
  public:
    using difference_type = std::ptrdiff_t;
    /// shortcut to the reverse iterator adapter
    using base_iterator = std::reverse_iterator<Base>;
    /// the reference type for the pointed-to element
    using reference = typename Base::reference;

    /// create reverse iterator from iterator
    explicit json_reverse_iterator(const typename base_iterator::iterator_type& it) noexcept
        : base_iterator(it) {}

    /// create reverse iterator from base class
    explicit json_reverse_iterator(const base_iterator& it) noexcept : base_iterator(it) {}

    /// post-increment (it++)
    json_reverse_iterator operator++(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator++(1));
    }

    /// pre-increment (++it)
    json_reverse_iterator& operator++()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator++());
    }

    /// post-decrement (it--)
    json_reverse_iterator operator--(int)& // NOLINT(cert-dcl21-cpp)
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator--(1));
    }

    /// pre-decrement (--it)
    json_reverse_iterator& operator--()
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator--());
    }

    /// add to iterator
    json_reverse_iterator& operator+=(difference_type i)
    {
        return static_cast<json_reverse_iterator&>(base_iterator::operator+=(i));
    }

    /// add to iterator
    json_reverse_iterator operator+(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator+(i));
    }

    /// subtract from iterator
    json_reverse_iterator operator-(difference_type i) const
    {
        return static_cast<json_reverse_iterator>(base_iterator::operator-(i));
    }

    /// return difference
    difference_type operator-(const json_reverse_iterator& other) const
    {
        return base_iterator(*this) - base_iterator(other);
    }

    /// access to successor
    reference operator[](difference_type n) const
    {
        return *(this->operator+(n));
    }

    /// return the key of an object iterator
    auto key() const -> decltype(std::declval<Base>().key())
    {
        auto it = --this->base();
        return it.key();
    }

    /// return the value of an iterator
    reference value() const
    {
        auto it = --this->base();
        return it.operator * ();
    }
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/iterators/primitive_iterator.hpp>

// #include <nlohmann/detail/json_custom_base_class.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <type_traits> // conditional, is_same

// #include <nlohmann/detail/abi_macros.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief Default base class of the @ref basic_json class.

So that the correct implementations of the copy / move ctors / assign operators
of @ref basic_json do not require complex case distinctions
(no base class / custom base class used as customization point),
@ref basic_json always has a base class.
By default, this class is used because it is empty and thus has no effect
on the behavior of @ref basic_json.
*/
struct json_default_base {};

template<class T>
using json_base_class = typename std::conditional <
                        std::is_same<T, void>::value,
                        json_default_base,
                        T
                        >::type;

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/json_pointer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // all_of
#include <cctype> // isdigit
#include <cerrno> // errno, ERANGE
#include <cstdlib> // strtoull
#ifndef JSON_NO_IO
    #include <iosfwd> // ostream
#endif  // JSON_NO_IO
#include <limits> // max
#include <numeric> // accumulate
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/string_escape.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// @brief JSON Pointer defines a string syntax for identifying a specific value within a JSON document
/// @sa https://json.nlohmann.me/api/json_pointer/
template<typename RefStringType>
class json_pointer
{
    // allow basic_json to access private members
    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    friend class basic_json;

    template<typename>
    friend class json_pointer;

    template<typename T>
    struct string_t_helper
    {
        using type = T;
    };

    NLOHMANN_BASIC_JSON_TPL_DECLARATION
    struct string_t_helper<NLOHMANN_BASIC_JSON_TPL>
    {
        using type = StringType;
    };

  public:
    // for backwards compatibility accept BasicJsonType
    using string_t = typename string_t_helper<RefStringType>::type;

    /// @brief create JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/json_pointer/
    explicit json_pointer(const string_t& s = "")
        : reference_tokens(split(s))
    {}

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/to_string/
    string_t to_string() const
    {
        return std::accumulate(reference_tokens.begin(), reference_tokens.end(),
                               string_t{},
                               [](const string_t& a, const string_t& b)
        {
            return detail::concat(a, '/', detail::escape(b));
        });
    }

    /// @brief return a string representation of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_string/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, to_string())
    operator string_t() const
    {
        return to_string();
    }

#ifndef JSON_NO_IO
    /// @brief write string representation of the JSON pointer to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const json_pointer& ptr)
    {
        o << ptr.to_string();
        return o;
    }
#endif

    /// @brief append another JSON pointer at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(const json_pointer& ptr)
    {
        reference_tokens.insert(reference_tokens.end(),
                                ptr.reference_tokens.begin(),
                                ptr.reference_tokens.end());
        return *this;
    }

    /// @brief append an unescaped reference token at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(string_t token)
    {
        push_back(std::move(token));
        return *this;
    }

    /// @brief append an array index at the end of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slasheq/
    json_pointer& operator/=(std::size_t array_idx)
    {
        return *this /= std::to_string(array_idx);
    }

    /// @brief create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs,
                                  const json_pointer& rhs)
    {
        return json_pointer(lhs) /= rhs;
    }

    /// @brief create a new JSON pointer by appending the unescaped token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, string_t token) // NOLINT(performance-unnecessary-value-param)
    {
        return json_pointer(lhs) /= std::move(token);
    }

    /// @brief create a new JSON pointer by appending the array-index-token at the end of the JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_slash/
    friend json_pointer operator/(const json_pointer& lhs, std::size_t array_idx)
    {
        return json_pointer(lhs) /= array_idx;
    }

    /// @brief returns the parent of this JSON pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/parent_pointer/
    json_pointer parent_pointer() const
    {
        if (empty())
        {
            return *this;
        }

        json_pointer res = *this;
        res.pop_back();
        return res;
    }

    /// @brief remove last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/pop_back/
    void pop_back()
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        reference_tokens.pop_back();
    }

    /// @brief return last reference token
    /// @sa https://json.nlohmann.me/api/json_pointer/back/
    const string_t& back() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        return reference_tokens.back();
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(const string_t& token)
    {
        reference_tokens.push_back(token);
    }

    /// @brief append an unescaped token at the end of the reference pointer
    /// @sa https://json.nlohmann.me/api/json_pointer/push_back/
    void push_back(string_t&& token)
    {
        reference_tokens.push_back(std::move(token));
    }

    /// @brief return whether pointer points to the root document
    /// @sa https://json.nlohmann.me/api/json_pointer/empty/
    bool empty() const noexcept
    {
        return reference_tokens.empty();
    }

  private:
    /*!
    @param[in] s  reference token to be converted into an array index

    @return integer representation of @a s

    @throw parse_error.106  if an array index begins with '0'
    @throw parse_error.109  if an array index begins not with a digit
    @throw out_of_range.404 if string @a s could not be converted to an integer
    @throw out_of_range.410 if an array index exceeds size_type
    */
    template<typename BasicJsonType>
    static typename BasicJsonType::size_type array_index(const string_t& s)
    {
        using size_type = typename BasicJsonType::size_type;

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == '0'))
        {
            JSON_THROW(detail::parse_error::create(106, 0, detail::concat("array index '", s, "' must not begin with '0'"), nullptr));
        }

        // error condition (cf. RFC 6901, Sect. 4)
        if (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= '1' && s[0] <= '9')))
        {
            JSON_THROW(detail::parse_error::create(109, 0, detail::concat("array index '", s, "' is not a number"), nullptr));
        }

        const char* p = s.c_str();
        char* p_end = nullptr; // NOLINT(misc-const-correctness)
        errno = 0; // strtoull doesn't reset errno
        const unsigned long long res = std::strtoull(p, &p_end, 10); // NOLINT(runtime/int)
        if (p == p_end // invalid input or empty string
                || errno == ERANGE // out of range
                || JSON_HEDLEY_UNLIKELY(static_cast<std::size_t>(p_end - p) != s.size())) // incomplete read
        {
            JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", s, "'"), nullptr));
        }

        // only triggered on special platforms (like 32bit), see also
        // https://github.com/nlohmann/json/pull/2203
        if (res >= static_cast<unsigned long long>((std::numeric_limits<size_type>::max)()))  // NOLINT(runtime/int)
        {
            JSON_THROW(detail::out_of_range::create(410, detail::concat("array index ", s, " exceeds size_type"), nullptr));   // LCOV_EXCL_LINE
        }

        return static_cast<size_type>(res);
    }

  JSON_PRIVATE_UNLESS_TESTED:
    json_pointer top() const
    {
        if (JSON_HEDLEY_UNLIKELY(empty()))
        {
            JSON_THROW(detail::out_of_range::create(405, "JSON pointer has no parent", nullptr));
        }

        json_pointer result = *this;
        result.reference_tokens = {reference_tokens[0]};
        return result;
    }

  private:
    /*!
    @brief create and return a reference to the pointed to value

    @complexity Linear in the number of reference tokens.

    @throw parse_error.109 if array index is not a number
    @throw type_error.313 if value cannot be unflattened
    */
    template<typename BasicJsonType>
    BasicJsonType& get_and_create(BasicJsonType& j) const
    {
        auto* result = &j;

        // in case no reference tokens exist, return a reference to the JSON value
        // j which will be overwritten by a primitive value
        for (const auto& reference_token : reference_tokens)
        {
            switch (result->type())
            {
                case detail::value_t::null:
                {
                    if (reference_token == "0")
                    {
                        // start a new array if the reference token is 0
                        result = &result->operator[](0);
                    }
                    else
                    {
                        // start a new object otherwise
                        result = &result->operator[](reference_token);
                    }
                    break;
                }

                case detail::value_t::object:
                {
                    // create an entry in the object
                    result = &result->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    // create an entry in the array
                    result = &result->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                /*
                The following code is only reached if there exists a reference
                token _and_ the current value is primitive. In this case, we have
                an error situation, because primitive values may only occur as
                a single value; that is, with an empty list of reference tokens.
                */
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::type_error::create(313, "invalid value to unflatten", &j));
            }
        }

        return *result;
    }

    /*!
    @brief return a reference to the pointed to value

    @note This version does not throw if a value is not present, but tries to
          create nested values instead. For instance, calling this function
          with pointer `"/this/that"` on a null value is equivalent to calling
          `operator[]("this").operator[]("that")` on that value, effectively
          changing the null value to an object.

    @param[in] ptr  a JSON value

    @return reference to the JSON value pointed to by the JSON pointer

    @complexity Linear in the length of the JSON pointer.

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_unchecked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            // convert null values to arrays or objects before continuing
            if (ptr->is_null())
            {
                // check if the reference token is a number
                const bool nums =
                    std::all_of(reference_token.begin(), reference_token.end(),
                                [](const unsigned char x)
                {
                    return std::isdigit(x);
                });

                // change value to an array for numbers or "-" or to object otherwise
                *ptr = (nums || reference_token == "-")
                       ? detail::value_t::array
                       : detail::value_t::object;
            }

            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (reference_token == "-")
                    {
                        // explicitly treat "-" as index beyond the end
                        ptr = &ptr->operator[](ptr->m_data.m_value.array->size());
                    }
                    else
                    {
                        // convert array index to number; unchecked access
                        ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    }
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    BasicJsonType& get_checked(BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @brief return a const reference to the pointed to value

    @param[in] ptr  a JSON value

    @return const reference to the JSON value pointed to by the JSON
    pointer

    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_unchecked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // use unchecked object access
                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" cannot be used for const access
                        JSON_THROW(detail::out_of_range::create(402, detail::concat("array index '-' (", std::to_string(ptr->m_data.m_value.array->size()), ") is out of range"), ptr));
                    }

                    // use unchecked array access
                    ptr = &ptr->operator[](array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    @throw out_of_range.402  if the array index '-' is used
    @throw out_of_range.404  if the JSON pointer can not be resolved
    */
    template<typename BasicJsonType>
    const BasicJsonType& get_checked(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    // note: at performs range check
                    ptr = &ptr->at(reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        JSON_THROW(detail::out_of_range::create(402, detail::concat(
                                "array index '-' (", std::to_string(ptr->m_data.m_value.array->size()),
                                ") is out of range"), ptr));
                    }

                    // note: at performs range check
                    ptr = &ptr->at(array_index<BasicJsonType>(reference_token));
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                    JSON_THROW(detail::out_of_range::create(404, detail::concat("unresolved reference token '", reference_token, "'"), ptr));
            }
        }

        return *ptr;
    }

    /*!
    @throw parse_error.106   if an array index begins with '0'
    @throw parse_error.109   if an array index was not a number
    */
    template<typename BasicJsonType>
    bool contains(const BasicJsonType* ptr) const
    {
        for (const auto& reference_token : reference_tokens)
        {
            switch (ptr->type())
            {
                case detail::value_t::object:
                {
                    if (!ptr->contains(reference_token))
                    {
                        // we did not find the key in the object
                        return false;
                    }

                    ptr = &ptr->operator[](reference_token);
                    break;
                }

                case detail::value_t::array:
                {
                    if (JSON_HEDLEY_UNLIKELY(reference_token == "-"))
                    {
                        // "-" always fails the range check
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !("0" <= reference_token && reference_token <= "9")))
                    {
                        // invalid char
                        return false;
                    }
                    if (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))
                    {
                        if (JSON_HEDLEY_UNLIKELY(!('1' <= reference_token[0] && reference_token[0] <= '9')))
                        {
                            // the first char should be between '1' and '9'
                            return false;
                        }
                        for (std::size_t i = 1; i < reference_token.size(); i++)
                        {
                            if (JSON_HEDLEY_UNLIKELY(!('0' <= reference_token[i] && reference_token[i] <= '9')))
                            {
                                // other char should be between '0' and '9'
                                return false;
                            }
                        }
                    }

                    const auto idx = array_index<BasicJsonType>(reference_token);
                    if (idx >= ptr->size())
                    {
                        // index out of range
                        return false;
                    }

                    ptr = &ptr->operator[](idx);
                    break;
                }

                case detail::value_t::null:
                case detail::value_t::string:
                case detail::value_t::boolean:
                case detail::value_t::number_integer:
                case detail::value_t::number_unsigned:
                case detail::value_t::number_float:
                case detail::value_t::binary:
                case detail::value_t::discarded:
                default:
                {
                    // we do not expect primitive values if there is still a
                    // reference token to process
                    return false;
                }
            }
        }

        // no reference token left means we found a primitive value
        return true;
    }

    /*!
    @brief split the string input to reference tokens

    @note This function is only called by the json_pointer constructor.
          All exceptions below are documented there.

    @throw parse_error.107  if the pointer is not empty or begins with '/'
    @throw parse_error.108  if character '~' is not followed by '0' or '1'
    */
    static std::vector<string_t> split(const string_t& reference_string)
    {
        std::vector<string_t> result;

        // special case: empty reference string -> no reference tokens
        if (reference_string.empty())
        {
            return result;
        }

        // check if a nonempty reference string begins with slash
        if (JSON_HEDLEY_UNLIKELY(reference_string[0] != '/'))
        {
            JSON_THROW(detail::parse_error::create(107, 1, detail::concat("JSON pointer must be empty or begin with '/' - was: '", reference_string, "'"), nullptr));
        }

        // extract the reference tokens:
        // - slash: position of the last read slash (or end of string)
        // - start: position after the previous slash
        for (
            // search for the first slash after the first character
            std::size_t slash = reference_string.find_first_of('/', 1),
            // set the beginning of the first reference token
            start = 1;
            // we can stop if start == 0 (if slash == string_t::npos)
            start != 0;
            // set the beginning of the next reference token
            // (will eventually be 0 if slash == string_t::npos)
            start = (slash == string_t::npos) ? 0 : slash + 1,
            // find next slash
            slash = reference_string.find_first_of('/', start))
        {
            // use the text between the beginning of the reference token
            // (start) and the last slash (slash).
            auto reference_token = reference_string.substr(start, slash - start);

            // check reference tokens are properly escaped
            for (std::size_t pos = reference_token.find_first_of('~');
                    pos != string_t::npos;
                    pos = reference_token.find_first_of('~', pos + 1))
            {
                JSON_ASSERT(reference_token[pos] == '~');

                // ~ must be followed by 0 or 1
                if (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||
                                         (reference_token[pos + 1] != '0' &&
                                          reference_token[pos + 1] != '1')))
                {
                    JSON_THROW(detail::parse_error::create(108, 0, "escape character '~' must be followed with '0' or '1'", nullptr));
                }
            }

            // finally, store the reference token
            detail::unescape(reference_token);
            result.push_back(reference_token);
        }

        return result;
    }

  private:
    /*!
    @param[in] reference_string  the reference string to the current value
    @param[in] value             the value to consider
    @param[in,out] result        the result object to insert values to

    @note Empty objects or arrays are flattened to `null`.
    */
    template<typename BasicJsonType>
    static void flatten(const string_t& reference_string,
                        const BasicJsonType& value,
                        BasicJsonType& result)
    {
        switch (value.type())
        {
            case detail::value_t::array:
            {
                if (value.m_data.m_value.array->empty())
                {
                    // flatten empty array as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate array and use index as a reference string
                    for (std::size_t i = 0; i < value.m_data.m_value.array->size(); ++i)
                    {
                        flatten(detail::concat<string_t>(reference_string, '/', std::to_string(i)),
                                value.m_data.m_value.array->operator[](i), result);
                    }
                }
                break;
            }

            case detail::value_t::object:
            {
                if (value.m_data.m_value.object->empty())
                {
                    // flatten empty object as null
                    result[reference_string] = nullptr;
                }
                else
                {
                    // iterate object and use keys as reference string
                    for (const auto& element : *value.m_data.m_value.object)
                    {
                        flatten(detail::concat<string_t>(reference_string, '/', detail::escape(element.first)), element.second, result);
                    }
                }
                break;
            }

            case detail::value_t::null:
            case detail::value_t::string:
            case detail::value_t::boolean:
            case detail::value_t::number_integer:
            case detail::value_t::number_unsigned:
            case detail::value_t::number_float:
            case detail::value_t::binary:
            case detail::value_t::discarded:
            default:
            {
                // add a primitive value with its reference string
                result[reference_string] = value;
                break;
            }
        }
    }

    /*!
    @param[in] value  flattened JSON

    @return unflattened JSON

    @throw parse_error.109 if array index is not a number
    @throw type_error.314  if value is not an object
    @throw type_error.315  if object values are not primitive
    @throw type_error.313  if value cannot be unflattened
    */
    template<typename BasicJsonType>
    static BasicJsonType
    unflatten(const BasicJsonType& value)
    {
        if (JSON_HEDLEY_UNLIKELY(!value.is_object()))
        {
            JSON_THROW(detail::type_error::create(314, "only objects can be unflattened", &value));
        }

        BasicJsonType result;

        // iterate the JSON object values
        for (const auto& element : *value.m_data.m_value.object)
        {
            if (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))
            {
                JSON_THROW(detail::type_error::create(315, "values in object must be primitive", &element.second));
            }

            // Assign the value to the reference pointed to by JSON pointer. Note
            // that if the JSON pointer is "" (i.e., points to the whole value),
            // function get_and_create returns a reference to the result itself.
            // An assignment will then create a primitive value.
            json_pointer(element.first).get_and_create(result) = element.second;
        }

        return result;
    }

    // can't use the conversion operator because of ambiguity
    json_pointer<string_t> convert() const&
    {
        json_pointer<string_t> result;
        result.reference_tokens = reference_tokens;
        return result;
    }

    json_pointer<string_t> convert()&&
    {
        json_pointer<string_t> result;
        result.reference_tokens = std::move(reference_tokens);
        return result;
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs>
    bool operator==(const json_pointer<RefStringTypeRhs>& rhs) const noexcept
    {
        return reference_tokens == rhs.reference_tokens;
    }

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer))
    bool operator==(const string_t& rhs) const
    {
        return *this == json_pointer(rhs);
    }

    /// @brief 3-way compares two JSON pointers
    template<typename RefStringTypeRhs>
    std::strong_ordering operator<=>(const json_pointer<RefStringTypeRhs>& rhs) const noexcept // *NOPAD*
    {
        return  reference_tokens <=> rhs.reference_tokens; // *NOPAD*
    }
#else
    /// @brief compares two JSON pointers for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for equality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_eq/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator==(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointers for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs) noexcept;

    /// @brief compares JSON pointer and string for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeLhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                           const StringType& rhs);

    /// @brief compares string and JSON pointer for inequality
    /// @sa https://json.nlohmann.me/api/json_pointer/operator_ne/
    template<typename RefStringTypeRhs, typename StringType>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator!=(const StringType& lhs,
                           const json_pointer<RefStringTypeRhs>& rhs);

    /// @brief compares two JSON pointer for less-than
    template<typename RefStringTypeLhs, typename RefStringTypeRhs>
    // NOLINTNEXTLINE(readability-redundant-declaration)
    friend bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                          const json_pointer<RefStringTypeRhs>& rhs) noexcept;
#endif

  private:
    /// the reference tokens
    std::vector<string_t> reference_tokens;
};

#if !JSON_HAS_THREE_WAY_COMPARISON
// functions cannot be defined inside the class due to ODR violations
template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens == rhs.reference_tokens;
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return lhs == json_pointer<RefStringTypeLhs>(rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator==(json_pointer, json_pointer))
inline bool operator==(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return json_pointer<RefStringTypeRhs>(lhs) == rhs;
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs,
         typename StringType = typename json_pointer<RefStringTypeLhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const json_pointer<RefStringTypeLhs>& lhs,
                       const StringType& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeRhs,
         typename StringType = typename json_pointer<RefStringTypeRhs>::string_t>
JSON_HEDLEY_DEPRECATED_FOR(3.11.2, operator!=(json_pointer, json_pointer))
inline bool operator!=(const StringType& lhs,
                       const json_pointer<RefStringTypeRhs>& rhs)
{
    return !(lhs == rhs);
}

template<typename RefStringTypeLhs, typename RefStringTypeRhs>
inline bool operator<(const json_pointer<RefStringTypeLhs>& lhs,
                      const json_pointer<RefStringTypeRhs>& rhs) noexcept
{
    return lhs.reference_tokens < rhs.reference_tokens;
}
#endif

NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/json_ref.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <initializer_list>
#include <utility>

// #include <nlohmann/detail/abi_macros.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

template<typename BasicJsonType>
class json_ref
{
  public:
    using value_type = BasicJsonType;

    json_ref(value_type&& value)
        : owned_value(std::move(value))
    {}

    json_ref(const value_type& value)
        : value_ref(&value)
    {}

    json_ref(std::initializer_list<json_ref> init)
        : owned_value(init)
    {}

    template <
        class... Args,
        enable_if_t<std::is_constructible<value_type, Args...>::value, int> = 0 >
    json_ref(Args && ... args)
        : owned_value(std::forward<Args>(args)...)
    {}

    // class should be movable only
    json_ref(json_ref&&) noexcept = default;
    json_ref(const json_ref&) = delete;
    json_ref& operator=(const json_ref&) = delete;
    json_ref& operator=(json_ref&&) = delete;
    ~json_ref() = default;

    value_type moved_or_copied() const
    {
        if (value_ref == nullptr)
        {
            return std::move(owned_value);
        }
        return *value_ref;
    }

    value_type const& operator*() const
    {
        return value_ref ? *value_ref : owned_value;
    }

    value_type const* operator->() const
    {
        return &** this;
    }

  private:
    mutable value_type owned_value = nullptr;
    value_type const* value_ref = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/string_escape.hpp>

// #include <nlohmann/detail/string_utils.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // reverse
#include <array> // array
#include <map> // map
#include <cmath> // isnan, isinf
#include <cstdint> // uint8_t, uint16_t, uint32_t, uint64_t
#include <cstring> // memcpy
#include <limits> // numeric_limits
#include <string> // string
#include <utility> // move
#include <vector> // vector

// #include <nlohmann/detail/input/binary_reader.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // copy
#include <cstddef> // size_t
#include <iterator> // back_inserter
#include <memory> // shared_ptr, make_shared
#include <string> // basic_string
#include <vector> // vector

#ifndef JSON_NO_IO
    #include <ios>      // streamsize
    #include <ostream>  // basic_ostream
#endif  // JSON_NO_IO

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// abstract output adapter interface
template<typename CharType> struct output_adapter_protocol
{
    virtual void write_character(CharType c) = 0;
    virtual void write_characters(const CharType* s, std::size_t length) = 0;
    virtual ~output_adapter_protocol() = default;

    output_adapter_protocol() = default;
    output_adapter_protocol(const output_adapter_protocol&) = default;
    output_adapter_protocol(output_adapter_protocol&&) noexcept = default;
    output_adapter_protocol& operator=(const output_adapter_protocol&) = default;
    output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;
};

/// a type to simplify interfaces
template<typename CharType>
using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;

/// output adapter for byte vectors
template<typename CharType, typename AllocatorType = std::allocator<CharType>>
class output_vector_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_vector_adapter(std::vector<CharType, AllocatorType>& vec) noexcept
        : v(vec)
    {}

    void write_character(CharType c) override
    {
        v.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        v.insert(v.end(), s, s + length);
    }

  private:
    std::vector<CharType, AllocatorType>& v;
};

#ifndef JSON_NO_IO
/// output adapter for output streams
template<typename CharType>
class output_stream_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_stream_adapter(std::basic_ostream<CharType>& s) noexcept
        : stream(s)
    {}

    void write_character(CharType c) override
    {
        stream.put(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        stream.write(s, static_cast<std::streamsize>(length));
    }

  private:
    std::basic_ostream<CharType>& stream;
};
#endif  // JSON_NO_IO

/// output adapter for basic_string
template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_string_adapter : public output_adapter_protocol<CharType>
{
  public:
    explicit output_string_adapter(StringType& s) noexcept
        : str(s)
    {}

    void write_character(CharType c) override
    {
        str.push_back(c);
    }

    JSON_HEDLEY_NON_NULL(2)
    void write_characters(const CharType* s, std::size_t length) override
    {
        str.append(s, length);
    }

  private:
    StringType& str;
};

template<typename CharType, typename StringType = std::basic_string<CharType>>
class output_adapter
{
  public:
    template<typename AllocatorType = std::allocator<CharType>>
    output_adapter(std::vector<CharType, AllocatorType>& vec)
        : oa(std::make_shared<output_vector_adapter<CharType, AllocatorType>>(vec)) {}

#ifndef JSON_NO_IO
    output_adapter(std::basic_ostream<CharType>& s)
        : oa(std::make_shared<output_stream_adapter<CharType>>(s)) {}
#endif  // JSON_NO_IO

    output_adapter(StringType& s)
        : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) {}

    operator output_adapter_t<CharType>()
    {
        return oa;
    }

  private:
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/string_concat.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/// how to encode BJData
enum class bjdata_version_t
{
    draft2,
    draft3,
};

///////////////////
// binary writer //
///////////////////

/*!
@brief serialization to CBOR and MessagePack values
*/
template<typename BasicJsonType, typename CharType>
class binary_writer
{
    using string_t = typename BasicJsonType::string_t;
    using binary_t = typename BasicJsonType::binary_t;
    using number_float_t = typename BasicJsonType::number_float_t;

  public:
    /*!
    @brief create a binary writer

    @param[in] adapter  output adapter to write to
    */
    explicit binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))
    {
        JSON_ASSERT(oa);
    }

    /*!
    @param[in] j  JSON value to serialize
    @pre       j.type() == value_t::object
    */
    void write_bson(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
            {
                write_bson_object(*j.m_data.m_value.object);
                break;
            }

            case value_t::null:
            case value_t::array:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                JSON_THROW(type_error::create(317, concat("to serialize to BSON, top-level type must be object, but is ", j.type_name()), &j));
            }
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_cbor(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null:
            {
                oa->write_character(to_char_type(0xF6));
                break;
            }

            case value_t::boolean:
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xF5)
                                    : to_char_type(0xF4));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // CBOR does not differentiate between positive signed
                    // integers and unsigned integers. Therefore, we used the
                    // code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_integer <= 0x17)
                    {
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x18));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x19));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x1A));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x1B));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    // The conversions below encode the sign in the first
                    // byte, and the value is converted to a positive number.
                    const auto positive_number = -1 - j.m_data.m_value.number_integer;
                    if (j.m_data.m_value.number_integer >= -24)
                    {
                        write_number(static_cast<std::uint8_t>(0x20 + positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        oa->write_character(to_char_type(0x38));
                        write_number(static_cast<std::uint8_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        oa->write_character(to_char_type(0x39));
                        write_number(static_cast<std::uint16_t>(positive_number));
                    }
                    else if (positive_number <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        oa->write_character(to_char_type(0x3A));
                        write_number(static_cast<std::uint32_t>(positive_number));
                    }
                    else
                    {
                        oa->write_character(to_char_type(0x3B));
                        write_number(static_cast<std::uint64_t>(positive_number));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x18));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x19));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_unsigned));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x1A));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_unsigned));
                }
                else
                {
                    oa->write_character(to_char_type(0x1B));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned));
                }
                break;
            }

            case value_t::number_float:
            {
                if (std::isnan(j.m_data.m_value.number_float))
                {
                    // NaN is 0xf97e00 in CBOR
                    oa->write_character(to_char_type(0xF9));
                    oa->write_character(to_char_type(0x7E));
                    oa->write_character(to_char_type(0x00));
                }
                else if (std::isinf(j.m_data.m_value.number_float))
                {
                    // Infinity is 0xf97c00, -Infinity is 0xf9fc00
                    oa->write_character(to_char_type(0xf9));
                    oa->write_character(j.m_data.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));
                    oa->write_character(to_char_type(0x00));
                }
                else
                {
                    write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::cbor);
                }
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x60 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x78));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x79));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x7A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x7B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x80 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x98));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x99));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x9A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x9B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_cbor(el);
                }
                break;
            }

            case value_t::binary:
            {
                if (j.m_data.m_value.binary->has_subtype())
                {
                    if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd8));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xd9));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xda));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.binary->subtype()));
                    }
                    else if (j.m_data.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        write_number(static_cast<std::uint8_t>(0xdb));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.binary->subtype()));
                    }
                }

                // step 1: write control byte and the binary array size
                const auto N = j.m_data.m_value.binary->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0x40 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0x58));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0x59));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0x5A));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0x5B));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 0x17)
                {
                    write_number(static_cast<std::uint8_t>(0xA0 + N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    oa->write_character(to_char_type(0xB8));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    oa->write_character(to_char_type(0xB9));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    oa->write_character(to_char_type(0xBA));
                    write_number(static_cast<std::uint32_t>(N));
                }
                // LCOV_EXCL_START
                else if (N <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    oa->write_character(to_char_type(0xBB));
                    write_number(static_cast<std::uint64_t>(N));
                }
                // LCOV_EXCL_STOP

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_cbor(el.first);
                    write_cbor(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    */
    void write_msgpack(const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::null: // nil
            {
                oa->write_character(to_char_type(0xC0));
                break;
            }

            case value_t::boolean: // true and false
            {
                oa->write_character(j.m_data.m_value.boolean
                                    ? to_char_type(0xC3)
                                    : to_char_type(0xC2));
                break;
            }

            case value_t::number_integer:
            {
                if (j.m_data.m_value.number_integer >= 0)
                {
                    // MessagePack does not differentiate between positive
                    // signed integers and unsigned integers. Therefore, we used
                    // the code from the value_t::number_unsigned case here.
                    if (j.m_data.m_value.number_unsigned < 128)
                    {
                        // positive fixnum
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                    {
                        // uint 8
                        oa->write_character(to_char_type(0xCC));
                        write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                    {
                        // uint 16
                        oa->write_character(to_char_type(0xCD));
                        write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                    {
                        // uint 32
                        oa->write_character(to_char_type(0xCE));
                        write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                    {
                        // uint 64
                        oa->write_character(to_char_type(0xCF));
                        write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                    }
                }
                else
                {
                    if (j.m_data.m_value.number_integer >= -32)
                    {
                        // negative fixnum
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                    {
                        // int 8
                        oa->write_character(to_char_type(0xD0));
                        write_number(static_cast<std::int8_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                    {
                        // int 16
                        oa->write_character(to_char_type(0xD1));
                        write_number(static_cast<std::int16_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                    {
                        // int 32
                        oa->write_character(to_char_type(0xD2));
                        write_number(static_cast<std::int32_t>(j.m_data.m_value.number_integer));
                    }
                    else if (j.m_data.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&
                             j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                    {
                        // int 64
                        oa->write_character(to_char_type(0xD3));
                        write_number(static_cast<std::int64_t>(j.m_data.m_value.number_integer));
                    }
                }
                break;
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned < 128)
                {
                    // positive fixnum
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // uint 8
                    oa->write_character(to_char_type(0xCC));
                    write_number(static_cast<std::uint8_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // uint 16
                    oa->write_character(to_char_type(0xCD));
                    write_number(static_cast<std::uint16_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // uint 32
                    oa->write_character(to_char_type(0xCE));
                    write_number(static_cast<std::uint32_t>(j.m_data.m_value.number_integer));
                }
                else if (j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    // uint 64
                    oa->write_character(to_char_type(0xCF));
                    write_number(static_cast<std::uint64_t>(j.m_data.m_value.number_integer));
                }
                break;
            }

            case value_t::number_float:
            {
                write_compact_float(j.m_data.m_value.number_float, detail::input_format_t::msgpack);
                break;
            }

            case value_t::string:
            {
                // step 1: write control byte and the string length
                const auto N = j.m_data.m_value.string->size();
                if (N <= 31)
                {
                    // fixstr
                    write_number(static_cast<std::uint8_t>(0xA0 | N));
                }
                else if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    // str 8
                    oa->write_character(to_char_type(0xD9));
                    write_number(static_cast<std::uint8_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // str 16
                    oa->write_character(to_char_type(0xDA));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // str 32
                    oa->write_character(to_char_type(0xDB));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write the string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                // step 1: write control byte and the array size
                const auto N = j.m_data.m_value.array->size();
                if (N <= 15)
                {
                    // fixarray
                    write_number(static_cast<std::uint8_t>(0x90 | N));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // array 16
                    oa->write_character(to_char_type(0xDC));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // array 32
                    oa->write_character(to_char_type(0xDD));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_msgpack(el);
                }
                break;
            }

            case value_t::binary:
            {
                // step 0: determine if the binary type has a set subtype to
                // determine whether to use the ext or fixext types
                const bool use_ext = j.m_data.m_value.binary->has_subtype();

                // step 1: write control byte and the byte string length
                const auto N = j.m_data.m_value.binary->size();
                if (N <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    std::uint8_t output_type{};
                    bool fixed = true;
                    if (use_ext)
                    {
                        switch (N)
                        {
                            case 1:
                                output_type = 0xD4; // fixext 1
                                break;
                            case 2:
                                output_type = 0xD5; // fixext 2
                                break;
                            case 4:
                                output_type = 0xD6; // fixext 4
                                break;
                            case 8:
                                output_type = 0xD7; // fixext 8
                                break;
                            case 16:
                                output_type = 0xD8; // fixext 16
                                break;
                            default:
                                output_type = 0xC7; // ext 8
                                fixed = false;
                                break;
                        }

                    }
                    else
                    {
                        output_type = 0xC4; // bin 8
                        fixed = false;
                    }

                    oa->write_character(to_char_type(output_type));
                    if (!fixed)
                    {
                        write_number(static_cast<std::uint8_t>(N));
                    }
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC8 // ext 16
                                                     : 0xC5; // bin 16

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    const std::uint8_t output_type = use_ext
                                                     ? 0xC9 // ext 32
                                                     : 0xC6; // bin 32

                    oa->write_character(to_char_type(output_type));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 1.5: if this is an ext type, write the subtype
                if (use_ext)
                {
                    write_number(static_cast<std::int8_t>(j.m_data.m_value.binary->subtype()));
                }

                // step 2: write the byte string
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                    N);

                break;
            }

            case value_t::object:
            {
                // step 1: write control byte and the object size
                const auto N = j.m_data.m_value.object->size();
                if (N <= 15)
                {
                    // fixmap
                    write_number(static_cast<std::uint8_t>(0x80 | (N & 0xF)));
                }
                else if (N <= (std::numeric_limits<std::uint16_t>::max)())
                {
                    // map 16
                    oa->write_character(to_char_type(0xDE));
                    write_number(static_cast<std::uint16_t>(N));
                }
                else if (N <= (std::numeric_limits<std::uint32_t>::max)())
                {
                    // map 32
                    oa->write_character(to_char_type(0xDF));
                    write_number(static_cast<std::uint32_t>(N));
                }

                // step 2: write each element
                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_msgpack(el.first);
                    write_msgpack(el.second);
                }
                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

    /*!
    @param[in] j  JSON value to serialize
    @param[in] use_count   whether to use '#' prefixes (optimized format)
    @param[in] use_type    whether to use '$' prefixes (optimized format)
    @param[in] add_prefix  whether prefixes need to be used for this value
    @param[in] use_bjdata  whether write in BJData format, default is false
    @param[in] bjdata_version  which BJData version to use, default is draft2
    */
    void write_ubjson(const BasicJsonType& j, const bool use_count,
                      const bool use_type, const bool add_prefix = true,
                      const bool use_bjdata = false, const bjdata_version_t bjdata_version = bjdata_version_t::draft2)
    {
        const bool bjdata_draft3 = use_bjdata && bjdata_version == bjdata_version_t::draft3;

        switch (j.type())
        {
            case value_t::null:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('Z'));
                }
                break;
            }

            case value_t::boolean:
            {
                if (add_prefix)
                {
                    oa->write_character(j.m_data.m_value.boolean
                                        ? to_char_type('T')
                                        : to_char_type('F'));
                }
                break;
            }

            case value_t::number_integer:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_integer, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_unsigned:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_unsigned, add_prefix, use_bjdata);
                break;
            }

            case value_t::number_float:
            {
                write_number_with_ubjson_prefix(j.m_data.m_value.number_float, add_prefix, use_bjdata);
                break;
            }

            case value_t::string:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('S'));
                }
                write_number_with_ubjson_prefix(j.m_data.m_value.string->size(), true, use_bjdata);
                oa->write_characters(
                    reinterpret_cast<const CharType*>(j.m_data.m_value.string->c_str()),
                    j.m_data.m_value.string->size());
                break;
            }

            case value_t::array:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.array->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin() + 1, j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.array->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.array)
                {
                    write_ubjson(el, use_count, use_type, prefix_required, use_bjdata, bjdata_version);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::binary:
            {
                if (add_prefix)
                {
                    oa->write_character(to_char_type('['));
                }

                if (use_type && (bjdata_draft3 || !j.m_data.m_value.binary->empty()))
                {
                    JSON_ASSERT(use_count);
                    oa->write_character(to_char_type('$'));
                    oa->write_character(bjdata_draft3 ? 'B' : 'U');
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.binary->size(), true, use_bjdata);
                }

                if (use_type)
                {
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(j.m_data.m_value.binary->data()),
                        j.m_data.m_value.binary->size());
                }
                else
                {
                    for (size_t i = 0; i < j.m_data.m_value.binary->size(); ++i)
                    {
                        oa->write_character(to_char_type(bjdata_draft3 ? 'B' : 'U'));
                        oa->write_character(j.m_data.m_value.binary->data()[i]);
                    }
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type(']'));
                }

                break;
            }

            case value_t::object:
            {
                if (use_bjdata && j.m_data.m_value.object->size() == 3 && j.m_data.m_value.object->find("_ArrayType_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArraySize_") != j.m_data.m_value.object->end() && j.m_data.m_value.object->find("_ArrayData_") != j.m_data.m_value.object->end())
                {
                    if (!write_bjdata_ndarray(*j.m_data.m_value.object, use_count, use_type, bjdata_version))  // decode bjdata ndarray in the JData format (https://github.com/NeuroJSON/jdata)
                    {
                        break;
                    }
                }

                if (add_prefix)
                {
                    oa->write_character(to_char_type('{'));
                }

                bool prefix_required = true;
                if (use_type && !j.m_data.m_value.object->empty())
                {
                    JSON_ASSERT(use_count);
                    const CharType first_prefix = ubjson_prefix(j.front(), use_bjdata);
                    const bool same_prefix = std::all_of(j.begin(), j.end(),
                                                         [this, first_prefix, use_bjdata](const BasicJsonType & v)
                    {
                        return ubjson_prefix(v, use_bjdata) == first_prefix;
                    });

                    std::vector<CharType> bjdx = {'[', '{', 'S', 'H', 'T', 'F', 'N', 'Z'}; // excluded markers in bjdata optimized type

                    if (same_prefix && !(use_bjdata && std::find(bjdx.begin(), bjdx.end(), first_prefix) != bjdx.end()))
                    {
                        prefix_required = false;
                        oa->write_character(to_char_type('$'));
                        oa->write_character(first_prefix);
                    }
                }

                if (use_count)
                {
                    oa->write_character(to_char_type('#'));
                    write_number_with_ubjson_prefix(j.m_data.m_value.object->size(), true, use_bjdata);
                }

                for (const auto& el : *j.m_data.m_value.object)
                {
                    write_number_with_ubjson_prefix(el.first.size(), true, use_bjdata);
                    oa->write_characters(
                        reinterpret_cast<const CharType*>(el.first.c_str()),
                        el.first.size());
                    write_ubjson(el.second, use_count, use_type, prefix_required, use_bjdata, bjdata_version);
                }

                if (!use_count)
                {
                    oa->write_character(to_char_type('}'));
                }

                break;
            }

            case value_t::discarded:
            default:
                break;
        }
    }

  private:
    //////////
    // BSON //
    //////////

    /*!
    @return The size of a BSON document entry header, including the id marker
            and the entry name size (and its null-terminator).
    */
    static std::size_t calc_bson_entry_header_size(const string_t& name, const BasicJsonType& j)
    {
        const auto it = name.find(static_cast<typename string_t::value_type>(0));
        if (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))
        {
            JSON_THROW(out_of_range::create(409, concat("BSON key cannot contain code point U+0000 (at byte ", std::to_string(it), ")"), &j));
        }

        static_cast<void>(j);
        return /*id*/ 1ul + name.size() + /*zero-terminator*/1u;
    }

    /*!
    @brief Writes the given @a element_type and @a name to the output adapter
    */
    void write_bson_entry_header(const string_t& name,
                                 const std::uint8_t element_type)
    {
        oa->write_character(to_char_type(element_type)); // boolean
        oa->write_characters(
            reinterpret_cast<const CharType*>(name.c_str()),
            name.size() + 1u);
    }

    /*!
    @brief Writes a BSON element with key @a name and boolean value @a value
    */
    void write_bson_boolean(const string_t& name,
                            const bool value)
    {
        write_bson_entry_header(name, 0x08);
        oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and double value @a value
    */
    void write_bson_double(const string_t& name,
                           const double value)
    {
        write_bson_entry_header(name, 0x01);
        write_number<double>(value, true);
    }

    /*!
    @return The size of the BSON-encoded string in @a value
    */
    static std::size_t calc_bson_string_size(const string_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and string value @a value
    */
    void write_bson_string(const string_t& name,
                           const string_t& value)
    {
        write_bson_entry_header(name, 0x02);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size() + 1ul), true);
        oa->write_characters(
            reinterpret_cast<const CharType*>(value.c_str()),
            value.size() + 1);
    }

    /*!
    @brief Writes a BSON element with key @a name and null value
    */
    void write_bson_null(const string_t& name)
    {
        write_bson_entry_header(name, 0x0A);
    }

    /*!
    @return The size of the BSON-encoded integer @a value
    */
    static std::size_t calc_bson_integer_size(const std::int64_t value)
    {
        return (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and integer @a value
    */
    void write_bson_integer(const string_t& name,
                            const std::int64_t value)
    {
        if ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())
        {
            write_bson_entry_header(name, 0x10); // int32
            write_number<std::int32_t>(static_cast<std::int32_t>(value), true);
        }
        else
        {
            write_bson_entry_header(name, 0x12); // int64
            write_number<std::int64_t>(static_cast<std::int64_t>(value), true);
        }
    }

    /*!
    @return The size of the BSON-encoded unsigned integer in @a j
    */
    static constexpr std::size_t calc_bson_unsigned_size(const std::uint64_t value) noexcept
    {
        return (value <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
               ? sizeof(std::int32_t)
               : sizeof(std::int64_t);
    }

    /*!
    @brief Writes a BSON element with key @a name and unsigned @a value
    */
    void write_bson_unsigned(const string_t& name,
                             const BasicJsonType& j)
    {
        if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            write_bson_entry_header(name, 0x10 /* int32 */);
            write_number<std::int32_t>(static_cast<std::int32_t>(j.m_data.m_value.number_unsigned), true);
        }
        else if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            write_bson_entry_header(name, 0x12 /* int64 */);
            write_number<std::int64_t>(static_cast<std::int64_t>(j.m_data.m_value.number_unsigned), true);
        }
        else
        {
            write_bson_entry_header(name, 0x11 /* uint64 */);
            write_number<std::uint64_t>(static_cast<std::uint64_t>(j.m_data.m_value.number_unsigned), true);
        }
    }

    /*!
    @brief Writes a BSON element with key @a name and object @a value
    */
    void write_bson_object_entry(const string_t& name,
                                 const typename BasicJsonType::object_t& value)
    {
        write_bson_entry_header(name, 0x03); // object
        write_bson_object(value);
    }

    /*!
    @return The size of the BSON-encoded array @a value
    */
    static std::size_t calc_bson_array_size(const typename BasicJsonType::array_t& value)
    {
        std::size_t array_index = 0ul;

        const std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), static_cast<std::size_t>(0), [&array_index](std::size_t result, const typename BasicJsonType::array_t::value_type & el)
        {
            return result + calc_bson_element_size(std::to_string(array_index++), el);
        });

        return sizeof(std::int32_t) + embedded_document_size + 1ul;
    }

    /*!
    @return The size of the BSON-encoded binary array @a value
    */
    static std::size_t calc_bson_binary_size(const typename BasicJsonType::binary_t& value)
    {
        return sizeof(std::int32_t) + value.size() + 1ul;
    }

    /*!
    @brief Writes a BSON element with key @a name and array @a value
    */
    void write_bson_array(const string_t& name,
                          const typename BasicJsonType::array_t& value)
    {
        write_bson_entry_header(name, 0x04); // array
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_array_size(value)), true);

        std::size_t array_index = 0ul;

        for (const auto& el : value)
        {
            write_bson_element(std::to_string(array_index++), el);
        }

        oa->write_character(to_char_type(0x00));
    }

    /*!
    @brief Writes a BSON element with key @a name and binary value @a value
    */
    void write_bson_binary(const string_t& name,
                           const binary_t& value)
    {
        write_bson_entry_header(name, 0x05);

        write_number<std::int32_t>(static_cast<std::int32_t>(value.size()), true);
        write_number(value.has_subtype() ? static_cast<std::uint8_t>(value.subtype()) : static_cast<std::uint8_t>(0x00));

        oa->write_characters(reinterpret_cast<const CharType*>(value.data()), value.size());
    }

    /*!
    @brief Calculates the size necessary to serialize the JSON value @a j with its @a name
    @return The calculated size for the BSON document entry for @a j with the given @a name.
    */
    static std::size_t calc_bson_element_size(const string_t& name,
            const BasicJsonType& j)
    {
        const auto header_size = calc_bson_entry_header_size(name, j);
        switch (j.type())
        {
            case value_t::object:
                return header_size + calc_bson_object_size(*j.m_data.m_value.object);

            case value_t::array:
                return header_size + calc_bson_array_size(*j.m_data.m_value.array);

            case value_t::binary:
                return header_size + calc_bson_binary_size(*j.m_data.m_value.binary);

            case value_t::boolean:
                return header_size + 1ul;

            case value_t::number_float:
                return header_size + 8ul;

            case value_t::number_integer:
                return header_size + calc_bson_integer_size(j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return header_size + calc_bson_unsigned_size(j.m_data.m_value.number_unsigned);

            case value_t::string:
                return header_size + calc_bson_string_size(*j.m_data.m_value.string);

            case value_t::null:
                return header_size + 0ul;

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return 0ul;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Serializes the JSON value @a j to BSON and associates it with the
           key @a name.
    @param name The name to associate with the JSON entity @a j within the
                current BSON document
    */
    void write_bson_element(const string_t& name,
                            const BasicJsonType& j)
    {
        switch (j.type())
        {
            case value_t::object:
                return write_bson_object_entry(name, *j.m_data.m_value.object);

            case value_t::array:
                return write_bson_array(name, *j.m_data.m_value.array);

            case value_t::binary:
                return write_bson_binary(name, *j.m_data.m_value.binary);

            case value_t::boolean:
                return write_bson_boolean(name, j.m_data.m_value.boolean);

            case value_t::number_float:
                return write_bson_double(name, j.m_data.m_value.number_float);

            case value_t::number_integer:
                return write_bson_integer(name, j.m_data.m_value.number_integer);

            case value_t::number_unsigned:
                return write_bson_unsigned(name, j);

            case value_t::string:
                return write_bson_string(name, *j.m_data.m_value.string);

            case value_t::null:
                return write_bson_null(name);

            // LCOV_EXCL_START
            case value_t::discarded:
            default:
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)
                return;
                // LCOV_EXCL_STOP
        }
    }

    /*!
    @brief Calculates the size of the BSON serialization of the given
           JSON-object @a j.
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    static std::size_t calc_bson_object_size(const typename BasicJsonType::object_t& value)
    {
        const std::size_t document_size = std::accumulate(value.begin(), value.end(), static_cast<std::size_t>(0),
                                          [](size_t result, const typename BasicJsonType::object_t::value_type & el)
        {
            return result += calc_bson_element_size(el.first, el.second);
        });

        return sizeof(std::int32_t) + document_size + 1ul;
    }

    /*!
    @param[in] value  JSON value to serialize
    @pre       value.type() == value_t::object
    */
    void write_bson_object(const typename BasicJsonType::object_t& value)
    {
        write_number<std::int32_t>(static_cast<std::int32_t>(calc_bson_object_size(value)), true);

        for (const auto& el : value)
        {
            write_bson_element(el.first, el.second);
        }

        oa->write_character(to_char_type(0x00));
    }

    //////////
    // CBOR //
    //////////

    static constexpr CharType get_cbor_float_prefix(float /*unused*/)
    {
        return to_char_type(0xFA);  // Single-Precision Float
    }

    static constexpr CharType get_cbor_float_prefix(double /*unused*/)
    {
        return to_char_type(0xFB);  // Double-Precision Float
    }

    /////////////
    // MsgPack //
    /////////////

    static constexpr CharType get_msgpack_float_prefix(float /*unused*/)
    {
        return to_char_type(0xCA);  // float 32
    }

    static constexpr CharType get_msgpack_float_prefix(double /*unused*/)
    {
        return to_char_type(0xCB);  // float 64
    }

    ////////////
    // UBJSON //
    ////////////

    // UBJSON: write number (floating point)
    template<typename NumberType, typename std::enable_if<
                 std::is_floating_point<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (add_prefix)
        {
            oa->write_character(get_ubjson_float_prefix(n));
        }
        write_number(n, use_bjdata);
    }

    // UBJSON: write number (unsigned integer)
    template<typename NumberType, typename std::enable_if<
                 std::is_unsigned<NumberType>::value, int>::type = 0>
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= (std::numeric_limits<std::uint8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint16_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<std::uint16_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= static_cast<uint64_t>((std::numeric_limits<uint32_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<std::uint32_t>(n), use_bjdata);
        }
        else if (n <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        else if (use_bjdata && n <= (std::numeric_limits<uint64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('M'));  // uint64 - bjdata only
            }
            write_number(static_cast<std::uint64_t>(n), use_bjdata);
        }
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
    }

    // UBJSON: write number (signed integer)
    template < typename NumberType, typename std::enable_if <
                   std::is_signed<NumberType>::value&&
                   !std::is_floating_point<NumberType>::value, int >::type = 0 >
    void write_number_with_ubjson_prefix(const NumberType n,
                                         const bool add_prefix,
                                         const bool use_bjdata)
    {
        if ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('i'));  // int8
            }
            write_number(static_cast<std::int8_t>(n), use_bjdata);
        }
        else if (static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint8_t>::max)()))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('U'));  // uint8
            }
            write_number(static_cast<std::uint8_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('I'));  // int16
            }
            write_number(static_cast<std::int16_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint16_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('u'));  // uint16 - bjdata only
            }
            write_number(static_cast<uint16_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('l'));  // int32
            }
            write_number(static_cast<std::int32_t>(n), use_bjdata);
        }
        else if (use_bjdata && (static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::min)()) <= n && n <= static_cast<std::int64_t>((std::numeric_limits<std::uint32_t>::max)())))
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('m'));  // uint32 - bjdata only
            }
            write_number(static_cast<uint32_t>(n), use_bjdata);
        }
        else if ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('L'));  // int64
            }
            write_number(static_cast<std::int64_t>(n), use_bjdata);
        }
        // LCOV_EXCL_START
        else
        {
            if (add_prefix)
            {
                oa->write_character(to_char_type('H'));  // high-precision number
            }

            const auto number = BasicJsonType(n).dump();
            write_number_with_ubjson_prefix(number.size(), true, use_bjdata);
            for (std::size_t i = 0; i < number.size(); ++i)
            {
                oa->write_character(to_char_type(static_cast<std::uint8_t>(number[i])));
            }
        }
        // LCOV_EXCL_STOP
    }

    /*!
    @brief determine the type prefix of container values
    */
    CharType ubjson_prefix(const BasicJsonType& j, const bool use_bjdata) const noexcept
    {
        switch (j.type())
        {
            case value_t::null:
                return 'Z';

            case value_t::boolean:
                return j.m_data.m_value.boolean ? 'T' : 'F';

            case value_t::number_integer:
            {
                if ((std::numeric_limits<std::int8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())
                {
                    return 'i';
                }
                if ((std::numeric_limits<std::uint8_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())
                {
                    return 'U';
                }
                if ((std::numeric_limits<std::int16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())
                {
                    return 'I';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint16_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if ((std::numeric_limits<std::int32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())
                {
                    return 'l';
                }
                if (use_bjdata && ((std::numeric_limits<std::uint32_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if ((std::numeric_limits<std::int64_t>::min)() <= j.m_data.m_value.number_integer && j.m_data.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())
                {
                    return 'L';
                }
                // anything else is treated as a high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_unsigned:
            {
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int8_t>::max)()))
                {
                    return 'i';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint8_t>::max)()))
                {
                    return 'U';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int16_t>::max)()))
                {
                    return 'I';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint16_t>::max)()))
                {
                    return 'u';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int32_t>::max)()))
                {
                    return 'l';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::uint32_t>::max)()))
                {
                    return 'm';
                }
                if (j.m_data.m_value.number_unsigned <= static_cast<std::uint64_t>((std::numeric_limits<std::int64_t>::max)()))
                {
                    return 'L';
                }
                if (use_bjdata && j.m_data.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())
                {
                    return 'M';
                }
                // anything else is treated as a high-precision number
                return 'H'; // LCOV_EXCL_LINE
            }

            case value_t::number_float:
                return get_ubjson_float_prefix(j.m_data.m_value.number_float);

            case value_t::string:
                return 'S';

            case value_t::array: // fallthrough
            case value_t::binary:
                return '[';

            case value_t::object:
                return '{';

            case value_t::discarded:
            default:  // discarded values
                return 'N';
        }
    }

    static constexpr CharType get_ubjson_float_prefix(float /*unused*/)
    {
        return 'd';  // float 32
    }

    static constexpr CharType get_ubjson_float_prefix(double /*unused*/)
    {
        return 'D';  // float 64
    }

    /*!
    @return false if the object is successfully converted to a bjdata ndarray, true if the type or size is invalid
    */
    bool write_bjdata_ndarray(const typename BasicJsonType::object_t& value, const bool use_count, const bool use_type, const bjdata_version_t bjdata_version)
    {
        std::map<string_t, CharType> bjdtype = {{"uint8", 'U'},  {"int8", 'i'},  {"uint16", 'u'}, {"int16", 'I'},
            {"uint32", 'm'}, {"int32", 'l'}, {"uint64", 'M'}, {"int64", 'L'}, {"single", 'd'}, {"double", 'D'},
            {"char", 'C'}, {"byte", 'B'}
        };

        string_t key = "_ArrayType_";
        auto it = bjdtype.find(static_cast<string_t>(value.at(key)));
        if (it == bjdtype.end())
        {
            return true;
        }
        CharType dtype = it->second;

        key = "_ArraySize_";
        std::size_t len = (value.at(key).empty() ? 0 : 1);
        for (const auto& el : value.at(key))
        {
            len *= static_cast<std::size_t>(el.m_data.m_value.number_unsigned);
        }

        key = "_ArrayData_";
        if (value.at(key).size() != len)
        {
            return true;
        }

        oa->write_character('[');
        oa->write_character('$');
        oa->write_character(dtype);
        oa->write_character('#');

        key = "_ArraySize_";
        write_ubjson(value.at(key), use_count, use_type, true,  true, bjdata_version);

        key = "_ArrayData_";
        if (dtype == 'U' || dtype == 'C' || dtype == 'B')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint8_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'i')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int8_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'u')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint16_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'I')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int16_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'm')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint32_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'l')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int32_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'M')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::uint64_t>(el.m_data.m_value.number_unsigned), true);
            }
        }
        else if (dtype == 'L')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<std::int64_t>(el.m_data.m_value.number_integer), true);
            }
        }
        else if (dtype == 'd')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<float>(el.m_data.m_value.number_float), true);
            }
        }
        else if (dtype == 'D')
        {
            for (const auto& el : value.at(key))
            {
                write_number(static_cast<double>(el.m_data.m_value.number_float), true);
            }
        }
        return false;
    }

    ///////////////////////
    // Utility functions //
    ///////////////////////

    /*
    @brief write a number to output input
    @param[in] n number of type @a NumberType
    @param[in] OutputIsLittleEndian Set to true if output data is
                                 required to be little endian
    @tparam NumberType the type of the number

    @note This function needs to respect the system's endianness, because bytes
          in CBOR, MessagePack, and UBJSON are stored in network order (big
          endian) and therefore need reordering on little endian systems.
          On the other hand, BSON and BJData use little endian and should reorder
          on big endian systems.
    */
    template<typename NumberType>
    void write_number(const NumberType n, const bool OutputIsLittleEndian = false)
    {
        // step 1: write the number to an array of length NumberType
        std::array<CharType, sizeof(NumberType)> vec{};
        std::memcpy(vec.data(), &n, sizeof(NumberType));

        // step 2: write the array to output (with possible reordering)
        if (is_little_endian != OutputIsLittleEndian)
        {
            // reverse byte order prior to conversion if necessary
            std::reverse(vec.begin(), vec.end());
        }

        oa->write_characters(vec.data(), sizeof(NumberType));
    }

    void write_compact_float(const number_float_t n, detail::input_format_t format)
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        if (!std::isfinite(n) || ((static_cast<double>(n) >= static_cast<double>(std::numeric_limits<float>::lowest()) &&
                                   static_cast<double>(n) <= static_cast<double>((std::numeric_limits<float>::max)()) &&
                                   static_cast<double>(static_cast<float>(n)) == static_cast<double>(n))))
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(static_cast<float>(n))
                                : get_msgpack_float_prefix(static_cast<float>(n)));
            write_number(static_cast<float>(n));
        }
        else
        {
            oa->write_character(format == detail::input_format_t::cbor
                                ? get_cbor_float_prefix(n)
                                : get_msgpack_float_prefix(n));
            write_number(n);
        }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

  public:
    // The following to_char_type functions are implement the conversion
    // between uint8_t and CharType. In case CharType is not unsigned,
    // such a conversion is required to allow values greater than 128.
    // See <https://github.com/nlohmann/json/issues/1286> for a discussion.
    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = nullptr >
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return *reinterpret_cast<char*>(&x);
    }

    template < typename C = CharType,
               enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = nullptr >
    static CharType to_char_type(std::uint8_t x) noexcept
    {
        // The std::is_trivial trait is deprecated in C++26. The replacement is to use
        // std::is_trivially_copyable and std::is_trivially_default_constructible.
        // However, some older library implementations support std::is_trivial
        // but not all the std::is_trivially_* traits.
        // Since detecting full support across all libraries is difficult,
        // we use std::is_trivial unless we are using a standard where it has been deprecated.
        // For more details, see: https://github.com/nlohmann/json/pull/4775#issuecomment-2884361627
#ifdef JSON_HAS_CPP_26
        static_assert(std::is_trivially_copyable<CharType>::value, "CharType must be trivially copyable");
        static_assert(std::is_trivially_default_constructible<CharType>::value, "CharType must be trivially default constructible");
#else
        static_assert(std::is_trivial<CharType>::value, "CharType must be trivial");
#endif

        static_assert(sizeof(std::uint8_t) == sizeof(CharType), "size of CharType must be equal to std::uint8_t");
        CharType result;
        std::memcpy(&result, &x, sizeof(x));
        return result;
    }

    template<typename C = CharType,
             enable_if_t<std::is_unsigned<C>::value>* = nullptr>
    static constexpr CharType to_char_type(std::uint8_t x) noexcept
    {
        return x;
    }

    template < typename InputCharType, typename C = CharType,
               enable_if_t <
                   std::is_signed<C>::value &&
                   std::is_signed<char>::value &&
                   std::is_same<char, typename std::remove_cv<InputCharType>::type>::value
                   > * = nullptr >
    static constexpr CharType to_char_type(InputCharType x) noexcept
    {
        return x;
    }

  private:
    /// whether we can assume little endianness
    const bool is_little_endian = little_endianness();

    /// the output
    output_adapter_t<CharType> oa = nullptr;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/output/serializer.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2008, 2009 Björn Hoehrmann <bjoern@hoehrmann.de>
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <algorithm> // reverse, remove, fill, find, none_of
#include <array> // array
#include <clocale> // localeconv, lconv
#include <cmath> // labs, isfinite, isnan, signbit
#include <cstddef> // size_t, ptrdiff_t
#include <cstdint> // uint8_t
#include <cstdio> // snprintf
#include <limits> // numeric_limits
#include <string> // string, char_traits
#include <iomanip> // setfill, setw
#include <type_traits> // is_same
#include <utility> // move

// #include <nlohmann/detail/conversions/to_chars.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2009 Florian Loitsch <https://florian.loitsch.com/>
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <array> // array
#include <cmath>   // signbit, isfinite
#include <cstdint> // intN_t, uintN_t
#include <cstring> // memcpy, memmove
#include <limits> // numeric_limits
#include <type_traits> // conditional

// #include <nlohmann/detail/macro_scope.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

/*!
@brief implements the Grisu2 algorithm for binary to decimal floating-point
conversion.

This implementation is a slightly modified version of the reference
implementation which may be obtained from
http://florian.loitsch.com/publications (bench.tar.gz).

The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.

For a detailed description of the algorithm see:

[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming
    Language Design and Implementation, PLDI 2010
[2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately",
    Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language
    Design and Implementation, PLDI 1996
*/
namespace dtoa_impl
{

template<typename Target, typename Source>
Target reinterpret_bits(const Source source)
{
    static_assert(sizeof(Target) == sizeof(Source), "size mismatch");

    Target target;
    std::memcpy(&target, &source, sizeof(Source));
    return target;
}

struct diyfp // f * 2^e
{
    static constexpr int kPrecision = 64; // = q

    std::uint64_t f = 0;
    int e = 0;

    constexpr diyfp(std::uint64_t f_, int e_) noexcept : f(f_), e(e_) {}

    /*!
    @brief returns x - y
    @pre x.e == y.e and x.f >= y.f
    */
    static diyfp sub(const diyfp& x, const diyfp& y) noexcept
    {
        JSON_ASSERT(x.e == y.e);
        JSON_ASSERT(x.f >= y.f);

        return {x.f - y.f, x.e};
    }

    /*!
    @brief returns x * y
    @note The result is rounded. (Only the upper q bits are returned.)
    */
    static diyfp mul(const diyfp& x, const diyfp& y) noexcept
    {
        static_assert(kPrecision == 64, "internal error");

        // Computes:
        //  f = round((x.f * y.f) / 2^q)
        //  e = x.e + y.e + q

        // Emulate the 64-bit * 64-bit multiplication:
        //
        // p = u * v
        //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)
        //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )
        //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )
        //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )
        //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)
        //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )
        //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )
        //
        // (Since Q might be larger than 2^32 - 1)
        //
        //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)
        //
        // (Q_hi + H does not overflow a 64-bit int)
        //
        //   = p_lo + 2^64 p_hi

        const std::uint64_t u_lo = x.f & 0xFFFFFFFFu;
        const std::uint64_t u_hi = x.f >> 32u;
        const std::uint64_t v_lo = y.f & 0xFFFFFFFFu;
        const std::uint64_t v_hi = y.f >> 32u;

        const std::uint64_t p0 = u_lo * v_lo;
        const std::uint64_t p1 = u_lo * v_hi;
        const std::uint64_t p2 = u_hi * v_lo;
        const std::uint64_t p3 = u_hi * v_hi;

        const std::uint64_t p0_hi = p0 >> 32u;
        const std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;
        const std::uint64_t p1_hi = p1 >> 32u;
        const std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;
        const std::uint64_t p2_hi = p2 >> 32u;

        std::uint64_t Q = p0_hi + p1_lo + p2_lo;

        // The full product might now be computed as
        //
        // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)
        // p_lo = p0_lo + (Q << 32)
        //
        // But in this particular case here, the full p_lo is not required.
        // Effectively, we only need to add the highest bit in p_lo to p_hi (and
        // Q_hi + 1 does not overflow).

        Q += std::uint64_t{1} << (64u - 32u - 1u); // round, ties up

        const std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);

        return {h, x.e + y.e + 64};
    }

    /*!
    @brief normalize x such that the significand is >= 2^(q-1)
    @pre x.f != 0
    */
    static diyfp normalize(diyfp x) noexcept
    {
        JSON_ASSERT(x.f != 0);

        while ((x.f >> 63u) == 0)
        {
            x.f <<= 1u;
            x.e--;
        }

        return x;
    }

    /*!
    @brief normalize x such that the result has the exponent E
    @pre e >= x.e and the upper e - x.e bits of x.f must be zero.
    */
    static diyfp normalize_to(const diyfp& x, const int target_exponent) noexcept
    {
        const int delta = x.e - target_exponent;

        JSON_ASSERT(delta >= 0);
        JSON_ASSERT(((x.f << delta) >> delta) == x.f);

        return {x.f << delta, target_exponent};
    }
};

struct boundaries
{
    diyfp w;
    diyfp minus;
    diyfp plus;
};

/*!
Compute the (normalized) diyfp representing the input number 'value' and its
boundaries.

@pre value must be finite and positive
*/
template<typename FloatType>
boundaries compute_boundaries(FloatType value)
{
    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // Convert the IEEE representation into a diyfp.
    //
    // If v is denormal:
    //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))
    // If v is normalized:
    //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))

    static_assert(std::numeric_limits<FloatType>::is_iec559,
                  "internal error: dtoa_short requires an IEEE-754 floating-point implementation");

    constexpr int      kPrecision = std::numeric_limits<FloatType>::digits; // = p (includes the hidden bit)
    constexpr int      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);
    constexpr int      kMinExp    = 1 - kBias;
    constexpr std::uint64_t kHiddenBit = std::uint64_t{1} << (kPrecision - 1); // = 2^(p-1)

    using bits_type = typename std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;

    const auto bits = static_cast<std::uint64_t>(reinterpret_bits<bits_type>(value));
    const std::uint64_t E = bits >> (kPrecision - 1);
    const std::uint64_t F = bits & (kHiddenBit - 1);

    const bool is_denormal = E == 0;
    const diyfp v = is_denormal
                    ? diyfp(F, kMinExp)
                    : diyfp(F + kHiddenBit, static_cast<int>(E) - kBias);

    // Compute the boundaries m- and m+ of the floating-point value
    // v = f * 2^e.
    //
    // Determine v- and v+, the floating-point predecessor and successor of v,
    // respectively.
    //
    //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)
    //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)
    //
    //      v+ = v + 2^e
    //
    // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_
    // between m- and m+ round to v, regardless of how the input rounding
    // algorithm breaks ties.
    //
    //      ---+-------------+-------------+-------------+-------------+---  (A)
    //         v-            m-            v             m+            v+
    //
    //      -----------------+------+------+-------------+-------------+---  (B)
    //                       v-     m-     v             m+            v+

    const bool lower_boundary_is_closer = F == 0 && E > 1;
    const diyfp m_plus = diyfp((2 * v.f) + 1, v.e - 1);
    const diyfp m_minus = lower_boundary_is_closer
                          ? diyfp((4 * v.f) - 1, v.e - 2)  // (B)
                          : diyfp((2 * v.f) - 1, v.e - 1); // (A)

    // Determine the normalized w+ = m+.
    const diyfp w_plus = diyfp::normalize(m_plus);

    // Determine w- = m- such that e_(w-) = e_(w+).
    const diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);

    return {diyfp::normalize(v), w_minus, w_plus};
}

// Given normalized diyfp w, Grisu needs to find a (normalized) cached
// power-of-ten c, such that the exponent of the product c * w = f * 2^e lies
// within a certain range [alpha, gamma] (Definition 3.2 from [1])
//
//      alpha <= e = e_c + e_w + q <= gamma
//
// or
//
//      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q
//                          <= f_c * f_w * 2^gamma
//
// Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies
//
//      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma
//
// or
//
//      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)
//
// The choice of (alpha,gamma) determines the size of the table and the form of
// the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well
// in practice:
//
// The idea is to cut the number c * w = f * 2^e into two parts, which can be
// processed independently: An integral part p1, and a fractional part p2:
//
//      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e
//              = (f div 2^-e) + (f mod 2^-e) * 2^e
//              = p1 + p2 * 2^e
//
// The conversion of p1 into decimal form requires a series of divisions and
// modulos by (a power of) 10. These operations are faster for 32-bit than for
// 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be
// achieved by choosing
//
//      -e >= 32   or   e <= -32 := gamma
//
// In order to convert the fractional part
//
//      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...
//
// into decimal form, the fraction is repeatedly multiplied by 10 and the digits
// d[-i] are extracted in order:
//
//      (10 * p2) div 2^-e = d[-1]
//      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...
//
// The multiplication by 10 must not overflow. It is sufficient to choose
//
//      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.
//
// Since p2 = f mod 2^-e < 2^-e,
//
//      -e <= 60   or   e >= -60 := alpha

constexpr int kAlpha = -60;
constexpr int kGamma = -32;

struct cached_power // c = f * 2^e ~= 10^k
{
    std::uint64_t f;
    int e;
    int k;
};

/*!
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached
power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c
satisfies (Definition 3.2 from [1])

     alpha <= e_c + e + q <= gamma.
*/
inline cached_power get_cached_power_for_binary_exponent(int e)
{
    // Now
    //
    //      alpha <= e_c + e + q <= gamma                                    (1)
    //      ==> f_c * 2^alpha <= c * 2^e * 2^q
    //
    // and since the c's are normalized, 2^(q-1) <= f_c,
    //
    //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)
    //      ==> 2^(alpha - e - 1) <= c
    //
    // If c were an exact power of ten, i.e. c = 10^k, one may determine k as
    //
    //      k = ceil( log_10( 2^(alpha - e - 1) ) )
    //        = ceil( (alpha - e - 1) * log_10(2) )
    //
    // From the paper:
    // "In theory the result of the procedure could be wrong since c is rounded,
    //  and the computation itself is approximated [...]. In practice, however,
    //  this simple function is sufficient."
    //
    // For IEEE double precision floating-point numbers converted into
    // normalized diyfp's w = f * 2^e, with q = 64,
    //
    //      e >= -1022      (min IEEE exponent)
    //           -52        (p - 1)
    //           -52        (p - 1, possibly normalize denormal IEEE numbers)
    //           -11        (normalize the diyfp)
    //         = -1137
    //
    // and
    //
    //      e <= +1023      (max IEEE exponent)
    //           -52        (p - 1)
    //           -11        (normalize the diyfp)
    //         = 960
    //
    // This binary exponent range [-1137,960] results in a decimal exponent
    // range [-307,324]. One does not need to store a cached power for each
    // k in this range. For each such k it suffices to find a cached power
    // such that the exponent of the product lies in [alpha,gamma].
    // This implies that the difference of the decimal exponents of adjacent
    // table entries must be less than or equal to
    //
    //      floor( (gamma - alpha) * log_10(2) ) = 8.
    //
    // (A smaller distance gamma-alpha would require a larger table.)

    // NB:
    // Actually, this function returns c, such that -60 <= e_c + e + 64 <= -34.

    constexpr int kCachedPowersMinDecExp = -300;
    constexpr int kCachedPowersDecStep = 8;

    static constexpr std::array<cached_power, 79> kCachedPowers =
    {
        {
            { 0xAB70FE17C79AC6CA, -1060, -300 },
            { 0xFF77B1FCBEBCDC4F, -1034, -292 },
            { 0xBE5691EF416BD60C, -1007, -284 },
            { 0x8DD01FAD907FFC3C,  -980, -276 },
            { 0xD3515C2831559A83,  -954, -268 },
            { 0x9D71AC8FADA6C9B5,  -927, -260 },
            { 0xEA9C227723EE8BCB,  -901, -252 },
            { 0xAECC49914078536D,  -874, -244 },
            { 0x823C12795DB6CE57,  -847, -236 },
            { 0xC21094364DFB5637,  -821, -228 },
            { 0x9096EA6F3848984F,  -794, -220 },
            { 0xD77485CB25823AC7,  -768, -212 },
            { 0xA086CFCD97BF97F4,  -741, -204 },
            { 0xEF340A98172AACE5,  -715, -196 },
            { 0xB23867FB2A35B28E,  -688, -188 },
            { 0x84C8D4DFD2C63F3B,  -661, -180 },
            { 0xC5DD44271AD3CDBA,  -635, -172 },
            { 0x936B9FCEBB25C996,  -608, -164 },
            { 0xDBAC6C247D62A584,  -582, -156 },
            { 0xA3AB66580D5FDAF6,  -555, -148 },
            { 0xF3E2F893DEC3F126,  -529, -140 },
            { 0xB5B5ADA8AAFF80B8,  -502, -132 },
            { 0x87625F056C7C4A8B,  -475, -124 },
            { 0xC9BCFF6034C13053,  -449, -116 },
            { 0x964E858C91BA2655,  -422, -108 },
            { 0xDFF9772470297EBD,  -396, -100 },
            { 0xA6DFBD9FB8E5B88F,  -369,  -92 },
            { 0xF8A95FCF88747D94,  -343,  -84 },
            { 0xB94470938FA89BCF,  -316,  -76 },
            { 0x8A08F0F8BF0F156B,  -289,  -68 },
            { 0xCDB02555653131B6,  -263,  -60 },
            { 0x993FE2C6D07B7FAC,  -236,  -52 },
            { 0xE45C10C42A2B3B06,  -210,  -44 },
            { 0xAA242499697392D3,  -183,  -36 },
            { 0xFD87B5F28300CA0E,  -157,  -28 },
            { 0xBCE5086492111AEB,  -130,  -20 },
            { 0x8CBCCC096F5088CC,  -103,  -12 },
            { 0xD1B71758E219652C,   -77,   -4 },
            { 0x9C40000000000000,   -50,    4 },
            { 0xE8D4A51000000000,   -24,   12 },
            { 0xAD78EBC5AC620000,     3,   20 },
            { 0x813F3978F8940984,    30,   28 },
            { 0xC097CE7BC90715B3,    56,   36 },
            { 0x8F7E32CE7BEA5C70,    83,   44 },
            { 0xD5D238A4ABE98068,   109,   52 },
            { 0x9F4F2726179A2245,   136,   60 },
            { 0xED63A231D4C4FB27,   162,   68 },
            { 0xB0DE65388CC8ADA8,   189,   76 },
            { 0x83C7088E1AAB65DB,   216,   84 },
            { 0xC45D1DF942711D9A,   242,   92 },
            { 0x924D692CA61BE758,   269,  100 },
            { 0xDA01EE641A708DEA,   295,  108 },
            { 0xA26DA3999AEF774A,   322,  116 },
            { 0xF209787BB47D6B85,   348,  124 },
            { 0xB454E4A179DD1877,   375,  132 },
            { 0x865B86925B9BC5C2,   402,  140 },
            { 0xC83553C5C8965D3D,   428,  148 },
            { 0x952AB45CFA97A0B3,   455,  156 },
            { 0xDE469FBD99A05FE3,   481,  164 },
            { 0xA59BC234DB398C25,   508,  172 },
            { 0xF6C69A72A3989F5C,   534,  180 },
            { 0xB7DCBF5354E9BECE,   561,  188 },
            { 0x88FCF317F22241E2,   588,  196 },
            { 0xCC20CE9BD35C78A5,   614,  204 },
            { 0x98165AF37B2153DF,   641,  212 },
            { 0xE2A0B5DC971F303A,   667,  220 },
            { 0xA8D9D1535CE3B396,   694,  228 },
            { 0xFB9B7CD9A4A7443C,   720,  236 },
            { 0xBB764C4CA7A44410,   747,  244 },
            { 0x8BAB8EEFB6409C1A,   774,  252 },
            { 0xD01FEF10A657842C,   800,  260 },
            { 0x9B10A4E5E9913129,   827,  268 },
            { 0xE7109BFBA19C0C9D,   853,  276 },
            { 0xAC2820D9623BF429,   880,  284 },
            { 0x80444B5E7AA7CF85,   907,  292 },
            { 0xBF21E44003ACDD2D,   933,  300 },
            { 0x8E679C2F5E44FF8F,   960,  308 },
            { 0xD433179D9C8CB841,   986,  316 },
            { 0x9E19DB92B4E31BA9,  1013,  324 },
        }
    };

    // This computation gives exactly the same results for k as
    //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)
    // for |e| <= 1500, but doesn't require floating-point operations.
    // NB: log_10(2) ~= 78913 / 2^18
    JSON_ASSERT(e >= -1500);
    JSON_ASSERT(e <=  1500);
    const int f = kAlpha - e - 1;
    const int k = ((f * 78913) / (1 << 18)) + static_cast<int>(f > 0);

    const int index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;
    JSON_ASSERT(index >= 0);
    JSON_ASSERT(static_cast<std::size_t>(index) < kCachedPowers.size());

    const cached_power cached = kCachedPowers[static_cast<std::size_t>(index)];
    JSON_ASSERT(kAlpha <= cached.e + e + 64);
    JSON_ASSERT(kGamma >= cached.e + e + 64);

    return cached;
}

/*!
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k.
For n == 0, returns 1 and sets pow10 := 1.
*/
inline int find_largest_pow10(const std::uint32_t n, std::uint32_t& pow10)
{
    // LCOV_EXCL_START
    if (n >= 1000000000)
    {
        pow10 = 1000000000;
        return 10;
    }
    // LCOV_EXCL_STOP
    if (n >= 100000000)
    {
        pow10 = 100000000;
        return  9;
    }
    if (n >= 10000000)
    {
        pow10 = 10000000;
        return  8;
    }
    if (n >= 1000000)
    {
        pow10 = 1000000;
        return  7;
    }
    if (n >= 100000)
    {
        pow10 = 100000;
        return  6;
    }
    if (n >= 10000)
    {
        pow10 = 10000;
        return  5;
    }
    if (n >= 1000)
    {
        pow10 = 1000;
        return  4;
    }
    if (n >= 100)
    {
        pow10 = 100;
        return  3;
    }
    if (n >= 10)
    {
        pow10 = 10;
        return  2;
    }

    pow10 = 1;
    return 1;
}

inline void grisu2_round(char* buf, int len, std::uint64_t dist, std::uint64_t delta,
                         std::uint64_t rest, std::uint64_t ten_k)
{
    JSON_ASSERT(len >= 1);
    JSON_ASSERT(dist <= delta);
    JSON_ASSERT(rest <= delta);
    JSON_ASSERT(ten_k > 0);

    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    //                                  ten_k
    //                                <------>
    //                                       <---- rest ---->
    // --------------[------------------+----+--------------]--------------
    //                                  w    V
    //                                       = buf * 10^k
    //
    // ten_k represents a unit-in-the-last-place in the decimal representation
    // stored in buf.
    // Decrement buf by ten_k while this takes buf closer to w.

    // The tests are written in this order to avoid overflow in unsigned
    // integer arithmetic.

    while (rest < dist
            && delta - rest >= ten_k
            && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))
    {
        JSON_ASSERT(buf[len - 1] != '0');
        buf[len - 1]--;
        rest += ten_k;
    }
}

/*!
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+.
M- and M+ must be normalized and share the same exponent -60 <= e <= -32.
*/
inline void grisu2_digit_gen(char* buffer, int& length, int& decimal_exponent,
                             diyfp M_minus, diyfp w, diyfp M_plus)
{
    static_assert(kAlpha >= -60, "internal error");
    static_assert(kGamma <= -32, "internal error");

    // Generates the digits (and the exponent) of a decimal floating-point
    // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's
    // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.
    //
    //               <--------------------------- delta ---->
    //                                  <---- dist --------->
    // --------------[------------------+-------------------]--------------
    //               M-                 w                   M+
    //
    // Grisu2 generates the digits of M+ from left to right and stops as soon as
    // V is in [M-,M+].

    JSON_ASSERT(M_plus.e >= kAlpha);
    JSON_ASSERT(M_plus.e <= kGamma);

    std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; // (significand of (M+ - M-), implicit exponent is e)
    std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; // (significand of (M+ - w ), implicit exponent is e)

    // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):
    //
    //      M+ = f * 2^e
    //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e
    //         = ((p1        ) * 2^-e + (p2        )) * 2^e
    //         = p1 + p2 * 2^e

    const diyfp one(std::uint64_t{1} << -M_plus.e, M_plus.e);

    auto p1 = static_cast<std::uint32_t>(M_plus.f >> -one.e); // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)
    std::uint64_t p2 = M_plus.f & (one.f - 1);                    // p2 = f mod 2^-e

    // 1)
    //
    // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]

    JSON_ASSERT(p1 > 0);

    std::uint32_t pow10{};
    const int k = find_largest_pow10(p1, pow10);

    //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)
    //
    //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))
    //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))
    //
    //      M+ = p1                                             + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e
    //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e
    //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e
    //
    // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)
    //
    //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]
    //
    // but stop as soon as
    //
    //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e

    int n = k;
    while (n > 0)
    {
        // Invariants:
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)
        //      pow10 = 10^(n-1) <= p1 < 10^n
        //
        const std::uint32_t d = p1 / pow10;  // d = p1 div 10^(n-1)
        const std::uint32_t r = p1 % pow10;  // r = p1 mod 10^(n-1)
        //
        //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e
        //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)
        //
        p1 = r;
        n--;
        //
        //      M+ = buffer * 10^n + (p1 + p2 * 2^e)
        //      pow10 = 10^n
        //

        // Now check if enough digits have been generated.
        // Compute
        //
        //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e
        //
        // Note:
        // Since rest and delta share the same exponent e, it suffices to
        // compare the significands.
        const std::uint64_t rest = (std::uint64_t{p1} << -one.e) + p2;
        if (rest <= delta)
        {
            // V = buffer * 10^n, with M- <= V <= M+.

            decimal_exponent += n;

            // We may now just stop. But instead, it looks as if the buffer
            // could be decremented to bring V closer to w.
            //
            // pow10 = 10^n is now 1 ulp in the decimal representation V.
            // The rounding procedure works with diyfp's with an implicit
            // exponent of e.
            //
            //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e
            //
            const std::uint64_t ten_n = std::uint64_t{pow10} << -one.e;
            grisu2_round(buffer, length, dist, delta, rest, ten_n);

            return;
        }

        pow10 /= 10;
        //
        //      pow10 = 10^(n-1) <= p1 < 10^n
        // Invariants restored.
    }

    // 2)
    //
    // The digits of the integral part have been generated:
    //
    //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e
    //         = buffer            + p2 * 2^e
    //
    // Now generate the digits of the fractional part p2 * 2^e.
    //
    // Note:
    // No decimal point is generated: the exponent is adjusted instead.
    //
    // p2 actually represents the fraction
    //
    //      p2 * 2^e
    //          = p2 / 2^-e
    //          = d[-1] / 10^1 + d[-2] / 10^2 + ...
    //
    // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)
    //
    //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m
    //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)
    //
    // using
    //
    //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)
    //                = (                   d) * 2^-e + (                   r)
    //
    // or
    //      10^m * p2 * 2^e = d + r * 2^e
    //
    // i.e.
    //
    //      M+ = buffer + p2 * 2^e
    //         = buffer + 10^-m * (d + r * 2^e)
    //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e
    //
    // and stop as soon as 10^-m * r * 2^e <= delta * 2^e

    JSON_ASSERT(p2 > delta);

    int m = 0;
    for (;;)
    {
        // Invariant:
        //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e
        //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e
        //
        JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);
        p2 *= 10;
        const std::uint64_t d = p2 >> -one.e;     // d = (10 * p2) div 2^-e
        const std::uint64_t r = p2 & (one.f - 1); // r = (10 * p2) mod 2^-e
        //
        //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e
        //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))
        //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        JSON_ASSERT(d <= 9);
        buffer[length++] = static_cast<char>('0' + d); // buffer := buffer * 10 + d
        //
        //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e
        //
        p2 = r;
        m++;
        //
        //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e
        // Invariant restored.

        // Check if enough digits have been generated.
        //
        //      10^-m * p2 * 2^e <= delta * 2^e
        //              p2 * 2^e <= 10^m * delta * 2^e
        //                    p2 <= 10^m * delta
        delta *= 10;
        dist  *= 10;
        if (p2 <= delta)
        {
            break;
        }
    }

    // V = buffer * 10^-m, with M- <= V <= M+.

    decimal_exponent -= m;

    // 1 ulp in the decimal representation is now 10^-m.
    // Since delta and dist are now scaled by 10^m, we need to do the
    // same with ulp in order to keep the units in sync.
    //
    //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e
    //
    const std::uint64_t ten_m = one.f;
    grisu2_round(buffer, length, dist, delta, p2, ten_m);

    // By construction this algorithm generates the shortest possible decimal
    // number (Loitsch, Theorem 6.2) which rounds back to w.
    // For an input number of precision p, at least
    //
    //      N = 1 + ceil(p * log_10(2))
    //
    // decimal digits are sufficient to identify all binary floating-point
    // numbers (Matula, "In-and-Out conversions").
    // This implies that the algorithm does not produce more than N decimal
    // digits.
    //
    //      N = 17 for p = 53 (IEEE double precision)
    //      N = 9  for p = 24 (IEEE single precision)
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
JSON_HEDLEY_NON_NULL(1)
inline void grisu2(char* buf, int& len, int& decimal_exponent,
                   diyfp m_minus, diyfp v, diyfp m_plus)
{
    JSON_ASSERT(m_plus.e == m_minus.e);
    JSON_ASSERT(m_plus.e == v.e);

    //  --------(-----------------------+-----------------------)--------    (A)
    //          m-                      v                       m+
    //
    //  --------------------(-----------+-----------------------)--------    (B)
    //                      m-          v                       m+
    //
    // First scale v (and m- and m+) such that the exponent is in the range
    // [alpha, gamma].

    const cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);

    const diyfp c_minus_k(cached.f, cached.e); // = c ~= 10^-k

    // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]
    const diyfp w       = diyfp::mul(v,       c_minus_k);
    const diyfp w_minus = diyfp::mul(m_minus, c_minus_k);
    const diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);

    //  ----(---+---)---------------(---+---)---------------(---+---)----
    //          w-                      w                       w+
    //          = c*m-                  = c*v                   = c*m+
    //
    // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and
    // w+ are now off by a small amount.
    // In fact:
    //
    //      w - v * 10^k < 1 ulp
    //
    // To account for this inaccuracy, add resp. subtract 1 ulp.
    //
    //  --------+---[---------------(---+---)---------------]---+--------
    //          w-  M-                  w                   M+  w+
    //
    // Now any number in [M-, M+] (bounds included) will round to w when input,
    // regardless of how the input rounding algorithm breaks ties.
    //
    // And digit_gen generates the shortest possible such number in [M-, M+].
    // Note that this does not mean that Grisu2 always generates the shortest
    // possible number in the interval (m-, m+).
    const diyfp M_minus(w_minus.f + 1, w_minus.e);
    const diyfp M_plus (w_plus.f  - 1, w_plus.e );

    decimal_exponent = -cached.k; // = -(-k) = k

    grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);
}

/*!
v = buf * 10^decimal_exponent
len is the length of the buffer (number of decimal digits)
The buffer must be large enough, i.e. >= max_digits10.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1)
void grisu2(char* buf, int& len, int& decimal_exponent, FloatType value)
{
    static_assert(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,
                  "internal error: not enough precision");

    JSON_ASSERT(std::isfinite(value));
    JSON_ASSERT(value > 0);

    // If the neighbors (and boundaries) of 'value' are always computed for double-precision
    // numbers, all float's can be recovered using strtod (and strtof). However, the resulting
    // decimal representations are not exactly "short".
    //
    // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)
    // says "value is converted to a string as if by std::sprintf in the default ("C") locale"
    // and since sprintf promotes floats to doubles, I think this is exactly what 'std::to_chars'
    // does.
    // On the other hand, the documentation for 'std::to_chars' requires that "parsing the
    // representation using the corresponding std::from_chars function recovers value exactly". That
    // indicates that single precision floating-point numbers should be recovered using
    // 'std::strtof'.
    //
    // NB: If the neighbors are computed for single-precision numbers, there is a single float
    //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision
    //     value is off by 1 ulp.
#if 0 // NOLINT(readability-avoid-unconditional-preprocessor-if)
    const boundaries w = compute_boundaries(static_cast<double>(value));
#else
    const boundaries w = compute_boundaries(value);
#endif

    grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);
}

/*!
@brief appends a decimal representation of e to buf
@return a pointer to the element following the exponent.
@pre -1000 < e < 1000
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* append_exponent(char* buf, int e)
{
    JSON_ASSERT(e > -1000);
    JSON_ASSERT(e <  1000);

    if (e < 0)
    {
        e = -e;
        *buf++ = '-';
    }
    else
    {
        *buf++ = '+';
    }

    auto k = static_cast<std::uint32_t>(e);
    if (k < 10)
    {
        // Always print at least two digits in the exponent.
        // This is for compatibility with printf("%g").
        *buf++ = '0';
        *buf++ = static_cast<char>('0' + k);
    }
    else if (k < 100)
    {
        *buf++ = static_cast<char>('0' + (k / 10));
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }
    else
    {
        *buf++ = static_cast<char>('0' + (k / 100));
        k %= 100;
        *buf++ = static_cast<char>('0' + (k / 10));
        k %= 10;
        *buf++ = static_cast<char>('0' + k);
    }

    return buf;
}

/*!
@brief prettify v = buf * 10^decimal_exponent

If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point
notation. Otherwise it will be printed in exponential notation.

@pre min_exp < 0
@pre max_exp > 0
*/
JSON_HEDLEY_NON_NULL(1)
JSON_HEDLEY_RETURNS_NON_NULL
inline char* format_buffer(char* buf, int len, int decimal_exponent,
                           int min_exp, int max_exp)
{
    JSON_ASSERT(min_exp < 0);
    JSON_ASSERT(max_exp > 0);

    const int k = len;
    const int n = len + decimal_exponent;

    // v = buf * 10^(n-k)
    // k is the length of the buffer (number of decimal digits)
    // n is the position of the decimal point relative to the start of the buffer.

    if (k <= n && n <= max_exp)
    {
        // digits[000]
        // len <= max_exp + 2

        std::memset(buf + k, '0', static_cast<size_t>(n) - static_cast<size_t>(k));
        // Make it look like a floating-point number (#362, #378)
        buf[n + 0] = '.';
        buf[n + 1] = '0';
        return buf + (static_cast<size_t>(n) + 2);
    }

    if (0 < n && n <= max_exp)
    {
        // dig.its
        // len <= max_digits10 + 1

        JSON_ASSERT(k > n);

        std::memmove(buf + (static_cast<size_t>(n) + 1), buf + n, static_cast<size_t>(k) - static_cast<size_t>(n));
        buf[n] = '.';
        return buf + (static_cast<size_t>(k) + 1U);
    }

    if (min_exp < n && n <= 0)
    {
        // 0.[000]digits
        // len <= 2 + (-min_exp - 1) + max_digits10

        std::memmove(buf + (2 + static_cast<size_t>(-n)), buf, static_cast<size_t>(k));
        buf[0] = '0';
        buf[1] = '.';
        std::memset(buf + 2, '0', static_cast<size_t>(-n));
        return buf + (2U + static_cast<size_t>(-n) + static_cast<size_t>(k));
    }

    if (k == 1)
    {
        // dE+123
        // len <= 1 + 5

        buf += 1;
    }
    else
    {
        // d.igitsE+123
        // len <= max_digits10 + 1 + 5

        std::memmove(buf + 2, buf + 1, static_cast<size_t>(k) - 1);
        buf[1] = '.';
        buf += 1 + static_cast<size_t>(k);
    }

    *buf++ = 'e';
    return append_exponent(buf, n - 1);
}

}  // namespace dtoa_impl

/*!
@brief generates a decimal representation of the floating-point number value in [first, last).

The format of the resulting decimal representation is similar to printf's %g
format. Returns an iterator pointing past-the-end of the decimal representation.

@note The input number must be finite, i.e. NaN's and Inf's are not supported.
@note The buffer must be large enough.
@note The result is NOT null-terminated.
*/
template<typename FloatType>
JSON_HEDLEY_NON_NULL(1, 2)
JSON_HEDLEY_RETURNS_NON_NULL
char* to_chars(char* first, const char* last, FloatType value)
{
    static_cast<void>(last); // maybe unused - fix warning
    JSON_ASSERT(std::isfinite(value));

    // Use signbit(value) instead of (value < 0) since signbit works for -0.
    if (std::signbit(value))
    {
        value = -value;
        *first++ = '-';
    }

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
    if (value == 0) // +-0
    {
        *first++ = '0';
        // Make it look like a floating-point number (#362, #378)
        *first++ = '.';
        *first++ = '0';
        return first;
    }
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);

    // Compute v = buffer * 10^decimal_exponent.
    // The decimal digits are stored in the buffer, which needs to be interpreted
    // as an unsigned decimal integer.
    // len is the length of the buffer, i.e., the number of decimal digits.
    int len = 0;
    int decimal_exponent = 0;
    dtoa_impl::grisu2(first, len, decimal_exponent, value);

    JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);

    // Format the buffer like printf("%.*g", prec, value)
    constexpr int kMinExp = -4;
    // Use digits10 here to increase compatibility with version 2.
    constexpr int kMaxExp = std::numeric_limits<FloatType>::digits10;

    JSON_ASSERT(last - first >= kMaxExp + 2);
    JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);
    JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);

    return dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);
}

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/exceptions.hpp>

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/cpp_future.hpp>

// #include <nlohmann/detail/output/binary_writer.hpp>

// #include <nlohmann/detail/output/output_adapters.hpp>

// #include <nlohmann/detail/string_concat.hpp>

// #include <nlohmann/detail/value_t.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN
namespace detail
{

///////////////////
// serialization //
///////////////////

/// how to treat decoding errors
enum class error_handler_t
{
    strict,  ///< throw a type_error exception in case of invalid UTF-8
    replace, ///< replace invalid UTF-8 sequences with U+FFFD
    ignore   ///< ignore invalid UTF-8 sequences
};

template<typename BasicJsonType>
class serializer
{
    using string_t = typename BasicJsonType::string_t;
    using number_float_t = typename BasicJsonType::number_float_t;
    using number_integer_t = typename BasicJsonType::number_integer_t;
    using number_unsigned_t = typename BasicJsonType::number_unsigned_t;
    using binary_char_t = typename BasicJsonType::binary_t::value_type;
    static constexpr std::uint8_t UTF8_ACCEPT = 0;
    static constexpr std::uint8_t UTF8_REJECT = 1;

  public:
    /*!
    @param[in] s  output stream to serialize to
    @param[in] ichar  indentation character to use
    @param[in] error_handler_  how to react on decoding errors
    */
    serializer(output_adapter_t<char> s, const char ichar,
               error_handler_t error_handler_ = error_handler_t::strict)
        : o(std::move(s))
        , loc(std::localeconv())
        , thousands_sep(loc->thousands_sep == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))
        , decimal_point(loc->decimal_point == nullptr ? '\0' : std::char_traits<char>::to_char_type(* (loc->decimal_point)))
        , indent_char(ichar)
        , indent_string(512, indent_char)
        , error_handler(error_handler_)
    {}

    // deleted because of pointer members
    serializer(const serializer&) = delete;
    serializer& operator=(const serializer&) = delete;
    serializer(serializer&&) = delete;
    serializer& operator=(serializer&&) = delete;
    ~serializer() = default;

    /*!
    @brief internal implementation of the serialization function

    This function is called by the public member function dump and organizes
    the serialization internally. The indentation level is propagated as
    additional parameter. In case of arrays and objects, the function is
    called recursively.

    - strings and object keys are escaped using `escape_string()`
    - integer numbers are converted implicitly via `operator<<`
    - floating-point numbers are converted to a string using `"%g"` format
    - binary values are serialized as objects containing the subtype and the
      byte array

    @param[in] val               value to serialize
    @param[in] pretty_print      whether the output shall be pretty-printed
    @param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters
    in the output are escaped with `\uXXXX` sequences, and the result consists
    of ASCII characters only.
    @param[in] indent_step       the indent level
    @param[in] current_indent    the current indent level (only used internally)
    */
    void dump(const BasicJsonType& val,
              const bool pretty_print,
              const bool ensure_ascii,
              const unsigned int indent_step,
              const unsigned int current_indent = 0)
    {
        switch (val.m_data.m_type)
        {
            case value_t::object:
            {
                if (val.m_data.m_value.object->empty())
                {
                    o->write_characters("{}", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\": ", 3);
                        dump(i->second, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_characters(indent_string.c_str(), new_indent);
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\": ", 3);
                    dump(i->second, true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_character('{');

                    // first n-1 elements
                    auto i = val.m_data.m_value.object->cbegin();
                    for (std::size_t cnt = 0; cnt < val.m_data.m_value.object->size() - 1; ++cnt, ++i)
                    {
                        o->write_character('\"');
                        dump_escaped(i->first, ensure_ascii);
                        o->write_characters("\":", 2);
                        dump(i->second, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(i != val.m_data.m_value.object->cend());
                    JSON_ASSERT(std::next(i) == val.m_data.m_value.object->cend());
                    o->write_character('\"');
                    dump_escaped(i->first, ensure_ascii);
                    o->write_characters("\":", 2);
                    dump(i->second, false, ensure_ascii, indent_step, current_indent);

                    o->write_character('}');
                }

                return;
            }

            case value_t::array:
            {
                if (val.m_data.m_value.array->empty())
                {
                    o->write_characters("[]", 2);
                    return;
                }

                if (pretty_print)
                {
                    o->write_characters("[\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        o->write_characters(indent_string.c_str(), new_indent);
                        dump(*i, true, ensure_ascii, indent_step, new_indent);
                        o->write_characters(",\n", 2);
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    o->write_characters(indent_string.c_str(), new_indent);
                    dump(val.m_data.m_value.array->back(), true, ensure_ascii, indent_step, new_indent);

                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character(']');
                }
                else
                {
                    o->write_character('[');

                    // first n-1 elements
                    for (auto i = val.m_data.m_value.array->cbegin();
                            i != val.m_data.m_value.array->cend() - 1; ++i)
                    {
                        dump(*i, false, ensure_ascii, indent_step, current_indent);
                        o->write_character(',');
                    }

                    // last element
                    JSON_ASSERT(!val.m_data.m_value.array->empty());
                    dump(val.m_data.m_value.array->back(), false, ensure_ascii, indent_step, current_indent);

                    o->write_character(']');
                }

                return;
            }

            case value_t::string:
            {
                o->write_character('\"');
                dump_escaped(*val.m_data.m_value.string, ensure_ascii);
                o->write_character('\"');
                return;
            }

            case value_t::binary:
            {
                if (pretty_print)
                {
                    o->write_characters("{\n", 2);

                    // variable to hold indentation for recursive calls
                    const auto new_indent = current_indent + indent_step;
                    if (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))
                    {
                        indent_string.resize(indent_string.size() * 2, ' ');
                    }

                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"bytes\": [", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_characters(", ", 2);
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\n", 3);
                    o->write_characters(indent_string.c_str(), new_indent);

                    o->write_characters("\"subtype\": ", 11);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                    }
                    else
                    {
                        o->write_characters("null", 4);
                    }
                    o->write_character('\n');
                    o->write_characters(indent_string.c_str(), current_indent);
                    o->write_character('}');
                }
                else
                {
                    o->write_characters("{\"bytes\":[", 10);

                    if (!val.m_data.m_value.binary->empty())
                    {
                        for (auto i = val.m_data.m_value.binary->cbegin();
                                i != val.m_data.m_value.binary->cend() - 1; ++i)
                        {
                            dump_integer(*i);
                            o->write_character(',');
                        }
                        dump_integer(val.m_data.m_value.binary->back());
                    }

                    o->write_characters("],\"subtype\":", 12);
                    if (val.m_data.m_value.binary->has_subtype())
                    {
                        dump_integer(val.m_data.m_value.binary->subtype());
                        o->write_character('}');
                    }
                    else
                    {
                        o->write_characters("null}", 5);
                    }
                }
                return;
            }

            case value_t::boolean:
            {
                if (val.m_data.m_value.boolean)
                {
                    o->write_characters("true", 4);
                }
                else
                {
                    o->write_characters("false", 5);
                }
                return;
            }

            case value_t::number_integer:
            {
                dump_integer(val.m_data.m_value.number_integer);
                return;
            }

            case value_t::number_unsigned:
            {
                dump_integer(val.m_data.m_value.number_unsigned);
                return;
            }

            case value_t::number_float:
            {
                dump_float(val.m_data.m_value.number_float);
                return;
            }

            case value_t::discarded:
            {
                o->write_characters("<discarded>", 11);
                return;
            }

            case value_t::null:
            {
                o->write_characters("null", 4);
                return;
            }

            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief dump escaped string

    Escape a string by replacing certain special characters by a sequence of an
    escape character (backslash) and another character and other control
    characters by a sequence of "\u" followed by a four-digit hex
    representation. The escaped string is written to output stream @a o.

    @param[in] s  the string to escape
    @param[in] ensure_ascii  whether to escape non-ASCII characters with
                             \uXXXX sequences

    @complexity Linear in the length of string @a s.
    */
    void dump_escaped(const string_t& s, const bool ensure_ascii)
    {
        std::uint32_t codepoint{};
        std::uint8_t state = UTF8_ACCEPT;
        std::size_t bytes = 0;  // number of bytes written to string_buffer

        // number of bytes written at the point of the last valid byte
        std::size_t bytes_after_last_accept = 0;
        std::size_t undumped_chars = 0;

        for (std::size_t i = 0; i < s.size(); ++i)
        {
            const auto byte = static_cast<std::uint8_t>(s[i]);

            switch (decode(state, codepoint, byte))
            {
                case UTF8_ACCEPT:  // decode found a new code point
                {
                    switch (codepoint)
                    {
                        case 0x08: // backspace
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'b';
                            break;
                        }

                        case 0x09: // horizontal tab
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 't';
                            break;
                        }

                        case 0x0A: // newline
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'n';
                            break;
                        }

                        case 0x0C: // formfeed
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'f';
                            break;
                        }

                        case 0x0D: // carriage return
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = 'r';
                            break;
                        }

                        case 0x22: // quotation mark
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\"';
                            break;
                        }

                        case 0x5C: // reverse solidus
                        {
                            string_buffer[bytes++] = '\\';
                            string_buffer[bytes++] = '\\';
                            break;
                        }

                        default:
                        {
                            // escape control characters (0x00..0x1F) or, if
                            // ensure_ascii parameter is used, non-ASCII characters
                            if ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))
                            {
                                if (codepoint <= 0xFFFF)
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 7, "\\u%04x",
                                                                      static_cast<std::uint16_t>(codepoint)));
                                    bytes += 6;
                                }
                                else
                                {
                                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
                                    static_cast<void>((std::snprintf)(string_buffer.data() + bytes, 13, "\\u%04x\\u%04x",
                                                                      static_cast<std::uint16_t>(0xD7C0u + (codepoint >> 10u)),
                                                                      static_cast<std::uint16_t>(0xDC00u + (codepoint & 0x3FFu))));
                                    bytes += 12;
                                }
                            }
                            else
                            {
                                // copy byte to buffer (all previous bytes
                                // been copied have in default case above)
                                string_buffer[bytes++] = s[i];
                            }
                            break;
                        }
                    }

                    // write buffer and reset index; there must be 13 bytes
                    // left, as this is the maximal number of bytes to be
                    // written ("\uxxxx\uxxxx\0") for one code point
                    if (string_buffer.size() - bytes < 13)
                    {
                        o->write_characters(string_buffer.data(), bytes);
                        bytes = 0;
                    }

                    // remember the byte position of this accept
                    bytes_after_last_accept = bytes;
                    undumped_chars = 0;
                    break;
                }

                case UTF8_REJECT:  // decode found invalid UTF-8 byte
                {
                    switch (error_handler)
                    {
                        case error_handler_t::strict:
                        {
                            JSON_THROW(type_error::create(316, concat("invalid UTF-8 byte at index ", std::to_string(i), ": 0x", hex_bytes(byte | 0)), nullptr));
                        }

                        case error_handler_t::ignore:
                        case error_handler_t::replace:
                        {
                            // in case we saw this character the first time, we
                            // would like to read it again, because the byte
                            // may be OK for itself, but just not OK for the
                            // previous sequence
                            if (undumped_chars > 0)
                            {
                                --i;
                            }

                            // reset length buffer to the last accepted index;
                            // thus removing/ignoring the invalid characters
                            bytes = bytes_after_last_accept;

                            if (error_handler == error_handler_t::replace)
                            {
                                // add a replacement character
                                if (ensure_ascii)
                                {
                                    string_buffer[bytes++] = '\\';
                                    string_buffer[bytes++] = 'u';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'f';
                                    string_buffer[bytes++] = 'd';
                                }
                                else
                                {
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xEF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBF');
                                    string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type('\xBD');
                                }

                                // write buffer and reset index; there must be 13 bytes
                                // left, as this is the maximal number of bytes to be
                                // written ("\uxxxx\uxxxx\0") for one code point
                                if (string_buffer.size() - bytes < 13)
                                {
                                    o->write_characters(string_buffer.data(), bytes);
                                    bytes = 0;
                                }

                                bytes_after_last_accept = bytes;
                            }

                            undumped_chars = 0;

                            // continue processing the string
                            state = UTF8_ACCEPT;
                            break;
                        }

                        default:            // LCOV_EXCL_LINE
                            JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
                    }
                    break;
                }

                default:  // decode found yet incomplete multibyte code point
                {
                    if (!ensure_ascii)
                    {
                        // code point will not be escaped - copy byte to buffer
                        string_buffer[bytes++] = s[i];
                    }
                    ++undumped_chars;
                    break;
                }
            }
        }

        // we finished processing the string
        if (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))
        {
            // write buffer
            if (bytes > 0)
            {
                o->write_characters(string_buffer.data(), bytes);
            }
        }
        else
        {
            // we finish reading, but do not accept: string was incomplete
            switch (error_handler)
            {
                case error_handler_t::strict:
                {
                    JSON_THROW(type_error::create(316, concat("incomplete UTF-8 string; last byte: 0x", hex_bytes(static_cast<std::uint8_t>(s.back() | 0))), nullptr));
                }

                case error_handler_t::ignore:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    break;
                }

                case error_handler_t::replace:
                {
                    // write all accepted bytes
                    o->write_characters(string_buffer.data(), bytes_after_last_accept);
                    // add a replacement character
                    if (ensure_ascii)
                    {
                        o->write_characters("\\ufffd", 6);
                    }
                    else
                    {
                        o->write_characters("\xEF\xBF\xBD", 3);
                    }
                    break;
                }

                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        }
    }

  private:
    /*!
    @brief count digits

    Count the number of decimal (base 10) digits for an input unsigned integer.

    @param[in] x  unsigned integer number to count its digits
    @return    number of decimal digits
    */
    unsigned int count_digits(number_unsigned_t x) noexcept
    {
        unsigned int n_digits = 1;
        for (;;)
        {
            if (x < 10)
            {
                return n_digits;
            }
            if (x < 100)
            {
                return n_digits + 1;
            }
            if (x < 1000)
            {
                return n_digits + 2;
            }
            if (x < 10000)
            {
                return n_digits + 3;
            }
            x = x / 10000u;
            n_digits += 4;
        }
    }

    /*!
     * @brief convert a byte to a uppercase hex representation
     * @param[in] byte byte to represent
     * @return representation ("00".."FF")
     */
    static std::string hex_bytes(std::uint8_t byte)
    {
        std::string result = "FF";
        constexpr const char* nibble_to_hex = "0123456789ABCDEF";
        result[0] = nibble_to_hex[byte / 16];
        result[1] = nibble_to_hex[byte % 16];
        return result;
    }

    // templates to avoid warnings about useless casts
    template <typename NumberType, enable_if_t<std::is_signed<NumberType>::value, int> = 0>
    bool is_negative_number(NumberType x)
    {
        return x < 0;
    }

    template < typename NumberType, enable_if_t <std::is_unsigned<NumberType>::value, int > = 0 >
    bool is_negative_number(NumberType /*unused*/)
    {
        return false;
    }

    /*!
    @brief dump an integer

    Dump a given integer to output stream @a o. Works internally with
    @a number_buffer.

    @param[in] x  integer number (signed or unsigned) to dump
    @tparam NumberType either @a number_integer_t or @a number_unsigned_t
    */
    template < typename NumberType, detail::enable_if_t <
                   std::is_integral<NumberType>::value ||
                   std::is_same<NumberType, number_unsigned_t>::value ||
                   std::is_same<NumberType, number_integer_t>::value ||
                   std::is_same<NumberType, binary_char_t>::value,
                   int > = 0 >
    void dump_integer(NumberType x)
    {
        static constexpr std::array<std::array<char, 2>, 100> digits_to_99
        {
            {
                {{'0', '0'}}, {{'0', '1'}}, {{'0', '2'}}, {{'0', '3'}}, {{'0', '4'}}, {{'0', '5'}}, {{'0', '6'}}, {{'0', '7'}}, {{'0', '8'}}, {{'0', '9'}},
                {{'1', '0'}}, {{'1', '1'}}, {{'1', '2'}}, {{'1', '3'}}, {{'1', '4'}}, {{'1', '5'}}, {{'1', '6'}}, {{'1', '7'}}, {{'1', '8'}}, {{'1', '9'}},
                {{'2', '0'}}, {{'2', '1'}}, {{'2', '2'}}, {{'2', '3'}}, {{'2', '4'}}, {{'2', '5'}}, {{'2', '6'}}, {{'2', '7'}}, {{'2', '8'}}, {{'2', '9'}},
                {{'3', '0'}}, {{'3', '1'}}, {{'3', '2'}}, {{'3', '3'}}, {{'3', '4'}}, {{'3', '5'}}, {{'3', '6'}}, {{'3', '7'}}, {{'3', '8'}}, {{'3', '9'}},
                {{'4', '0'}}, {{'4', '1'}}, {{'4', '2'}}, {{'4', '3'}}, {{'4', '4'}}, {{'4', '5'}}, {{'4', '6'}}, {{'4', '7'}}, {{'4', '8'}}, {{'4', '9'}},
                {{'5', '0'}}, {{'5', '1'}}, {{'5', '2'}}, {{'5', '3'}}, {{'5', '4'}}, {{'5', '5'}}, {{'5', '6'}}, {{'5', '7'}}, {{'5', '8'}}, {{'5', '9'}},
                {{'6', '0'}}, {{'6', '1'}}, {{'6', '2'}}, {{'6', '3'}}, {{'6', '4'}}, {{'6', '5'}}, {{'6', '6'}}, {{'6', '7'}}, {{'6', '8'}}, {{'6', '9'}},
                {{'7', '0'}}, {{'7', '1'}}, {{'7', '2'}}, {{'7', '3'}}, {{'7', '4'}}, {{'7', '5'}}, {{'7', '6'}}, {{'7', '7'}}, {{'7', '8'}}, {{'7', '9'}},
                {{'8', '0'}}, {{'8', '1'}}, {{'8', '2'}}, {{'8', '3'}}, {{'8', '4'}}, {{'8', '5'}}, {{'8', '6'}}, {{'8', '7'}}, {{'8', '8'}}, {{'8', '9'}},
                {{'9', '0'}}, {{'9', '1'}}, {{'9', '2'}}, {{'9', '3'}}, {{'9', '4'}}, {{'9', '5'}}, {{'9', '6'}}, {{'9', '7'}}, {{'9', '8'}}, {{'9', '9'}},
            }
        };

        // special case for "0"
        if (x == 0)
        {
            o->write_character('0');
            return;
        }

        // use a pointer to fill the buffer
        auto buffer_ptr = number_buffer.begin(); // NOLINT(llvm-qualified-auto,readability-qualified-auto,cppcoreguidelines-pro-type-vararg,hicpp-vararg)

        number_unsigned_t abs_value;

        unsigned int n_chars{};

        if (is_negative_number(x))
        {
            *buffer_ptr = '-';
            abs_value = remove_sign(static_cast<number_integer_t>(x));

            // account one more byte for the minus sign
            n_chars = 1 + count_digits(abs_value);
        }
        else
        {
            abs_value = static_cast<number_unsigned_t>(x);
            n_chars = count_digits(abs_value);
        }

        // spare 1 byte for '\0'
        JSON_ASSERT(n_chars < number_buffer.size() - 1);

        // jump to the end to generate the string from backward,
        // so we later avoid reversing the result
        buffer_ptr += static_cast<typename decltype(number_buffer)::difference_type>(n_chars);

        // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu
        // See: https://www.youtube.com/watch?v=o4-CwDo2zpg
        while (abs_value >= 100)
        {
            const auto digits_index = static_cast<unsigned>((abs_value % 100));
            abs_value /= 100;
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }

        if (abs_value >= 10)
        {
            const auto digits_index = static_cast<unsigned>(abs_value);
            *(--buffer_ptr) = digits_to_99[digits_index][1];
            *(--buffer_ptr) = digits_to_99[digits_index][0];
        }
        else
        {
            *(--buffer_ptr) = static_cast<char>('0' + abs_value);
        }

        o->write_characters(number_buffer.data(), n_chars);
    }

    /*!
    @brief dump a floating-point number

    Dump a given floating-point number to output stream @a o. Works internally
    with @a number_buffer.

    @param[in] x  floating-point number to dump
    */
    void dump_float(number_float_t x)
    {
        // NaN / inf
        if (!std::isfinite(x))
        {
            o->write_characters("null", 4);
            return;
        }

        // If number_float_t is an IEEE-754 single or double precision number,
        // use the Grisu2 algorithm to produce short numbers which are
        // guaranteed to round-trip, using strtof and strtod, resp.
        //
        // NB: The test below works if <long double> == <double>.
        static constexpr bool is_ieee_single_or_double
            = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||
              (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);

        dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());
    }

    void dump_float(number_float_t x, std::true_type /*is_ieee_single_or_double*/)
    {
        auto* begin = number_buffer.data();
        auto* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);

        o->write_characters(begin, static_cast<size_t>(end - begin));
    }

    void dump_float(number_float_t x, std::false_type /*is_ieee_single_or_double*/)
    {
        // get the number of digits for a float -> text -> float round-trip
        static constexpr auto d = std::numeric_limits<number_float_t>::max_digits10;

        // the actual conversion
        // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)
        std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), "%.*g", d, x);

        // negative value indicates an error
        JSON_ASSERT(len > 0);
        // check if the buffer was large enough
        JSON_ASSERT(static_cast<std::size_t>(len) < number_buffer.size());

        // erase thousands separators
        if (thousands_sep != '\0')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::remove returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto end = std::remove(number_buffer.begin(), number_buffer.begin() + len, thousands_sep);
            std::fill(end, number_buffer.end(), '\0');
            JSON_ASSERT((end - number_buffer.begin()) <= len);
            len = (end - number_buffer.begin());
        }

        // convert decimal point to '.'
        if (decimal_point != '\0' && decimal_point != '.')
        {
            // NOLINTNEXTLINE(readability-qualified-auto,llvm-qualified-auto): std::find returns an iterator, see https://github.com/nlohmann/json/issues/3081
            const auto dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);
            if (dec_pos != number_buffer.end())
            {
                *dec_pos = '.';
            }
        }

        o->write_characters(number_buffer.data(), static_cast<std::size_t>(len));

        // determine if we need to append ".0"
        const bool value_is_int_like =
            std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,
                         [](char c)
        {
            return c == '.' || c == 'e';
        });

        if (value_is_int_like)
        {
            o->write_characters(".0", 2);
        }
    }

    /*!
    @brief check whether a string is UTF-8 encoded

    The function checks each byte of a string whether it is UTF-8 encoded. The
    result of the check is stored in the @a state parameter. The function must
    be called initially with state 0 (accept). State 1 means the string must
    be rejected, because the current byte is not allowed. If the string is
    completely processed, but the state is non-zero, the string ended
    prematurely; that is, the last byte indicated more bytes should have
    followed.

    @param[in,out] state  the state of the decoding
    @param[in,out] codep  codepoint (valid only if resulting state is UTF8_ACCEPT)
    @param[in] byte       next byte to decode
    @return               new state

    @note The function has been edited: a std::array is used.

    @copyright Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
    @sa http://bjoern.hoehrmann.de/utf-8/decoder/dfa/
    */
    static std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, const std::uint8_t byte) noexcept
    {
        static const std::array<std::uint8_t, 400> utf8d =
        {
            {
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 00..1F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 20..3F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 40..5F
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 60..7F
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, // 80..9F
                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, // A0..BF
                8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, // C0..DF
                0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, // E0..EF
                0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, // F0..FF
                0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, // s0..s0
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, // s1..s2
                1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, // s3..s4
                1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, // s5..s6
                1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s7..s8
            }
        };

        JSON_ASSERT(static_cast<std::size_t>(byte) < utf8d.size());
        const std::uint8_t type = utf8d[byte];

        codep = (state != UTF8_ACCEPT)
                ? (byte & 0x3fu) | (codep << 6u)
                : (0xFFu >> type) & (byte);

        const std::size_t index = 256u + (static_cast<size_t>(state) * 16u) + static_cast<size_t>(type);
        JSON_ASSERT(index < utf8d.size());
        state = utf8d[index];
        return state;
    }

    /*
     * Overload to make the compiler happy while it is instantiating
     * dump_integer for number_unsigned_t.
     * Must never be called.
     */
    number_unsigned_t remove_sign(number_unsigned_t x)
    {
        JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        return x; // LCOV_EXCL_LINE
    }

    /*
     * Helper function for dump_integer
     *
     * This function takes a negative signed integer and returns its absolute
     * value as an unsigned integer. The plus/minus shuffling is necessary as we
     * cannot directly remove the sign of an arbitrary signed integer as the
     * absolute values of INT_MIN and INT_MAX are usually not the same. See
     * #1708 for details.
     */
    number_unsigned_t remove_sign(number_integer_t x) noexcept
    {
        JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); // NOLINT(misc-redundant-expression)
        return static_cast<number_unsigned_t>(-(x + 1)) + 1;
    }

  private:
    /// the output of the serializer
    output_adapter_t<char> o = nullptr;

    /// a (hopefully) large enough character buffer
    std::array<char, 64> number_buffer{{}};

    /// the locale
    const std::lconv* loc = nullptr;
    /// the locale's thousand separator character
    const char thousands_sep = '\0';
    /// the locale's decimal point character
    const char decimal_point = '\0';

    /// string buffer
    std::array<char, 512> string_buffer{{}};

    /// the indentation character
    const char indent_char;
    /// the indentation string
    string_t indent_string;

    /// error_handler how to react on decoding errors
    const error_handler_t error_handler;
};

}  // namespace detail
NLOHMANN_JSON_NAMESPACE_END

// #include <nlohmann/detail/value_t.hpp>

// #include <nlohmann/json_fwd.hpp>

// #include <nlohmann/ordered_map.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#include <functional> // equal_to, less
#include <initializer_list> // initializer_list
#include <iterator> // input_iterator_tag, iterator_traits
#include <memory> // allocator
#include <stdexcept> // for out_of_range
#include <type_traits> // enable_if, is_convertible
#include <utility> // pair
#include <vector> // vector

// #include <nlohmann/detail/macro_scope.hpp>

// #include <nlohmann/detail/meta/type_traits.hpp>


NLOHMANN_JSON_NAMESPACE_BEGIN

/// ordered_map: a minimal map-like container that preserves insertion order
/// for use within nlohmann::basic_json<ordered_map>
template <class Key, class T, class IgnoredLess = std::less<Key>,
          class Allocator = std::allocator<std::pair<const Key, T>>>
              struct ordered_map : std::vector<std::pair<const Key, T>, Allocator>
{
    using key_type = Key;
    using mapped_type = T;
    using Container = std::vector<std::pair<const Key, T>, Allocator>;
    using iterator = typename Container::iterator;
    using const_iterator = typename Container::const_iterator;
    using size_type = typename Container::size_type;
    using value_type = typename Container::value_type;
#ifdef JSON_HAS_CPP_14
    using key_compare = std::equal_to<>;
#else
    using key_compare = std::equal_to<Key>;
#endif

    // Explicit constructors instead of `using Container::Container`
    // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)
    ordered_map() noexcept(noexcept(Container())) : Container{} {}
    explicit ordered_map(const Allocator& alloc) noexcept(noexcept(Container(alloc))) : Container{alloc} {}
    template <class It>
    ordered_map(It first, It last, const Allocator& alloc = Allocator())
        : Container{first, last, alloc} {}
    ordered_map(std::initializer_list<value_type> init, const Allocator& alloc = Allocator() )
        : Container{init, alloc} {}

    std::pair<iterator, bool> emplace(const key_type& key, T&& t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(key, std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    std::pair<iterator, bool> emplace(KeyType && key, T && t)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return {it, false};
            }
        }
        Container::emplace_back(std::forward<KeyType>(key), std::forward<T>(t));
        return {std::prev(this->end()), true};
    }

    T& operator[](const key_type& key)
    {
        return emplace(key, T{}).first->second;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & operator[](KeyType && key)
    {
        return emplace(std::forward<KeyType>(key), T{}).first->second;
    }

    const T& operator[](const key_type& key) const
    {
        return at(key);
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & operator[](KeyType && key) const
    {
        return at(std::forward<KeyType>(key));
    }

    T& at(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    T & at(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    const T& at(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    const T & at(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it->second;
            }
        }

        JSON_THROW(std::out_of_range("key not found"));
    }

    size_type erase(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type erase(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                // Since we cannot move const Keys, re-construct them in place
                for (auto next = it; ++next != this->end(); ++it)
                {
                    it->~value_type(); // Destroy but keep allocation
                    new (&*it) value_type{std::move(*next)};
                }
                Container::pop_back();
                return 1;
            }
        }
        return 0;
    }

    iterator erase(iterator pos)
    {
        return erase(pos, std::next(pos));
    }

    iterator erase(iterator first, iterator last)
    {
        if (first == last)
        {
            return first;
        }

        const auto elements_affected = std::distance(first, last);
        const auto offset = std::distance(Container::begin(), first);

        // This is the start situation. We need to delete elements_affected
        // elements (3 in this example: e, f, g), and need to return an
        // iterator past the last deleted element (h in this example).
        // Note that offset is the distance from the start of the vector
        // to first. We will need this later.

        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //             first    last

        // Since we cannot move const Keys, we re-construct them in place.
        // We start at first and re-construct (viz. copy) the elements from
        // the back of the vector. Example for the first iteration:

        //               ,--------.
        //               v        |   destroy e and re-construct with h
        // [ a, b, c, d, e, f, g, h, i, j ]
        //               ^        ^
        //               it       it + elements_affected

        for (auto it = first; std::next(it, elements_affected) != Container::end(); ++it)
        {
            it->~value_type(); // destroy but keep allocation
            new (&*it) value_type{std::move(*std::next(it, elements_affected))}; // "move" next element to it
        }

        // [ a, b, c, d, h, i, j, h, i, j ]
        //               ^        ^
        //             first    last

        // remove the unneeded elements at the end of the vector
        Container::resize(this->size() - static_cast<size_type>(elements_affected));

        // [ a, b, c, d, h, i, j ]
        //               ^        ^
        //             first    last

        // first is now pointing past the last deleted element, but we cannot
        // use this iterator, because it may have been invalidated by the
        // resize call. Instead, we can return begin() + offset.
        return Container::begin() + offset;
    }

    size_type count(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return 1;
            }
        }
        return 0;
    }

    iterator find(const key_type& key)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_key_type<key_compare, key_type, KeyType>::value, int> = 0>
    iterator find(KeyType && key) // NOLINT(cppcoreguidelines-missing-std-forward)
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    const_iterator find(const key_type& key) const
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, key))
            {
                return it;
            }
        }
        return Container::end();
    }

    std::pair<iterator, bool> insert( value_type&& value )
    {
        return emplace(value.first, std::move(value.second));
    }

    std::pair<iterator, bool> insert( const value_type& value )
    {
        for (auto it = this->begin(); it != this->end(); ++it)
        {
            if (m_compare(it->first, value.first))
            {
                return {it, false};
            }
        }
        Container::push_back(value);
        return {--this->end(), true};
    }

    template<typename InputIt>
    using require_input_iter = typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,
        std::input_iterator_tag>::value>::type;

    template<typename InputIt, typename = require_input_iter<InputIt>>
    void insert(InputIt first, InputIt last)
    {
        for (auto it = first; it != last; ++it)
        {
            insert(*it);
        }
    }

private:
    JSON_NO_UNIQUE_ADDRESS key_compare m_compare = key_compare();
};

NLOHMANN_JSON_NAMESPACE_END


#if defined(JSON_HAS_CPP_17)
    #if JSON_HAS_STATIC_RTTI
        #include <any>
    #endif
    #include <string_view>
#endif

/*!
@brief namespace for Niels Lohmann
@see https://github.com/nlohmann
@since version 1.0.0
*/
NLOHMANN_JSON_NAMESPACE_BEGIN

/*!
@brief a class to store JSON values

@internal
@invariant The member variables @a m_value and @a m_type have the following
relationship:
- If `m_type == value_t::object`, then `m_value.object != nullptr`.
- If `m_type == value_t::array`, then `m_value.array != nullptr`.
- If `m_type == value_t::string`, then `m_value.string != nullptr`.
The invariants are checked by member function assert_invariant().

@note ObjectType trick from https://stackoverflow.com/a/9860911
@endinternal

@since version 1.0.0

@nosubgrouping
*/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
class basic_json // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)
    : public ::nlohmann::detail::json_base_class<CustomBaseClass>
{
  private:
    template<detail::value_t> friend struct detail::external_constructor;

    template<typename>
    friend class ::nlohmann::json_pointer;
    // can be restored when json_pointer backwards compatibility is removed
    // friend ::nlohmann::json_pointer<StringType>;

    template<typename BasicJsonType, typename InputType>
    friend class ::nlohmann::detail::parser;
    friend ::nlohmann::detail::serializer<basic_json>;
    template<typename BasicJsonType>
    friend class ::nlohmann::detail::iter_impl;
    template<typename BasicJsonType, typename CharType>
    friend class ::nlohmann::detail::binary_writer;
    template<typename BasicJsonType, typename InputType, typename SAX>
    friend class ::nlohmann::detail::binary_reader;
    template<typename BasicJsonType, typename InputAdapterType>
    friend class ::nlohmann::detail::json_sax_dom_parser;
    template<typename BasicJsonType, typename InputAdapterType>
    friend class ::nlohmann::detail::json_sax_dom_callback_parser;
    friend class ::nlohmann::detail::exception;

    /// workaround type for MSVC
    using basic_json_t = NLOHMANN_BASIC_JSON_TPL;
    using json_base_class_t = ::nlohmann::detail::json_base_class<CustomBaseClass>;

  JSON_PRIVATE_UNLESS_TESTED:
    // convenience aliases for types residing in namespace detail;
    using lexer = ::nlohmann::detail::lexer_base<basic_json>;

    template<typename InputAdapterType>
    static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(
        InputAdapterType adapter,
        detail::parser_callback_t<basic_json>cb = nullptr,
        const bool allow_exceptions = true,
        const bool ignore_comments = false,
        const bool ignore_trailing_commas = false
                                 )
    {
        return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),
            std::move(cb), allow_exceptions, ignore_comments, ignore_trailing_commas);
    }

  private:
    using primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;
    template<typename BasicJsonType>
    using internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;
    template<typename BasicJsonType>
    using iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;
    template<typename Iterator>
    using iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;
    template<typename Base> using json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;

    template<typename CharType>
    using output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;

    template<typename InputType>
    using binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;
    template<typename CharType> using binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;

  JSON_PRIVATE_UNLESS_TESTED:
    using serializer = ::nlohmann::detail::serializer<basic_json>;

  public:
    using value_t = detail::value_t;
    /// JSON Pointer, see @ref nlohmann::json_pointer
    using json_pointer = ::nlohmann::json_pointer<StringType>;
    template<typename T, typename SFINAE>
    using json_serializer = JSONSerializer<T, SFINAE>;
    /// how to treat decoding errors
    using error_handler_t = detail::error_handler_t;
    /// how to treat CBOR tags
    using cbor_tag_handler_t = detail::cbor_tag_handler_t;
    /// how to encode BJData
    using bjdata_version_t = detail::bjdata_version_t;
    /// helper type for initializer lists of basic_json values
    using initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;

    using input_format_t = detail::input_format_t;
    /// SAX interface type, see @ref nlohmann::json_sax
    using json_sax_t = json_sax<basic_json>;

    ////////////////
    // exceptions //
    ////////////////

    /// @name exceptions
    /// Classes to implement user-defined exceptions.
    /// @{

    using exception = detail::exception;
    using parse_error = detail::parse_error;
    using invalid_iterator = detail::invalid_iterator;
    using type_error = detail::type_error;
    using out_of_range = detail::out_of_range;
    using other_error = detail::other_error;

    /// @}

    /////////////////////
    // container types //
    /////////////////////

    /// @name container types
    /// The canonic container types to use @ref basic_json like any other STL
    /// container.
    /// @{

    /// the type of elements in a basic_json container
    using value_type = basic_json;

    /// the type of an element reference
    using reference = value_type&;
    /// the type of an element const reference
    using const_reference = const value_type&;

    /// a type to represent differences between iterators
    using difference_type = std::ptrdiff_t;
    /// a type to represent container sizes
    using size_type = std::size_t;

    /// the allocator type
    using allocator_type = AllocatorType<basic_json>;

    /// the type of an element pointer
    using pointer = typename std::allocator_traits<allocator_type>::pointer;
    /// the type of an element const pointer
    using const_pointer = typename std::allocator_traits<allocator_type>::const_pointer;

    /// an iterator for a basic_json container
    using iterator = iter_impl<basic_json>;
    /// a const iterator for a basic_json container
    using const_iterator = iter_impl<const basic_json>;
    /// a reverse iterator for a basic_json container
    using reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;
    /// a const reverse iterator for a basic_json container
    using const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;

    /// @}

    /// @brief returns the allocator associated with the container
    /// @sa https://json.nlohmann.me/api/basic_json/get_allocator/
    static allocator_type get_allocator()
    {
        return allocator_type();
    }

    /// @brief returns version information on the library
    /// @sa https://json.nlohmann.me/api/basic_json/meta/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json meta()
    {
        basic_json result;

        result["copyright"] = "(C) 2013-2026 Niels Lohmann";
        result["name"] = "JSON for Modern C++";
        result["url"] = "https://github.com/nlohmann/json";
        result["version"]["string"] =
            detail::concat(std::to_string(NLOHMANN_JSON_VERSION_MAJOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_MINOR), '.',
                           std::to_string(NLOHMANN_JSON_VERSION_PATCH));
        result["version"]["major"] = NLOHMANN_JSON_VERSION_MAJOR;
        result["version"]["minor"] = NLOHMANN_JSON_VERSION_MINOR;
        result["version"]["patch"] = NLOHMANN_JSON_VERSION_PATCH;

#ifdef _WIN32
        result["platform"] = "win32";
#elif defined __linux__
        result["platform"] = "linux";
#elif defined __APPLE__
        result["platform"] = "apple";
#elif defined __unix__
        result["platform"] = "unix";
#else
        result["platform"] = "unknown";
#endif

#if defined(__ICC) || defined(__INTEL_COMPILER)
        result["compiler"] = {{"family", "icc"}, {"version", __INTEL_COMPILER}};
#elif defined(__clang__)
        result["compiler"] = {{"family", "clang"}, {"version", __clang_version__}};
#elif defined(__GNUC__) || defined(__GNUG__)
        result["compiler"] = {{"family", "gcc"}, {"version", detail::concat(
                    std::to_string(__GNUC__), '.',
                    std::to_string(__GNUC_MINOR__), '.',
                    std::to_string(__GNUC_PATCHLEVEL__))
            }
        };
#elif defined(__HP_cc) || defined(__HP_aCC)
        result["compiler"] = "hp"
#elif defined(__IBMCPP__)
        result["compiler"] = {{"family", "ilecpp"}, {"version", __IBMCPP__}};
#elif defined(_MSC_VER)
        result["compiler"] = {{"family", "msvc"}, {"version", _MSC_VER}};
#elif defined(__PGI)
        result["compiler"] = {{"family", "pgcpp"}, {"version", __PGI}};
#elif defined(__SUNPRO_CC)
        result["compiler"] = {{"family", "sunpro"}, {"version", __SUNPRO_CC}};
#else
        result["compiler"] = {{"family", "unknown"}, {"version", "unknown"}};
#endif

#if defined(_MSVC_LANG)
        result["compiler"]["c++"] = std::to_string(_MSVC_LANG);
#elif defined(__cplusplus)
        result["compiler"]["c++"] = std::to_string(__cplusplus);
#else
        result["compiler"]["c++"] = "unknown";
#endif
        return result;
    }

    ///////////////////////////
    // JSON value data types //
    ///////////////////////////

    /// @name JSON value data types
    /// The data types to store a JSON value. These types are derived from
    /// the template arguments passed to class @ref basic_json.
    /// @{

    /// @brief default object key comparator type
    /// The actual object key comparator type (@ref object_comparator_t) may be
    /// different.
    /// @sa https://json.nlohmann.me/api/basic_json/default_object_comparator_t/
#if defined(JSON_HAS_CPP_14)
    // use of transparent comparator avoids unnecessary repeated construction of temporaries
    // in functions involving lookup by key with types other than object_t::key_type (aka. StringType)
    using default_object_comparator_t = std::less<>;
#else
    using default_object_comparator_t = std::less<StringType>;
#endif

    /// @brief a type for an object
    /// @sa https://json.nlohmann.me/api/basic_json/object_t/
    using object_t = ObjectType<StringType,
          basic_json,
          default_object_comparator_t,
          AllocatorType<std::pair<const StringType,
          basic_json>>>;

    /// @brief a type for an array
    /// @sa https://json.nlohmann.me/api/basic_json/array_t/
    using array_t = ArrayType<basic_json, AllocatorType<basic_json>>;

    /// @brief a type for a string
    /// @sa https://json.nlohmann.me/api/basic_json/string_t/
    using string_t = StringType;

    /// @brief a type for a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/boolean_t/
    using boolean_t = BooleanType;

    /// @brief a type for a number (integer)
    /// @sa https://json.nlohmann.me/api/basic_json/number_integer_t/
    using number_integer_t = NumberIntegerType;

    /// @brief a type for a number (unsigned)
    /// @sa https://json.nlohmann.me/api/basic_json/number_unsigned_t/
    using number_unsigned_t = NumberUnsignedType;

    /// @brief a type for a number (floating-point)
    /// @sa https://json.nlohmann.me/api/basic_json/number_float_t/
    using number_float_t = NumberFloatType;

    /// @brief a type for a packed binary type
    /// @sa https://json.nlohmann.me/api/basic_json/binary_t/
    using binary_t = nlohmann::byte_container_with_subtype<BinaryType>;

    /// @brief object key comparator type
    /// @sa https://json.nlohmann.me/api/basic_json/object_comparator_t/
    using object_comparator_t = detail::actual_object_comparator_t<basic_json>;

    /// @}

  private:

    /// helper for exception-safe object creation
    template<typename T, typename... Args>
    JSON_HEDLEY_RETURNS_NON_NULL
    static T* create(Args&& ... args)
    {
        AllocatorType<T> alloc;
        using AllocatorTraits = std::allocator_traits<AllocatorType<T>>;

        auto deleter = [&](T * obj)
        {
            AllocatorTraits::deallocate(alloc, obj, 1);
        };
        std::unique_ptr<T, decltype(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);
        AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);
        JSON_ASSERT(obj != nullptr);
        return obj.release();
    }

    ////////////////////////
    // JSON value storage //
    ////////////////////////

  JSON_PRIVATE_UNLESS_TESTED:
    /*!
    @brief a JSON value

    The actual storage for a JSON value of the @ref basic_json class. This
    union combines the different storage types for the JSON value types
    defined in @ref value_t.

    JSON type | value_t type    | used type
    --------- | --------------- | ------------------------
    object    | object          | pointer to @ref object_t
    array     | array           | pointer to @ref array_t
    string    | string          | pointer to @ref string_t
    boolean   | boolean         | @ref boolean_t
    number    | number_integer  | @ref number_integer_t
    number    | number_unsigned | @ref number_unsigned_t
    number    | number_float    | @ref number_float_t
    binary    | binary          | pointer to @ref binary_t
    null      | null            | *no value is stored*

    @note Variable-length types (objects, arrays, and strings) are stored as
    pointers. The size of the union should not exceed 64 bits if the default
    value types are used.

    @since version 1.0.0
    */
    union json_value
    {
        /// object (stored with pointer to save storage)
        object_t* object;
        /// array (stored with pointer to save storage)
        array_t* array;
        /// string (stored with pointer to save storage)
        string_t* string;
        /// binary (stored with pointer to save storage)
        binary_t* binary;
        /// boolean
        boolean_t boolean;
        /// number (integer)
        number_integer_t number_integer;
        /// number (unsigned integer)
        number_unsigned_t number_unsigned;
        /// number (floating-point)
        number_float_t number_float;

        /// default constructor (for null values)
        json_value() = default;
        /// constructor for booleans
        json_value(boolean_t v) noexcept : boolean(v) {}
        /// constructor for numbers (integer)
        json_value(number_integer_t v) noexcept : number_integer(v) {}
        /// constructor for numbers (unsigned)
        json_value(number_unsigned_t v) noexcept : number_unsigned(v) {}
        /// constructor for numbers (floating-point)
        json_value(number_float_t v) noexcept : number_float(v) {}
        /// constructor for empty values of a given type
        json_value(value_t t)
        {
            switch (t)
            {
                case value_t::object:
                {
                    object = create<object_t>();
                    break;
                }

                case value_t::array:
                {
                    array = create<array_t>();
                    break;
                }

                case value_t::string:
                {
                    string = create<string_t>("");
                    break;
                }

                case value_t::binary:
                {
                    binary = create<binary_t>();
                    break;
                }

                case value_t::boolean:
                {
                    boolean = static_cast<boolean_t>(false);
                    break;
                }

                case value_t::number_integer:
                {
                    number_integer = static_cast<number_integer_t>(0);
                    break;
                }

                case value_t::number_unsigned:
                {
                    number_unsigned = static_cast<number_unsigned_t>(0);
                    break;
                }

                case value_t::number_float:
                {
                    number_float = static_cast<number_float_t>(0.0);
                    break;
                }

                case value_t::null:
                {
                    object = nullptr;  // silence warning, see #821
                    break;
                }

                case value_t::discarded:
                default:
                {
                    object = nullptr;  // silence warning, see #821
                    if (JSON_HEDLEY_UNLIKELY(t == value_t::null))
                    {
                        JSON_THROW(other_error::create(500, "961c151d2e87f2686a955a9be24d316f1362bf21 3.12.0", nullptr)); // LCOV_EXCL_LINE
                    }
                    break;
                }
            }
        }

        /// constructor for strings
        json_value(const string_t& value) : string(create<string_t>(value)) {}

        /// constructor for rvalue strings
        json_value(string_t&& value) : string(create<string_t>(std::move(value))) {}

        /// constructor for objects
        json_value(const object_t& value) : object(create<object_t>(value)) {}

        /// constructor for rvalue objects
        json_value(object_t&& value) : object(create<object_t>(std::move(value))) {}

        /// constructor for arrays
        json_value(const array_t& value) : array(create<array_t>(value)) {}

        /// constructor for rvalue arrays
        json_value(array_t&& value) : array(create<array_t>(std::move(value))) {}

        /// constructor for binary arrays
        json_value(const typename binary_t::container_type& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays
        json_value(typename binary_t::container_type&& value) : binary(create<binary_t>(std::move(value))) {}

        /// constructor for binary arrays (internal type)
        json_value(const binary_t& value) : binary(create<binary_t>(value)) {}

        /// constructor for rvalue binary arrays (internal type)
        json_value(binary_t&& value) : binary(create<binary_t>(std::move(value))) {}

        void destroy(value_t t)
        {
            if (
                (t == value_t::object && object == nullptr) ||
                (t == value_t::array && array == nullptr) ||
                (t == value_t::string && string == nullptr) ||
                (t == value_t::binary && binary == nullptr)
            )
            {
                // not initialized (e.g., due to exception in the ctor)
                return;
            }
            if (t == value_t::array || t == value_t::object)
            {
                // flatten the current json_value to a heap-allocated stack
                std::vector<basic_json> stack;

                // move the top-level items to stack
                if (t == value_t::array)
                {
                    stack.reserve(array->size());
                    std::move(array->begin(), array->end(), std::back_inserter(stack));
                }
                else
                {
                    stack.reserve(object->size());
                    for (auto&& it : *object)
                    {
                        stack.push_back(std::move(it.second));
                    }
                }

                while (!stack.empty())
                {
                    // move the last item to a local variable to be processed
                    basic_json current_item(std::move(stack.back()));
                    stack.pop_back();

                    // if current_item is array/object, move
                    // its children to the stack to be processed later
                    if (current_item.is_array())
                    {
                        std::move(current_item.m_data.m_value.array->begin(), current_item.m_data.m_value.array->end(), std::back_inserter(stack));

                        current_item.m_data.m_value.array->clear();
                    }
                    else if (current_item.is_object())
                    {
                        for (auto&& it : *current_item.m_data.m_value.object)
                        {
                            stack.push_back(std::move(it.second));
                        }

                        current_item.m_data.m_value.object->clear();
                    }

                    // it's now safe that current_item gets destructed
                    // since it doesn't have any children
                }
            }

            switch (t)
            {
                case value_t::object:
                {
                    AllocatorType<object_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, object);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, object, 1);
                    break;
                }

                case value_t::array:
                {
                    AllocatorType<array_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, array);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, array, 1);
                    break;
                }

                case value_t::string:
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, string, 1);
                    break;
                }

                case value_t::binary:
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, binary, 1);
                    break;
                }

                case value_t::null:
                case value_t::boolean:
                case value_t::number_integer:
                case value_t::number_unsigned:
                case value_t::number_float:
                case value_t::discarded:
                default:
                {
                    break;
                }
            }
        }
    };

  private:
    /*!
    @brief checks the class invariants

    This function asserts the class invariants. It needs to be called at the
    end of every constructor to make sure that created objects respect the
    invariant. Furthermore, it has to be called each time the type of a JSON
    value is changed, because the invariant expresses a relationship between
    @a m_type and @a m_value.

    Furthermore, the parent relation is checked for arrays and objects: If
    @a check_parents true and the value is an array or object, then the
    container's elements must have the current value as parent.

    @param[in] check_parents  whether the parent relation should be checked.
               The value is true by default and should only be set to false
               during destruction of objects when the invariant does not
               need to hold.
    */
    void assert_invariant(bool check_parents = true) const noexcept
    {
        JSON_ASSERT(m_data.m_type != value_t::object || m_data.m_value.object != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::array || m_data.m_value.array != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::string || m_data.m_value.string != nullptr);
        JSON_ASSERT(m_data.m_type != value_t::binary || m_data.m_value.binary != nullptr);

#if JSON_DIAGNOSTICS
        JSON_TRY
        {
            // cppcheck-suppress assertWithSideEffect
            JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [this](const basic_json & j)
            {
                return j.m_parent == this;
            }));
        }
        JSON_CATCH(...) {} // LCOV_EXCL_LINE
#endif
        static_cast<void>(check_parents);
    }

    void set_parents()
    {
#if JSON_DIAGNOSTICS
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                for (auto& element : *m_data.m_value.array)
                {
                    element.m_parent = this;
                }
                break;
            }

            case value_t::object:
            {
                for (auto& element : *m_data.m_value.object)
                {
                    element.second.m_parent = this;
                }
                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }
#endif
    }

    iterator set_parents(iterator it, typename iterator::difference_type count_set_parents)
    {
#if JSON_DIAGNOSTICS
        for (typename iterator::difference_type i = 0; i < count_set_parents; ++i)
        {
            (it + i)->m_parent = this;
        }
#else
        static_cast<void>(count_set_parents);
#endif
        return it;
    }

    reference set_parent(reference j, std::size_t old_capacity = detail::unknown_size())
    {
#if JSON_DIAGNOSTICS
        if (old_capacity != detail::unknown_size())
        {
            // see https://github.com/nlohmann/json/issues/2838
            JSON_ASSERT(type() == value_t::array);
            if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
            {
                // capacity has changed: update all parents
                set_parents();
                return j;
            }
        }

        // ordered_json uses a vector internally, so pointers could have
        // been invalidated; see https://github.com/nlohmann/json/issues/2962
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning(push )
#pragma warning(disable : 4127) // ignore warning to replace if with if constexpr
#endif
        if (detail::is_ordered_map<object_t>::value)
        {
            set_parents();
            return j;
        }
#ifdef JSON_HEDLEY_MSVC_VERSION
#pragma warning( pop )
#endif

        j.m_parent = this;
#else
        static_cast<void>(j);
        static_cast<void>(old_capacity);
#endif
        return j;
    }

  public:
    //////////////////////////
    // JSON parser callback //
    //////////////////////////

    /// @brief parser event types
    /// @sa https://json.nlohmann.me/api/basic_json/parse_event_t/
    using parse_event_t = detail::parse_event_t;

    /// @brief per-element parser callback type
    /// @sa https://json.nlohmann.me/api/basic_json/parser_callback_t/
    using parser_callback_t = detail::parser_callback_t<basic_json>;

    //////////////////
    // constructors //
    //////////////////

    /// @name constructors and destructors
    /// Constructors of class @ref basic_json, copy/move constructor, copy
    /// assignment, static functions creating objects, and the destructor.
    /// @{

    /// @brief create an empty value with a given type
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const value_t v)
        : m_data(v)
    {
        assert_invariant();
    }

    /// @brief create a null object
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(std::nullptr_t = nullptr) noexcept // NOLINT(bugprone-exception-escape)
        : basic_json(value_t::null)
    {
        assert_invariant();
    }

    /// @brief create a JSON value from compatible types
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename CompatibleType,
               typename U = detail::uncvref_t<CompatibleType>,
               detail::enable_if_t <
                   !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, int > = 0 >
    basic_json(CompatibleType && val) noexcept(noexcept( // NOLINT(bugprone-forwarding-reference-overload,bugprone-exception-escape)
            JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),
                                       std::forward<CompatibleType>(val))))
    {
        JSONSerializer<U>::to_json(*this, std::forward<CompatibleType>(val));
        set_parents();
        assert_invariant();
    }

    /// @brief create a JSON value from an existing one
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, int > = 0 >
    basic_json(const BasicJsonType& val)
#if JSON_DIAGNOSTIC_POSITIONS
        : start_position(val.start_pos()),
          end_position(val.end_pos())
#endif
    {
        using other_boolean_t = typename BasicJsonType::boolean_t;
        using other_number_float_t = typename BasicJsonType::number_float_t;
        using other_number_integer_t = typename BasicJsonType::number_integer_t;
        using other_number_unsigned_t = typename BasicJsonType::number_unsigned_t;
        using other_string_t = typename BasicJsonType::string_t;
        using other_object_t = typename BasicJsonType::object_t;
        using other_array_t = typename BasicJsonType::array_t;
        using other_binary_t = typename BasicJsonType::binary_t;

        switch (val.type())
        {
            case value_t::boolean:
                JSONSerializer<other_boolean_t>::to_json(*this, val.template get<other_boolean_t>());
                break;
            case value_t::number_float:
                JSONSerializer<other_number_float_t>::to_json(*this, val.template get<other_number_float_t>());
                break;
            case value_t::number_integer:
                JSONSerializer<other_number_integer_t>::to_json(*this, val.template get<other_number_integer_t>());
                break;
            case value_t::number_unsigned:
                JSONSerializer<other_number_unsigned_t>::to_json(*this, val.template get<other_number_unsigned_t>());
                break;
            case value_t::string:
                JSONSerializer<other_string_t>::to_json(*this, val.template get_ref<const other_string_t&>());
                break;
            case value_t::object:
                JSONSerializer<other_object_t>::to_json(*this, val.template get_ref<const other_object_t&>());
                break;
            case value_t::array:
                JSONSerializer<other_array_t>::to_json(*this, val.template get_ref<const other_array_t&>());
                break;
            case value_t::binary:
                JSONSerializer<other_binary_t>::to_json(*this, val.template get_ref<const other_binary_t&>());
                break;
            case value_t::null:
                *this = nullptr;
                break;
            case value_t::discarded:
                m_data.m_type = value_t::discarded;
                break;
            default:            // LCOV_EXCL_LINE
                JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
        }
        JSON_ASSERT(m_data.m_type == val.type());

        set_parents();
        assert_invariant();
    }

    /// @brief create a container (array or object) from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(initializer_list_t init,
               bool type_deduction = true,
               value_t manual_type = value_t::array)
    {
        // check if each element is an array with two elements whose first
        // element is a string
        bool is_an_object = std::all_of(init.begin(), init.end(),
                                        [](const detail::json_ref<basic_json>& element_ref)
        {
            // The cast is to ensure op[size_type] is called, bearing in mind size_type may not be int;
            // (many string types can be constructed from 0 via its null-pointer guise, so we get a
            // broken call to op[key_type], the wrong semantics, and a 4804 warning on Windows)
            return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[static_cast<size_type>(0)].is_string();
        });

        // adjust type if type deduction is not wanted
        if (!type_deduction)
        {
            // if an array is wanted, do not create an object though possible
            if (manual_type == value_t::array)
            {
                is_an_object = false;
            }

            // if an object is wanted but impossible, throw an exception
            if (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))
            {
                JSON_THROW(type_error::create(301, "cannot create object from initializer list", nullptr));
            }
        }

        if (is_an_object)
        {
            // the initializer list is a list of pairs -> create an object
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;

            for (auto& element_ref : init)
            {
                auto element = element_ref.moved_or_copied();
                m_data.m_value.object->emplace(
                    std::move(*((*element.m_data.m_value.array)[0].m_data.m_value.string)),
                    std::move((*element.m_data.m_value.array)[1]));
            }
        }
        else
        {
            // the initializer list describes an array -> create an array
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>(init.begin(), init.end());
        }

        set_parents();
        assert_invariant();
    }

    /// @brief explicitly create a binary array (without subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = init;
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(const typename binary_t::container_type& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(init, subtype);
        return res;
    }

    /// @brief explicitly create a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = std::move(init);
        return res;
    }

    /// @brief explicitly create a binary array (with subtype)
    /// @sa https://json.nlohmann.me/api/basic_json/binary/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json binary(typename binary_t::container_type&& init, typename binary_t::subtype_type subtype)
    {
        auto res = basic_json();
        res.m_data.m_type = value_t::binary;
        res.m_data.m_value = binary_t(std::move(init), subtype);
        return res;
    }

    /// @brief explicitly create an array from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/array/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json array(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::array);
    }

    /// @brief explicitly create an object from an initializer list
    /// @sa https://json.nlohmann.me/api/basic_json/object/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json object(initializer_list_t init = {})
    {
        return basic_json(init, false, value_t::object);
    }

    /// @brief construct an array with count copies of given value
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(size_type cnt, const basic_json& val):
        m_data{cnt, val}
    {
        set_parents();
        assert_invariant();
    }

    /// @brief construct a JSON container given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    template < class InputIT, typename std::enable_if <
                   std::is_same<InputIT, typename basic_json_t::iterator>::value ||
                   std::is_same<InputIT, typename basic_json_t::const_iterator>::value, int >::type = 0 >
    basic_json(InputIT first, InputIT last) // NOLINT(performance-unnecessary-value-param)
    {
        JSON_ASSERT(first.m_object != nullptr);
        JSON_ASSERT(last.m_object != nullptr);

        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(201, "iterators are not compatible", nullptr));
        }

        // copy type from the first iterator
        m_data.m_type = first.m_object->m_data.m_type;

        // check if the iterator range is complete for primitive values
        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            {
                if (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()
                                         || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", first.m_object));
                }
                break;
            }

            case value_t::null:
            case value_t::object:
            case value_t::array:
            case value_t::binary:
            case value_t::discarded:
            default:
                break;
        }

        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = first.m_object->m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = first.m_object->m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = first.m_object->m_data.m_value.number_float;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = first.m_object->m_data.m_value.boolean;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *first.m_object->m_data.m_value.string;
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object = create<object_t>(first.m_it.object_iterator,
                                        last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array = create<array_t>(first.m_it.array_iterator,
                                                       last.m_it.array_iterator);
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *first.m_object->m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(invalid_iterator::create(206, detail::concat("cannot construct with iterators from ", first.m_object->type_name()), first.m_object));
        }

        set_parents();
        assert_invariant();
    }

    ///////////////////////////////////////
    // other constructors and destructor //
    ///////////////////////////////////////

    template<typename JsonRef,
             detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,
                                 std::is_same<typename JsonRef::value_type, basic_json>>::value, int> = 0 >
    basic_json(const JsonRef& ref) : basic_json(ref.moved_or_copied()) {}

    /// @brief copy constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(const basic_json& other)
        : json_base_class_t(other)
#if JSON_DIAGNOSTIC_POSITIONS
        , start_position(other.start_position)
        , end_position(other.end_position)
#endif
    {
        m_data.m_type = other.m_data.m_type;
        // check of passed value is valid
        other.assert_invariant();

        switch (m_data.m_type)
        {
            case value_t::object:
            {
                m_data.m_value = *other.m_data.m_value.object;
                break;
            }

            case value_t::array:
            {
                m_data.m_value = *other.m_data.m_value.array;
                break;
            }

            case value_t::string:
            {
                m_data.m_value = *other.m_data.m_value.string;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value = other.m_data.m_value.boolean;
                break;
            }

            case value_t::number_integer:
            {
                m_data.m_value = other.m_data.m_value.number_integer;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value = other.m_data.m_value.number_unsigned;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value = other.m_data.m_value.number_float;
                break;
            }

            case value_t::binary:
            {
                m_data.m_value = *other.m_data.m_value.binary;
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }

        set_parents();
        assert_invariant();
    }

    /// @brief move constructor
    /// @sa https://json.nlohmann.me/api/basic_json/basic_json/
    basic_json(basic_json&& other) noexcept
        : json_base_class_t(std::forward<json_base_class_t>(other)),
          m_data(std::move(other.m_data)) // cppcheck-suppress[accessForwarded] TODO check
#if JSON_DIAGNOSTIC_POSITIONS
        , start_position(other.start_position) // cppcheck-suppress[accessForwarded] TODO check
        , end_position(other.end_position) // cppcheck-suppress[accessForwarded] TODO check
#endif
    {
        // check that the passed value is valid
        other.assert_invariant(false); // cppcheck-suppress[accessForwarded]

        // invalidate payload
        other.m_data.m_type = value_t::null;
        other.m_data.m_value = {};

#if JSON_DIAGNOSTIC_POSITIONS
        other.start_position = std::string::npos;
        other.end_position = std::string::npos;
#endif

        set_parents();
        assert_invariant();
    }

    /// @brief copy assignment
    /// @sa https://json.nlohmann.me/api/basic_json/operator=/
    basic_json& operator=(basic_json other) noexcept ( // NOLINT(cppcoreguidelines-c-copy-assignment-signature,misc-unconventional-assign-operator)
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&&
        std::is_nothrow_move_assignable<json_value>::value&&
        std::is_nothrow_move_assignable<json_base_class_t>::value
    )
    {
        // check that the passed value is valid
        other.assert_invariant();

        using std::swap;
        swap(m_data.m_type, other.m_data.m_type);
        swap(m_data.m_value, other.m_data.m_value);

#if JSON_DIAGNOSTIC_POSITIONS
        swap(start_position, other.start_position);
        swap(end_position, other.end_position);
#endif

        json_base_class_t::operator=(std::move(other));

        set_parents();
        assert_invariant();
        return *this;
    }

    /// @brief destructor
    /// @sa https://json.nlohmann.me/api/basic_json/~basic_json/
    ~basic_json() noexcept
    {
        assert_invariant(false);
    }

    /// @}

  public:
    ///////////////////////
    // object inspection //
    ///////////////////////

    /// @name object inspection
    /// Functions to inspect the type of a JSON value.
    /// @{

    /// @brief serialization
    /// @sa https://json.nlohmann.me/api/basic_json/dump/
    string_t dump(const int indent = -1,
                  const char indent_char = ' ',
                  const bool ensure_ascii = false,
                  const error_handler_t error_handler = error_handler_t::strict) const
    {
        string_t result;
        serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);

        if (indent >= 0)
        {
            s.dump(*this, true, ensure_ascii, static_cast<unsigned int>(indent));
        }
        else
        {
            s.dump(*this, false, ensure_ascii, 0);
        }

        return result;
    }

    /// @brief return the type of the JSON value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/type/
    constexpr value_t type() const noexcept
    {
        return m_data.m_type;
    }

    /// @brief return whether type is primitive
    /// @sa https://json.nlohmann.me/api/basic_json/is_primitive/
    constexpr bool is_primitive() const noexcept
    {
        return is_null() || is_string() || is_boolean() || is_number() || is_binary();
    }

    /// @brief return whether type is structured
    /// @sa https://json.nlohmann.me/api/basic_json/is_structured/
    constexpr bool is_structured() const noexcept
    {
        return is_array() || is_object();
    }

    /// @brief return whether value is null
    /// @sa https://json.nlohmann.me/api/basic_json/is_null/
    constexpr bool is_null() const noexcept
    {
        return m_data.m_type == value_t::null;
    }

    /// @brief return whether value is a boolean
    /// @sa https://json.nlohmann.me/api/basic_json/is_boolean/
    constexpr bool is_boolean() const noexcept
    {
        return m_data.m_type == value_t::boolean;
    }

    /// @brief return whether value is a number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number/
    constexpr bool is_number() const noexcept
    {
        return is_number_integer() || is_number_float();
    }

    /// @brief return whether value is an integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_integer/
    constexpr bool is_number_integer() const noexcept
    {
        return m_data.m_type == value_t::number_integer || m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is an unsigned integer number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_unsigned/
    constexpr bool is_number_unsigned() const noexcept
    {
        return m_data.m_type == value_t::number_unsigned;
    }

    /// @brief return whether value is a floating-point number
    /// @sa https://json.nlohmann.me/api/basic_json/is_number_float/
    constexpr bool is_number_float() const noexcept
    {
        return m_data.m_type == value_t::number_float;
    }

    /// @brief return whether value is an object
    /// @sa https://json.nlohmann.me/api/basic_json/is_object/
    constexpr bool is_object() const noexcept
    {
        return m_data.m_type == value_t::object;
    }

    /// @brief return whether value is an array
    /// @sa https://json.nlohmann.me/api/basic_json/is_array/
    constexpr bool is_array() const noexcept
    {
        return m_data.m_type == value_t::array;
    }

    /// @brief return whether value is a string
    /// @sa https://json.nlohmann.me/api/basic_json/is_string/
    constexpr bool is_string() const noexcept
    {
        return m_data.m_type == value_t::string;
    }

    /// @brief return whether value is a binary array
    /// @sa https://json.nlohmann.me/api/basic_json/is_binary/
    constexpr bool is_binary() const noexcept
    {
        return m_data.m_type == value_t::binary;
    }

    /// @brief return whether value is discarded
    /// @sa https://json.nlohmann.me/api/basic_json/is_discarded/
    constexpr bool is_discarded() const noexcept
    {
        return m_data.m_type == value_t::discarded;
    }

    /// @brief return the type of the JSON value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/operator_value_t/
    constexpr operator value_t() const noexcept
    {
        return m_data.m_type;
    }

    /// @}

  private:
    //////////////////
    // value access //
    //////////////////

    /// get a boolean (explicit)
    boolean_t get_impl(boolean_t* /*unused*/) const
    {
        if (JSON_HEDLEY_LIKELY(is_boolean()))
        {
            return m_data.m_value.boolean;
        }

        JSON_THROW(type_error::create(302, detail::concat("type must be boolean, but is ", type_name()), this));
    }

    /// get a pointer to the value (object)
    object_t* get_impl_ptr(object_t* /*unused*/) noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (object)
    constexpr const object_t* get_impl_ptr(const object_t* /*unused*/) const noexcept
    {
        return is_object() ? m_data.m_value.object : nullptr;
    }

    /// get a pointer to the value (array)
    array_t* get_impl_ptr(array_t* /*unused*/) noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (array)
    constexpr const array_t* get_impl_ptr(const array_t* /*unused*/) const noexcept
    {
        return is_array() ? m_data.m_value.array : nullptr;
    }

    /// get a pointer to the value (string)
    string_t* get_impl_ptr(string_t* /*unused*/) noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (string)
    constexpr const string_t* get_impl_ptr(const string_t* /*unused*/) const noexcept
    {
        return is_string() ? m_data.m_value.string : nullptr;
    }

    /// get a pointer to the value (boolean)
    boolean_t* get_impl_ptr(boolean_t* /*unused*/) noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (boolean)
    constexpr const boolean_t* get_impl_ptr(const boolean_t* /*unused*/) const noexcept
    {
        return is_boolean() ? &m_data.m_value.boolean : nullptr;
    }

    /// get a pointer to the value (integer number)
    number_integer_t* get_impl_ptr(number_integer_t* /*unused*/) noexcept
    {
        return m_data.m_type == value_t::number_integer ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (integer number)
    constexpr const number_integer_t* get_impl_ptr(const number_integer_t* /*unused*/) const noexcept
    {
        return m_data.m_type == value_t::number_integer ? &m_data.m_value.number_integer : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    number_unsigned_t* get_impl_ptr(number_unsigned_t* /*unused*/) noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (unsigned number)
    constexpr const number_unsigned_t* get_impl_ptr(const number_unsigned_t* /*unused*/) const noexcept
    {
        return is_number_unsigned() ? &m_data.m_value.number_unsigned : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    number_float_t* get_impl_ptr(number_float_t* /*unused*/) noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (floating-point number)
    constexpr const number_float_t* get_impl_ptr(const number_float_t* /*unused*/) const noexcept
    {
        return is_number_float() ? &m_data.m_value.number_float : nullptr;
    }

    /// get a pointer to the value (binary)
    binary_t* get_impl_ptr(binary_t* /*unused*/) noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /// get a pointer to the value (binary)
    constexpr const binary_t* get_impl_ptr(const binary_t* /*unused*/) const noexcept
    {
        return is_binary() ? m_data.m_value.binary : nullptr;
    }

    /*!
    @brief helper function to implement get_ref()

    This function helps to implement get_ref() without code duplication for
    const and non-const overloads

    @tparam ThisType will be deduced as `basic_json` or `const basic_json`

    @throw type_error.303 if ReferenceType does not match underlying value
    type of the current JSON
    */
    template<typename ReferenceType, typename ThisType>
    static ReferenceType get_ref_impl(ThisType& obj)
    {
        // delegate the call to get_ptr<>()
        auto* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();

        if (JSON_HEDLEY_LIKELY(ptr != nullptr))
        {
            return *ptr;
        }

        JSON_THROW(type_error::create(303, detail::concat("incompatible ReferenceType for get_ref, actual type is ", obj.type_name()), &obj));
    }

  public:
    /// @name value access
    /// Direct access to the stored value of a JSON value.
    /// @{

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>()
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

    /// @brief get a pointer value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ptr/
    template < typename PointerType, typename std::enable_if <
                   std::is_pointer<PointerType>::value&&
                   std::is_const<typename std::remove_pointer<PointerType>::type>::value, int >::type = 0 >
    constexpr auto get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {
        // delegate the call to get_impl_ptr<>() const
        return get_impl_ptr(static_cast<PointerType>(nullptr));
    }

  private:
    /*!
    @brief get a value (explicit)

    Explicit type conversion between the JSON value and a compatible value
    which is [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    ValueType ret;
    JSONSerializer<ValueType>::from_json(*this, ret);
    return ret;
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json,
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `void from_json(const basic_json&, ValueType&)`, and
    - @ref json_serializer<ValueType> does not have a `from_json()` method of
      the form `ValueType from_json(const basic_json&)`

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,get__ValueType_const}

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::is_default_constructible<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<0> /*unused*/) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))
    {
        auto ret = ValueType();
        JSONSerializer<ValueType>::from_json(*this, ret);
        return ret;
    }

    /*!
    @brief get a value (explicit); special case

    Explicit type conversion between the JSON value and a compatible value
    which is **not** [CopyConstructible](https://en.cppreference.com/w/cpp/named_req/CopyConstructible)
    and **not** [DefaultConstructible](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible).
    The value is converted by calling the @ref json_serializer<ValueType>
    `from_json()` method.

    The function is equivalent to executing
    @code {.cpp}
    return JSONSerializer<ValueType>::from_json(*this);
    @endcode

    This overloads is chosen if:
    - @a ValueType is not @ref basic_json and
    - @ref json_serializer<ValueType> has a `from_json()` method of the form
      `ValueType from_json(const basic_json&)`

    @note If @ref json_serializer<ValueType> has both overloads of
    `from_json()`, this one is chosen.

    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @a ValueType

    @throw what @ref json_serializer<ValueType> `from_json()` method throws

    @since version 2.1.0
    */
    template < typename ValueType,
               detail::enable_if_t <
                   detail::has_non_default_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType get_impl(detail::priority_tag<1> /*unused*/) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))
    {
        return JSONSerializer<ValueType>::from_json(*this);
    }

    /*!
    @brief get special-case overload

    This overloads converts the current @ref basic_json in a different
    @ref basic_json type

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this, converted into @a BasicJsonType

    @complexity Depending on the implementation of the called `from_json()`
                method.

    @since version 3.2.0
    */
    template < typename BasicJsonType,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value,
                   int > = 0 >
    BasicJsonType get_impl(detail::priority_tag<2> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get special-case overload

    This overloads avoids a lot of template boilerplate, it can be seen as the
    identity method

    @tparam BasicJsonType == @ref basic_json

    @return a copy of *this

    @complexity Constant.

    @since version 2.1.0
    */
    template<typename BasicJsonType,
             detail::enable_if_t<
                 std::is_same<BasicJsonType, basic_json_t>::value,
                 int> = 0>
    basic_json get_impl(detail::priority_tag<3> /*unused*/) const
    {
        return *this;
    }

    /*!
    @brief get a pointer value (explicit)
    @copydoc get()
    */
    template<typename PointerType,
             detail::enable_if_t<
                 std::is_pointer<PointerType>::value,
                 int> = 0>
    constexpr auto get_impl(detail::priority_tag<4> /*unused*/) const noexcept
    -> decltype(std::declval<const basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

  public:
    /*!
    @brief get a (pointer) value (explicit)

    Performs explicit type conversion between the JSON value and a compatible value if required.

    - If the requested type is a pointer to the internally stored JSON value that pointer is returned.
    No copies are made.

    - If the requested type is the current @ref basic_json, or a different @ref basic_json convertible
    from the current @ref basic_json.

    - Otherwise the value is converted by calling the @ref json_serializer<ValueType> `from_json()`
    method.

    @tparam ValueTypeCV the provided value type
    @tparam ValueType the returned value type

    @return copy of the JSON value, converted to @tparam ValueType if necessary

    @throw what @ref json_serializer<ValueType> `from_json()` method throws if conversion is required

    @since version 2.1.0
    */
    template < typename ValueTypeCV, typename ValueType = detail::uncvref_t<ValueTypeCV>>
#if defined(JSON_HAS_CPP_14)
    constexpr
#endif
    auto get() const noexcept(
    noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {})))
    -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> {}))
    {
        // we cannot static_assert on ValueTypeCV being non-const, because
        // there is support for get<const basic_json_t>(), which is why we
        // still need the uncvref
        static_assert(!std::is_reference<ValueTypeCV>::value,
                      "get() cannot be used with reference types, you might want to use get_ref()");
        return get_impl<ValueType>(detail::priority_tag<4> {});
    }

    /*!
    @brief get a pointer value (explicit)

    Explicit pointer access to the internally stored JSON value. No copies are
    made.

    @warning The pointer becomes invalid if the underlying JSON object
    changes.

    @tparam PointerType pointer type; must be a pointer to @ref array_t, @ref
    object_t, @ref string_t, @ref boolean_t, @ref number_integer_t,
    @ref number_unsigned_t, or @ref number_float_t.

    @return pointer to the internally stored JSON value if the requested
    pointer type @a PointerType fits to the JSON value; `nullptr` otherwise

    @complexity Constant.

    @liveexample{The example below shows how pointers to internal values of a
    JSON value can be requested. Note that no type conversions are made and a
    `nullptr` is returned if the value and the requested pointer type does not
    match.,get__PointerType}

    @sa see @ref get_ptr() for explicit pointer-member access

    @since version 1.0.0
    */
    template<typename PointerType, typename std::enable_if<
                 std::is_pointer<PointerType>::value, int>::type = 0>
    auto get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())
    {
        // delegate the call to get_ptr
        return get_ptr<PointerType>();
    }

    /// @brief get a value (explicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_to/
    template < typename ValueType,
               detail::enable_if_t <
                   !detail::is_basic_json<ValueType>::value&&
                   detail::has_from_json<basic_json_t, ValueType>::value,
                   int > = 0 >
    ValueType & get_to(ValueType& v) const noexcept(noexcept(
            JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<ValueType>::from_json(*this, v);
        return v;
    }

    // specialization to allow calling get_to with a basic_json value
    // see https://github.com/nlohmann/json/issues/2175
    template<typename ValueType,
             detail::enable_if_t <
                 detail::is_basic_json<ValueType>::value,
                 int> = 0>
    ValueType & get_to(ValueType& v) const
    {
        v = *this;
        return v;
    }

    template <
        typename T, std::size_t N,
        typename Array = T (&)[N], // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
        detail::enable_if_t <
            detail::has_from_json<basic_json_t, Array>::value, int > = 0 >
    Array get_to(T (&v)[N]) const // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
    noexcept(noexcept(JSONSerializer<Array>::from_json(
                          std::declval<const basic_json_t&>(), v)))
    {
        JSONSerializer<Array>::from_json(*this, v);
        return v;
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template<typename ReferenceType, typename std::enable_if<
                 std::is_reference<ReferenceType>::value, int>::type = 0>
    ReferenceType get_ref()
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /// @brief get a reference value (implicit)
    /// @sa https://json.nlohmann.me/api/basic_json/get_ref/
    template < typename ReferenceType, typename std::enable_if <
                   std::is_reference<ReferenceType>::value&&
                   std::is_const<typename std::remove_reference<ReferenceType>::type>::value, int >::type = 0 >
    ReferenceType get_ref() const
    {
        // delegate call to get_ref_impl
        return get_ref_impl<ReferenceType>(*this);
    }

    /*!
    @brief get a value (implicit)

    Implicit type conversion between the JSON value and a compatible value.
    The call is realized by calling @ref get() const.

    @tparam ValueType non-pointer type compatible to the JSON value, for
    instance `int` for JSON integer numbers, `bool` for JSON booleans, or
    `std::vector` types for JSON arrays. The character type of @ref string_t
    as well as an initializer list of this type is excluded to avoid
    ambiguities as these types implicitly convert to `std::string`.

    @return copy of the JSON value, converted to type @a ValueType

    @throw type_error.302 in case passed type @a ValueType is incompatible
    to the JSON value type (e.g., the JSON value is of type boolean, but a
    string is requested); see example below

    @complexity Linear in the size of the JSON value.

    @liveexample{The example below shows several conversions from JSON values
    to other types. There a few things to note: (1) Floating-point numbers can
    be converted to integers\, (2) A JSON array can be converted to a standard
    `std::vector<short>`\, (3) A JSON object can be converted to C++
    associative containers such as `std::unordered_map<std::string\,
    json>`.,operator__ValueType}

    @since version 1.0.0
    */
    template < typename ValueType, typename std::enable_if <
                   detail::conjunction <
                       detail::negation<std::is_pointer<ValueType>>,
                       detail::negation<std::is_same<ValueType, std::nullptr_t>>,
                       detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,
                                        detail::negation<std::is_same<ValueType, typename string_t::value_type>>,
                                        detail::negation<detail::is_basic_json<ValueType>>,
                                        detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,
#if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))
                                                detail::negation<std::is_same<ValueType, std::string_view>>,
#endif
#if defined(JSON_HAS_CPP_17) && JSON_HAS_STATIC_RTTI
                                                detail::negation<std::is_same<ValueType, std::any>>,
#endif
                                                detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>
                                                >::value, int >::type = 0 >
                                        JSON_EXPLICIT operator ValueType() const
    {
        // delegate the call to get<>() const
        return get<ValueType>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    binary_t& get_binary()
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<binary_t*>();
    }

    /// @brief get a binary value
    /// @sa https://json.nlohmann.me/api/basic_json/get_binary/
    const binary_t& get_binary() const
    {
        if (!is_binary())
        {
            JSON_THROW(type_error::create(302, detail::concat("type must be binary, but is ", type_name()), this));
        }

        return *get_ptr<const binary_t*>();
    }

    /// @}

    ////////////////////
    // element access //
    ////////////////////

    /// @name element access
    /// Access to the JSON value.
    /// @{

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(size_type idx)
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return set_parent(m_data.m_value.array->at(idx));
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create a better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            } // cppcheck-suppress[missingReturn]
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified array element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(size_type idx) const
    {
        // at only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            JSON_TRY
            {
                return m_data.m_value.array->at(idx);
            }
            JSON_CATCH (std::out_of_range&)
            {
                // create a better exception explanation
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            } // cppcheck-suppress[missingReturn]
        }
        else
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const typename object_t::key_type& key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    reference at(KeyType && key)
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return set_parent(it->second);
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const typename object_t::key_type& key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(key);
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", key, "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified object element with bounds checking
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_reference at(KeyType && key) const
    {
        // at only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(304, detail::concat("cannot use at() with ", type_name()), this));
        }

        auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it == m_data.m_value.object->end())
        {
            JSON_THROW(out_of_range::create(403, detail::concat("key '", string_t(std::forward<KeyType>(key)), "' not found"), this));
        }
        return it->second;
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](size_type idx)
    {
        // implicitly convert a null value to an empty array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value.array = create<array_t>();
            assert_invariant();
        }

        // operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // fill up the array with null values if given idx is outside the range
            if (idx >= m_data.m_value.array->size())
            {
#if JSON_DIAGNOSTICS
                // remember array size & capacity before resizing
                const auto old_size = m_data.m_value.array->size();
                const auto old_capacity = m_data.m_value.array->capacity();
#endif
                m_data.m_value.array->resize(idx + 1);

#if JSON_DIAGNOSTICS
                if (JSON_HEDLEY_UNLIKELY(m_data.m_value.array->capacity() != old_capacity))
                {
                    // capacity has changed: update all parents
                    set_parents();
                }
                else
                {
                    // set parent for values added above
                    set_parents(begin() + static_cast<typename iterator::difference_type>(old_size), static_cast<typename iterator::difference_type>(idx + 1 - old_size));
                }
#endif
                assert_invariant();
            }

            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified array element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](size_type idx) const
    {
        // const operator[] only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            return m_data.m_value.array->operator[](idx);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a numeric argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](typename object_t::key_type key) // NOLINT(performance-unnecessary-value-param)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::move(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const typename object_t::key_type& key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(key);
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    // these two functions resolve a (const) char * ambiguity affecting Clang and MSVC
    // (they seemingly cannot be constrained to resolve the ambiguity)
    template<typename T>
    reference operator[](T* key)
    {
        return operator[](typename object_t::key_type(key));
    }

    template<typename T>
    const_reference operator[](T* key) const
    {
        return operator[](typename object_t::key_type(key));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    reference operator[](KeyType && key)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        // operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto result = m_data.m_value.object->emplace(std::forward<KeyType>(key), nullptr);
            return set_parent(result.first->second);
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

    /// @brief access specified object element
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int > = 0 >
    const_reference operator[](KeyType && key) const
    {
        // const operator[] only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
            JSON_ASSERT(it != m_data.m_value.object->end());
            return it->second;
        }

        JSON_THROW(type_error::create(305, detail::concat("cannot use operator[] with a string argument with ", type_name()), this));
    }

  private:
    template<typename KeyType>
    using is_comparable_with_object_key = detail::is_comparable <
        object_comparator_t, const typename object_t::key_type&, KeyType >;

    template<typename ValueType>
    using value_return_type = std::conditional <
        detail::is_c_string_uncvref<ValueType>::value,
        string_t, typename std::decay<ValueType>::type >;

  public:
    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const typename object_t::key_type& key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   !detail::is_transparent<object_comparator_t>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const typename object_t::key_type& key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(key);
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(KeyType && key, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ValueType>();
            }

            return default_value;
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class KeyType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_transparent<object_comparator_t>::value
                   && !detail::is_json_pointer<KeyType>::value
                   && is_comparable_with_object_key<KeyType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(KeyType && key, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If 'key' is found, return its value. Otherwise, return `default_value'.
            const auto it = find(std::forward<KeyType>(key));
            if (it != end())
            {
                return it->template get<ReturnType>();
            }

            return std::forward<ValueType>(default_value);
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, detail::enable_if_t <
                   detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ValueType value(const json_pointer& ptr, const ValueType& default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If the pointer resolves to a value, return it. Otherwise, return
            // 'default_value'.
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ValueType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return default_value;
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    /// @brief access specified object element via JSON Pointer with default value
    /// @sa https://json.nlohmann.me/api/basic_json/value/
    template < class ValueType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    ReturnType value(const json_pointer& ptr, ValueType && default_value) const
    {
        // value only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            // If the pointer resolves to a value, return it. Otherwise, return
            // 'default_value'.
            JSON_TRY
            {
                return ptr.get_checked(this).template get<ReturnType>();
            }
            JSON_INTERNAL_CATCH (out_of_range&)
            {
                return std::forward<ValueType>(default_value);
            }
        }

        JSON_THROW(type_error::create(306, detail::concat("cannot use value() with ", type_name()), this));
    }

    template < class ValueType, class BasicJsonType, detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ValueType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ValueType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, const ValueType& default_value) const
    {
        return value(ptr.convert(), default_value);
    }

    template < class ValueType, class BasicJsonType, class ReturnType = typename value_return_type<ValueType>::type,
               detail::enable_if_t <
                   detail::is_basic_json<BasicJsonType>::value
                   && detail::is_getable<basic_json_t, ReturnType>::value
                   && !std::is_same<value_t, detail::uncvref_t<ValueType>>::value, int > = 0 >
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    ReturnType value(const ::nlohmann::json_pointer<BasicJsonType>& ptr, ValueType && default_value) const
    {
        return value(ptr.convert(), std::forward<ValueType>(default_value));
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    reference front()
    {
        return *begin();
    }

    /// @brief access the first element
    /// @sa https://json.nlohmann.me/api/basic_json/front/
    const_reference front() const
    {
        return *cbegin();
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    reference back()
    {
        auto tmp = end();
        --tmp;
        return *tmp;
    }

    /// @brief access the last element
    /// @sa https://json.nlohmann.me/api/basic_json/back/
    const_reference back() const
    {
        auto tmp = cend();
        --tmp;
        return *tmp;
    }

    /// @brief remove element given an iterator
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType pos) // NOLINT(performance-unnecessary-value-param)
    {
        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != pos.m_object))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))
                {
                    JSON_THROW(invalid_iterator::create(205, "iterator out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(pos.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(pos.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

    /// @brief remove elements given an iterator range
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template < class IteratorType, detail::enable_if_t <
                   std::is_same<IteratorType, typename basic_json_t::iterator>::value ||
                   std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, int > = 0 >
    IteratorType erase(IteratorType first, IteratorType last) // NOLINT(performance-unnecessary-value-param)
    {
        // make sure the iterator fits the current value
        if (JSON_HEDLEY_UNLIKELY(this != first.m_object || this != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(203, "iterators do not fit current value", this));
        }

        IteratorType result = end();

        switch (m_data.m_type)
        {
            case value_t::boolean:
            case value_t::number_float:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::string:
            case value_t::binary:
            {
                if (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()
                                       || !last.m_it.primitive_iterator.is_end()))
                {
                    JSON_THROW(invalid_iterator::create(204, "iterators out of range", this));
                }

                if (is_string())
                {
                    AllocatorType<string_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.string);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.string, 1);
                    m_data.m_value.string = nullptr;
                }
                else if (is_binary())
                {
                    AllocatorType<binary_t> alloc;
                    std::allocator_traits<decltype(alloc)>::destroy(alloc, m_data.m_value.binary);
                    std::allocator_traits<decltype(alloc)>::deallocate(alloc, m_data.m_value.binary, 1);
                    m_data.m_value.binary = nullptr;
                }

                m_data.m_type = value_t::null;
                assert_invariant();
                break;
            }

            case value_t::object:
            {
                result.m_it.object_iterator = m_data.m_value.object->erase(first.m_it.object_iterator,
                                              last.m_it.object_iterator);
                break;
            }

            case value_t::array:
            {
                result.m_it.array_iterator = m_data.m_value.array->erase(first.m_it.array_iterator,
                                             last.m_it.array_iterator);
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return result;
    }

  private:
    template < typename KeyType, detail::enable_if_t <
                   detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        return m_data.m_value.object->erase(std::forward<KeyType>(key));
    }

    template < typename KeyType, detail::enable_if_t <
                   !detail::has_erase_with_key_type<basic_json_t, KeyType>::value, int > = 0 >
    size_type erase_internal(KeyType && key)
    {
        // this erase only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }

        const auto it = m_data.m_value.object->find(std::forward<KeyType>(key));
        if (it != m_data.m_value.object->end())
        {
            m_data.m_value.object->erase(it);
            return 1;
        }
        return 0;
    }

  public:

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    size_type erase(const typename object_t::key_type& key)
    {
        // the indirection via erase_internal() is added to avoid making this
        // function a template and thus de-rank it during overload resolution
        return erase_internal(key);
    }

    /// @brief remove element from a JSON object given a key
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type erase(KeyType && key)
    {
        return erase_internal(std::forward<KeyType>(key));
    }

    /// @brief remove element from a JSON array given an index
    /// @sa https://json.nlohmann.me/api/basic_json/erase/
    void erase(const size_type idx)
    {
        // this erase only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            if (JSON_HEDLEY_UNLIKELY(idx >= size()))
            {
                JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), this));
            }

            m_data.m_value.array->erase(m_data.m_value.array->begin() + static_cast<difference_type>(idx));
        }
        else
        {
            JSON_THROW(type_error::create(307, detail::concat("cannot use erase() with ", type_name()), this));
        }
    }

    /// @}

    ////////////
    // lookup //
    ////////////

    /// @name lookup
    /// @{

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    iterator find(const typename object_t::key_type& key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    const_iterator find(const typename object_t::key_type& key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(key);
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    iterator find(KeyType && key)
    {
        auto result = end();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief find an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/find/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    const_iterator find(KeyType && key) const
    {
        auto result = cend();

        if (is_object())
        {
            result.m_it.object_iterator = m_data.m_value.object->find(std::forward<KeyType>(key));
        }

        return result;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    size_type count(const typename object_t::key_type& key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(key) : 0;
    }

    /// @brief returns the number of occurrences of a key in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/count/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    size_type count(KeyType && key) const
    {
        // return 0 for all nonobject types
        return is_object() ? m_data.m_value.object->count(std::forward<KeyType>(key)) : 0;
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const typename object_t::key_type& key) const
    {
        return is_object() && m_data.m_value.object->find(key) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    template<class KeyType, detail::enable_if_t<
                 detail::is_usable_as_basic_json_key_type<basic_json_t, KeyType>::value, int> = 0>
    bool contains(KeyType && key) const
    {
        return is_object() && m_data.m_value.object->find(std::forward<KeyType>(key)) != m_data.m_value.object->end();
    }

    /// @brief check the existence of an element in a JSON object given a JSON pointer
    /// @sa https://json.nlohmann.me/api/basic_json/contains/
    bool contains(const json_pointer& ptr) const
    {
        return ptr.contains(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    bool contains(const typename ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.contains(this);
    }

    /// @}

    ///////////////
    // iterators //
    ///////////////

    /// @name iterators
    /// @{

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    iterator begin() noexcept
    {
        iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/begin/
    const_iterator begin() const noexcept
    {
        return cbegin();
    }

    /// @brief returns a const iterator to the first element
    /// @sa https://json.nlohmann.me/api/basic_json/cbegin/
    const_iterator cbegin() const noexcept
    {
        const_iterator result(this);
        result.set_begin();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    iterator end() noexcept
    {
        iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/end/
    const_iterator end() const noexcept
    {
        return cend();
    }

    /// @brief returns an iterator to one past the last element
    /// @sa https://json.nlohmann.me/api/basic_json/cend/
    const_iterator cend() const noexcept
    {
        const_iterator result(this);
        result.set_end();
        return result;
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    reverse_iterator rbegin() noexcept
    {
        return reverse_iterator(end());
    }

    /// @brief returns an iterator to the reverse-beginning
    /// @sa https://json.nlohmann.me/api/basic_json/rbegin/
    const_reverse_iterator rbegin() const noexcept
    {
        return crbegin();
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    reverse_iterator rend() noexcept
    {
        return reverse_iterator(begin());
    }

    /// @brief returns an iterator to the reverse-end
    /// @sa https://json.nlohmann.me/api/basic_json/rend/
    const_reverse_iterator rend() const noexcept
    {
        return crend();
    }

    /// @brief returns a const reverse iterator to the last element
    /// @sa https://json.nlohmann.me/api/basic_json/crbegin/
    const_reverse_iterator crbegin() const noexcept
    {
        return const_reverse_iterator(cend());
    }

    /// @brief returns a const reverse iterator to one before the first
    /// @sa https://json.nlohmann.me/api/basic_json/crend/
    const_reverse_iterator crend() const noexcept
    {
        return const_reverse_iterator(cbegin());
    }

  public:
    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///             version 4.0.0 of the library. Please use @ref items() instead;
    ///             that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief wrapper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    /// @deprecated This function is deprecated since 3.1.0 and will be removed in
    ///         version 4.0.0 of the library. Please use @ref items() instead;
    ///         that is, replace `json::iterator_wrapper(j)` with `j.items()`.
    JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())
    static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept
    {
        return ref.items();
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<iterator> items() noexcept
    {
        return iteration_proxy<iterator>(*this);
    }

    /// @brief helper to access iterator member functions in range-based for
    /// @sa https://json.nlohmann.me/api/basic_json/items/
    iteration_proxy<const_iterator> items() const noexcept
    {
        return iteration_proxy<const_iterator>(*this);
    }

    /// @}

    //////////////
    // capacity //
    //////////////

    /// @name capacity
    /// @{

    /// @brief checks whether the container is empty.
    /// @sa https://json.nlohmann.me/api/basic_json/empty/
    bool empty() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return true;
            }

            case value_t::array:
            {
                // delegate call to array_t::empty()
                return m_data.m_value.array->empty();
            }

            case value_t::object:
            {
                // delegate call to object_t::empty()
                return m_data.m_value.object->empty();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types are nonempty
                return false;
            }
        }
    }

    /// @brief returns the number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/size/
    size_type size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
            {
                // null values are empty
                return 0;
            }

            case value_t::array:
            {
                // delegate call to array_t::size()
                return m_data.m_value.array->size();
            }

            case value_t::object:
            {
                // delegate call to object_t::size()
                return m_data.m_value.object->size();
            }

            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have size 1
                return 1;
            }
        }
    }

    /// @brief returns the maximum possible number of elements
    /// @sa https://json.nlohmann.me/api/basic_json/max_size/
    size_type max_size() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::array:
            {
                // delegate call to array_t::max_size()
                return m_data.m_value.array->max_size();
            }

            case value_t::object:
            {
                // delegate call to object_t::max_size()
                return m_data.m_value.object->max_size();
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // all other types have max_size() == size()
                return size();
            }
        }
    }

    /// @}

    ///////////////
    // modifiers //
    ///////////////

    /// @name modifiers
    /// @{

    /// @brief clears the contents
    /// @sa https://json.nlohmann.me/api/basic_json/clear/
    void clear() noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::number_integer:
            {
                m_data.m_value.number_integer = 0;
                break;
            }

            case value_t::number_unsigned:
            {
                m_data.m_value.number_unsigned = 0;
                break;
            }

            case value_t::number_float:
            {
                m_data.m_value.number_float = 0.0;
                break;
            }

            case value_t::boolean:
            {
                m_data.m_value.boolean = false;
                break;
            }

            case value_t::string:
            {
                m_data.m_value.string->clear();
                break;
            }

            case value_t::binary:
            {
                m_data.m_value.binary->clear();
                break;
            }

            case value_t::array:
            {
                m_data.m_value.array->clear();
                break;
            }

            case value_t::object:
            {
                m_data.m_value.object->clear();
                break;
            }

            case value_t::null:
            case value_t::discarded:
            default:
                break;
        }
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(basic_json&& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array (move semantics)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(std::move(val));
        set_parent(m_data.m_value.array->back(), old_capacity);
        // if val is moved from, basic_json move constructor marks it null, so we do not call the destructor
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(basic_json&& val)
    {
        push_back(std::move(val));
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const basic_json& val)
    {
        // push_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->push_back(val);
        set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const basic_json& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(const typename object_t::value_type& val)
    {
        // push_back only works for null objects or objects
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(308, detail::concat("cannot use push_back() with ", type_name()), this));
        }

        // transform a null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add the element to the object
        auto res = m_data.m_value.object->insert(val);
        set_parent(res.first->second);
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(const typename object_t::value_type& val)
    {
        push_back(val);
        return *this;
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/push_back/
    void push_back(initializer_list_t init)
    {
        if (is_object() && init.size() == 2 && (*init.begin())->is_string())
        {
            basic_json&& key = init.begin()->moved_or_copied();
            push_back(typename object_t::value_type(
                          std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));
        }
        else
        {
            push_back(basic_json(init));
        }
    }

    /// @brief add an object to an object
    /// @sa https://json.nlohmann.me/api/basic_json/operator+=/
    reference operator+=(initializer_list_t init)
    {
        push_back(init);
        return *this;
    }

    /// @brief add an object to an array
    /// @sa https://json.nlohmann.me/api/basic_json/emplace_back/
    template<class... Args>
    reference emplace_back(Args&& ... args)
    {
        // emplace_back only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace_back() with ", type_name()), this));
        }

        // transform a null object into an array
        if (is_null())
        {
            m_data.m_type = value_t::array;
            m_data.m_value = value_t::array;
            assert_invariant();
        }

        // add the element to the array (perfect forwarding)
        const auto old_capacity = m_data.m_value.array->capacity();
        m_data.m_value.array->emplace_back(std::forward<Args>(args)...);
        return set_parent(m_data.m_value.array->back(), old_capacity);
    }

    /// @brief add an object to an object if key does not exist
    /// @sa https://json.nlohmann.me/api/basic_json/emplace/
    template<class... Args>
    std::pair<iterator, bool> emplace(Args&& ... args)
    {
        // emplace only works for null objects or arrays
        if (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))
        {
            JSON_THROW(type_error::create(311, detail::concat("cannot use emplace() with ", type_name()), this));
        }

        // transform a null object into an object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value = value_t::object;
            assert_invariant();
        }

        // add the element to the array (perfect forwarding)
        auto res = m_data.m_value.object->emplace(std::forward<Args>(args)...);
        set_parent(res.first->second);

        // create a result iterator and set iterator to the result of emplace
        auto it = begin();
        it.m_it.object_iterator = res.first;

        // return pair of iterator and boolean
        return {it, res.second};
    }

    /// Helper for insertion of an iterator
    /// @note: This uses std::distance to support GCC 4.8,
    ///        see https://github.com/nlohmann/json/pull/1257
    template<typename... Args>
    iterator insert_iterator(const_iterator pos, Args&& ... args) // NOLINT(performance-unnecessary-value-param)
    {
        iterator result(this);
        JSON_ASSERT(m_data.m_value.array != nullptr);

        auto insert_pos = std::distance(m_data.m_value.array->begin(), pos.m_it.array_iterator);
        m_data.m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);
        result.m_it.array_iterator = m_data.m_value.array->begin() + insert_pos;

        // This could have been written as:
        // result.m_it.array_iterator = m_data.m_value.array->insert(pos.m_it.array_iterator, cnt, val);
        // but the return value of insert is missing in GCC 4.8, so it is written this way instead.

        set_parents();
        return result;
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const basic_json& val) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, basic_json&& val) // NOLINT(performance-unnecessary-value-param)
    {
        return insert(pos, val);
    }

    /// @brief inserts copies of element into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, size_type cnt, const basic_json& val) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            // check if iterator pos fits to this JSON value
            if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
            {
                JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
            }

            // insert to array and return iterator
            return insert_iterator(pos, cnt, val);
        }

        JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
    }

    /// @brief inserts range of elements into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, const_iterator first, const_iterator last) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        if (JSON_HEDLEY_UNLIKELY(first.m_object == this))
        {
            JSON_THROW(invalid_iterator::create(211, "passed iterators may not belong to container", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);
    }

    /// @brief inserts elements from initializer list into array
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    iterator insert(const_iterator pos, initializer_list_t ilist) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for arrays
        if (JSON_HEDLEY_UNLIKELY(!is_array()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if iterator pos fits to this JSON value
        if (JSON_HEDLEY_UNLIKELY(pos.m_object != this))
        {
            JSON_THROW(invalid_iterator::create(202, "iterator does not fit current value", this));
        }

        // insert to array and return iterator
        return insert_iterator(pos, ilist.begin(), ilist.end());
    }

    /// @brief inserts range of elements into object
    /// @sa https://json.nlohmann.me/api/basic_json/insert/
    void insert(const_iterator first, const_iterator last) // NOLINT(performance-unnecessary-value-param)
    {
        // insert only works for objects
        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(309, detail::concat("cannot use insert() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(invalid_iterator::create(202, "iterators first and last must point to objects", this));
        }

        m_data.m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);
        set_parents();
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_reference j, bool merge_objects = false)
    {
        update(j.begin(), j.end(), merge_objects);
    }

    /// @brief updates a JSON object from another object, overwriting existing keys
    /// @sa https://json.nlohmann.me/api/basic_json/update/
    void update(const_iterator first, const_iterator last, bool merge_objects = false) // NOLINT(performance-unnecessary-value-param)
    {
        // implicitly convert a null value to an empty object
        if (is_null())
        {
            m_data.m_type = value_t::object;
            m_data.m_value.object = create<object_t>();
            assert_invariant();
        }

        if (JSON_HEDLEY_UNLIKELY(!is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", type_name()), this));
        }

        // check if range iterators belong to the same JSON object
        if (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))
        {
            JSON_THROW(invalid_iterator::create(210, "iterators do not fit", this));
        }

        // passed iterators must belong to objects
        if (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))
        {
            JSON_THROW(type_error::create(312, detail::concat("cannot use update() with ", first.m_object->type_name()), first.m_object));
        }

        for (auto it = first; it != last; ++it)
        {
            if (merge_objects && it.value().is_object())
            {
                auto it2 = m_data.m_value.object->find(it.key());
                if (it2 != m_data.m_value.object->end())
                {
                    it2->second.update(it.value(), true);
                    continue;
                }
            }
            m_data.m_value.object->operator[](it.key()) = it.value();
#if JSON_DIAGNOSTICS
            m_data.m_value.object->operator[](it.key()).m_parent = this;
#endif
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(reference other) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        std::swap(m_data.m_type, other.m_data.m_type);
        std::swap(m_data.m_value, other.m_data.m_value);

        set_parents();
        other.set_parents();
        assert_invariant();
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    friend void swap(reference left, reference right) noexcept (
        std::is_nothrow_move_constructible<value_t>::value&&
        std::is_nothrow_move_assignable<value_t>::value&&
        std::is_nothrow_move_constructible<json_value>::value&& // NOLINT(cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
        std::is_nothrow_move_assignable<json_value>::value
    )
    {
        left.swap(right);
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(array_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for arrays
        if (JSON_HEDLEY_LIKELY(is_array()))
        {
            using std::swap;
            swap(*(m_data.m_value.array), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(array_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(object_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for objects
        if (JSON_HEDLEY_LIKELY(is_object()))
        {
            using std::swap;
            swap(*(m_data.m_value.object), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(object_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(string_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_string()))
        {
            using std::swap;
            swap(*(m_data.m_value.string), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(string_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(binary_t& other) // NOLINT(bugprone-exception-escape,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t&) with ", type_name()), this));
        }
    }

    /// @brief exchanges the values
    /// @sa https://json.nlohmann.me/api/basic_json/swap/
    void swap(typename binary_t::container_type& other) // NOLINT(bugprone-exception-escape)
    {
        // swap only works for strings
        if (JSON_HEDLEY_LIKELY(is_binary()))
        {
            using std::swap;
            swap(*(m_data.m_value.binary), other);
        }
        else
        {
            JSON_THROW(type_error::create(310, detail::concat("cannot use swap(binary_t::container_type&) with ", type_name()), this));
        }
    }

    /// @}

    //////////////////////////////////////////
    // lexicographical comparison operators //
    //////////////////////////////////////////

    /// @name lexicographical comparison operators
    /// @{

    // note parentheses around operands are necessary; see
    // https://github.com/nlohmann/json/issues/1530
#define JSON_IMPLEMENT_OPERATOR(op, null_result, unordered_result, default_result)                       \
    const auto lhs_type = lhs.type();                                                                    \
    const auto rhs_type = rhs.type();                                                                    \
    \
    if (lhs_type == rhs_type) /* NOLINT(readability/braces) */                                           \
    {                                                                                                    \
        switch (lhs_type)                                                                                \
        {                                                                                                \
            case value_t::array:                                                                         \
                return (*lhs.m_data.m_value.array) op (*rhs.m_data.m_value.array);                                     \
                \
            case value_t::object:                                                                        \
                return (*lhs.m_data.m_value.object) op (*rhs.m_data.m_value.object);                                   \
                \
            case value_t::null:                                                                          \
                return (null_result);                                                                    \
                \
            case value_t::string:                                                                        \
                return (*lhs.m_data.m_value.string) op (*rhs.m_data.m_value.string);                                   \
                \
            case value_t::boolean:                                                                       \
                return (lhs.m_data.m_value.boolean) op (rhs.m_data.m_value.boolean);                                   \
                \
            case value_t::number_integer:                                                                \
                return (lhs.m_data.m_value.number_integer) op (rhs.m_data.m_value.number_integer);                     \
                \
            case value_t::number_unsigned:                                                               \
                return (lhs.m_data.m_value.number_unsigned) op (rhs.m_data.m_value.number_unsigned);                   \
                \
            case value_t::number_float:                                                                  \
                return (lhs.m_data.m_value.number_float) op (rhs.m_data.m_value.number_float);                         \
                \
            case value_t::binary:                                                                        \
                return (*lhs.m_data.m_value.binary) op (*rhs.m_data.m_value.binary);                                   \
                \
            case value_t::discarded:                                                                     \
            default:                                                                                     \
                return (unordered_result);                                                               \
        }                                                                                                \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)                   \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_integer) op rhs.m_data.m_value.number_float;      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)                   \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_integer);      \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)                  \
    {                                                                                                    \
        return static_cast<number_float_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_float;     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)                  \
    {                                                                                                    \
        return lhs.m_data.m_value.number_float op static_cast<number_float_t>(rhs.m_data.m_value.number_unsigned);     \
    }                                                                                                    \
    else if (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)                \
    {                                                                                                    \
        return static_cast<number_integer_t>(lhs.m_data.m_value.number_unsigned) op rhs.m_data.m_value.number_integer; \
    }                                                                                                    \
    else if (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)                \
    {                                                                                                    \
        return lhs.m_data.m_value.number_integer op static_cast<number_integer_t>(rhs.m_data.m_value.number_unsigned); \
    }                                                                                                    \
    else if(compares_unordered(lhs, rhs))\
    {\
        return (unordered_result);\
    }\
    \
    return (default_result);

  JSON_PRIVATE_UNLESS_TESTED:
    // returns true if:
    // - any operand is NaN and the other operand is of number type
    // - any operand is discarded
    // in legacy mode, discarded values are considered ordered if
    // an operation is computed as an odd number of inverses of others
    static bool compares_unordered(const_reference lhs, const_reference rhs, bool inverse = false) noexcept
    {
        if ((lhs.is_number_float() && std::isnan(lhs.m_data.m_value.number_float) && rhs.is_number())
                || (rhs.is_number_float() && std::isnan(rhs.m_data.m_value.number_float) && lhs.is_number()))
        {
            return true;
        }
#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
        return (lhs.is_discarded() || rhs.is_discarded()) && !inverse;
#else
        static_cast<void>(inverse);
        return lhs.is_discarded() || rhs.is_discarded();
#endif
    }

  private:
    bool compares_unordered(const_reference rhs, bool inverse = false) const noexcept
    {
        return compares_unordered(*this, rhs, inverse);
    }

  public:
#if JSON_HAS_THREE_WAY_COMPARISON
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    bool operator==(const_reference rhs) const noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        const_reference lhs = *this;
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator==(ScalarType rhs) const noexcept
    {
        return *this == basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    bool operator!=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !operator==(rhs);
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    std::partial_ordering operator<=>(const_reference rhs) const noexcept // *NOPAD*
    {
        const_reference lhs = *this;
        // default_result is used if we cannot compare values. In that case,
        // we compare types.
        JSON_IMPLEMENT_OPERATOR(<=>, // *NOPAD*
                                std::partial_ordering::equivalent,
                                std::partial_ordering::unordered,
                                lhs_type <=> rhs_type) // *NOPAD*
    }

    /// @brief comparison: 3-way
    /// @sa https://json.nlohmann.me/api/basic_json/operator_spaceship/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    std::partial_ordering operator<=>(ScalarType rhs) const noexcept // *NOPAD*
    {
        return *this <=> basic_json(rhs); // *NOPAD*
    }

#if JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
    // all operators that are computed as an odd number of inverses of others
    // need to be overloaded to emulate the legacy comparison behavior

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator<=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(rhs < *this);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator<=(ScalarType rhs) const noexcept
    {
        return *this <= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON)
    bool operator>=(const_reference rhs) const noexcept
    {
        if (compares_unordered(rhs, true))
        {
            return false;
        }
        return !(*this < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType>
    requires std::is_scalar_v<ScalarType>
    bool operator>=(ScalarType rhs) const noexcept
    {
        return *this >= basic_json(rhs);
    }
#endif
#else
    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    friend bool operator==(const_reference lhs, const_reference rhs) noexcept
    {
#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
#endif
        JSON_IMPLEMENT_OPERATOR( ==, true, false, false)
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs == basic_json(rhs);
    }

    /// @brief comparison: equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_eq/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator==(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) == rhs;
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    friend bool operator!=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs == rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs != basic_json(rhs);
    }

    /// @brief comparison: not equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ne/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator!=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) != rhs;
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    friend bool operator<(const_reference lhs, const_reference rhs) noexcept
    {
        // default_result is used if we cannot compare values. In that case,
        // we compare types. Note we have to call the operator explicitly,
        // because MSVC has problems otherwise.
        JSON_IMPLEMENT_OPERATOR( <, false, false, operator<(lhs_type, rhs_type))
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs < basic_json(rhs);
    }

    /// @brief comparison: less than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_lt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) < rhs;
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    friend bool operator<=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(rhs < lhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs <= basic_json(rhs);
    }

    /// @brief comparison: less than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_le/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator<=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) <= rhs;
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    friend bool operator>(const_reference lhs, const_reference rhs) noexcept
    {
        // double inverse
        if (compares_unordered(lhs, rhs))
        {
            return false;
        }
        return !(lhs <= rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs > basic_json(rhs);
    }

    /// @brief comparison: greater than
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gt/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) > rhs;
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    friend bool operator>=(const_reference lhs, const_reference rhs) noexcept
    {
        if (compares_unordered(lhs, rhs, true))
        {
            return false;
        }
        return !(lhs < rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(const_reference lhs, ScalarType rhs) noexcept
    {
        return lhs >= basic_json(rhs);
    }

    /// @brief comparison: greater than or equal
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ge/
    template<typename ScalarType, typename std::enable_if<
                 std::is_scalar<ScalarType>::value, int>::type = 0>
    friend bool operator>=(ScalarType lhs, const_reference rhs) noexcept
    {
        return basic_json(lhs) >= rhs;
    }
#endif

#undef JSON_IMPLEMENT_OPERATOR

    /// @}

    ///////////////////
    // serialization //
    ///////////////////

    /// @name serialization
    /// @{
#ifndef JSON_NO_IO
    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    friend std::ostream& operator<<(std::ostream& o, const basic_json& j)
    {
        // read width member and use it as the indentation parameter if nonzero
        const bool pretty_print = o.width() > 0;
        const auto indentation = pretty_print ? o.width() : 0;

        // reset width to 0 for subsequent calls to this stream
        o.width(0);

        // do the actual serialization
        serializer s(detail::output_adapter<char>(o), o.fill());
        s.dump(j, pretty_print, false, static_cast<unsigned int>(indentation));
        return o;
    }

    /// @brief serialize to stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_ltlt/
    /// @deprecated This function is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator<<(std::ostream&, const basic_json&) instead; that is,
    ///             replace calls like `j >> o;` with `o << j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator<<(std::ostream&, const basic_json&))
    friend std::ostream& operator>>(const basic_json& j, std::ostream& o)
    {
        return o << j;
    }
#endif  // JSON_NO_IO
    /// @}

    /////////////////////
    // deserialization //
    /////////////////////

    /// @name deserialization
    /// @{

    /// @brief deserialize from a compatible input
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(InputType&& i,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false,
                            const bool ignore_trailing_commas = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::forward<InputType>(i)), std::move(cb), allow_exceptions, ignore_comments, ignore_trailing_commas).parse(true, result); // cppcheck-suppress[accessMoved,accessForwarded]
        return result;
    }

    /// @brief deserialize from a pair of character iterators
    /// @sa https://json.nlohmann.me/api/basic_json/parse/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json parse(IteratorType first,
                            IteratorType last,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false,
                            const bool ignore_trailing_commas = false)
    {
        basic_json result;
        parser(detail::input_adapter(std::move(first), std::move(last)), std::move(cb), allow_exceptions, ignore_comments, ignore_trailing_commas).parse(true, result); // cppcheck-suppress[accessMoved]
        return result;
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))
    static basic_json parse(detail::span_input_adapter&& i,
                            parser_callback_t cb = nullptr,
                            const bool allow_exceptions = true,
                            const bool ignore_comments = false,
                            const bool ignore_trailing_commas = false)
    {
        basic_json result;
        parser(i.get(), std::move(cb), allow_exceptions, ignore_comments, ignore_trailing_commas).parse(true, result); // cppcheck-suppress[accessMoved]
        return result;
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename InputType>
    static bool accept(InputType&& i,
                       const bool ignore_comments = false,
                       const bool ignore_trailing_commas = false)
    {
        return parser(detail::input_adapter(std::forward<InputType>(i)), nullptr, false, ignore_comments, ignore_trailing_commas).accept(true);
    }

    /// @brief check if the input is valid JSON
    /// @sa https://json.nlohmann.me/api/basic_json/accept/
    template<typename IteratorType>
    static bool accept(IteratorType first, IteratorType last,
                       const bool ignore_comments = false,
                       const bool ignore_trailing_commas = false)
    {
        return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments, ignore_trailing_commas).accept(true);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
    static bool accept(detail::span_input_adapter&& i,
                       const bool ignore_comments = false,
                       const bool ignore_trailing_commas = false)
    {
        return parser(i.get(), nullptr, false, ignore_comments, ignore_trailing_commas).accept(true);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template <typename InputType, typename SAX>
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(InputType&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false,
                          const bool ignore_trailing_commas = false)
    {
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wtautological-pointer-compare"
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnonnull-compare"
#endif
        if (sax == nullptr)
        {
            JSON_THROW(other_error::create(502, "SAX handler must not be null", nullptr));
        }
#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments, ignore_trailing_commas).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    template<class IteratorType, class SAX>
    JSON_HEDLEY_NON_NULL(3)
    static bool sax_parse(IteratorType first, IteratorType last, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false,
                          const bool ignore_trailing_commas = false)
    {
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wtautological-pointer-compare"
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnonnull-compare"
#endif
        if (sax == nullptr)
        {
            JSON_THROW(other_error::create(502, "SAX handler must not be null", nullptr));
        }
#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        return format == input_format_t::json
               ? parser(std::move(ia), nullptr, true, ignore_comments, ignore_trailing_commas).sax_parse(sax, strict)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }

    /// @brief generate SAX events
    /// @sa https://json.nlohmann.me/api/basic_json/sax_parse/
    /// @deprecated This function is deprecated since 3.8.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             sax_parse(ptr, ptr + len) instead.
    template <typename SAX>
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))
    JSON_HEDLEY_NON_NULL(2)
    static bool sax_parse(detail::span_input_adapter&& i, SAX* sax,
                          input_format_t format = input_format_t::json,
                          const bool strict = true,
                          const bool ignore_comments = false,
                          const bool ignore_trailing_commas = false)
    {
#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wtautological-pointer-compare"
#elif defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnonnull-compare"
#endif
        if (sax == nullptr)
        {
            JSON_THROW(other_error::create(502, "SAX handler must not be null", nullptr));
        }
#if defined(__clang__)
#pragma clang diagnostic pop
#elif defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
        auto ia = i.get();
        return format == input_format_t::json
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               ? parser(std::move(ia), nullptr, true, ignore_comments, ignore_trailing_commas).sax_parse(sax, strict)
               // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
               : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia), format).sax_parse(format, sax, strict);
    }
#ifndef JSON_NO_IO
    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    /// @deprecated This stream operator is deprecated since 3.0.0 and will be removed in
    ///             version 4.0.0 of the library. Please use
    ///             operator>>(std::istream&, basic_json&) instead; that is,
    ///             replace calls like `j << i;` with `i >> j;`.
    JSON_HEDLEY_DEPRECATED_FOR(3.0.0, operator>>(std::istream&, basic_json&))
    friend std::istream& operator<<(basic_json& j, std::istream& i)
    {
        return operator>>(i, j);
    }

    /// @brief deserialize from stream
    /// @sa https://json.nlohmann.me/api/basic_json/operator_gtgt/
    friend std::istream& operator>>(std::istream& i, basic_json& j)
    {
        parser(detail::input_adapter(i)).parse(false, j);
        return i;
    }
#endif  // JSON_NO_IO
    /// @}

    ///////////////////////////
    // convenience functions //
    ///////////////////////////

    /// @brief return the type as string
    /// @sa https://json.nlohmann.me/api/basic_json/type_name/
    JSON_HEDLEY_RETURNS_NON_NULL
    const char* type_name() const noexcept
    {
        switch (m_data.m_type)
        {
            case value_t::null:
                return "null";
            case value_t::object:
                return "object";
            case value_t::array:
                return "array";
            case value_t::string:
                return "string";
            case value_t::boolean:
                return "boolean";
            case value_t::binary:
                return "binary";
            case value_t::discarded:
                return "discarded";
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
                return "number";
            default:
                return "invalid";
        }
    }

  JSON_PRIVATE_UNLESS_TESTED:
    //////////////////////
    // member variables //
    //////////////////////

    struct data
    {
        /// the type of the current element
        value_t m_type = value_t::null;

        /// the value of the current element
        json_value m_value = {};

        data(const value_t v)
            : m_type(v), m_value(v)
        {
        }

        data(size_type cnt, const basic_json& val)
            : m_type(value_t::array)
        {
            m_value.array = create<array_t>(cnt, val);
        }

        data() noexcept = default;
        data(data&&) noexcept = default;
        data(const data&) noexcept = delete;
        data& operator=(data&&) noexcept = delete;
        data& operator=(const data&) noexcept = delete;

        ~data() noexcept
        {
            m_value.destroy(m_type);
        }
    };

    data m_data = {};

#if JSON_DIAGNOSTICS
    /// a pointer to a parent value (for debugging purposes)
    basic_json* m_parent = nullptr;
#endif

#if JSON_DIAGNOSTIC_POSITIONS
    /// the start position of the value
    std::size_t start_position = std::string::npos;
    /// the end position of the value
    std::size_t end_position = std::string::npos;
  public:
    constexpr std::size_t start_pos() const noexcept
    {
        return start_position;
    }

    constexpr std::size_t end_pos() const noexcept
    {
        return end_position;
    }
#endif

    //////////////////////////////////////////
    // binary serialization/deserialization //
    //////////////////////////////////////////

    /// @name binary serialization/deserialization support
    /// @{

  public:
    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static std::vector<std::uint8_t> to_cbor(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_cbor(j, result);
        return result;
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_cbor(j);
    }

    /// @brief create a CBOR serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_cbor/
    static void to_cbor(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_cbor(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static std::vector<std::uint8_t> to_msgpack(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_msgpack(j, result);
        return result;
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_msgpack(j);
    }

    /// @brief create a MessagePack serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_msgpack/
    static void to_msgpack(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_msgpack(j);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static std::vector<std::uint8_t> to_ubjson(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false)
    {
        std::vector<std::uint8_t> result;
        to_ubjson(j, result, use_size, use_type);
        return result;
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a UBJSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_ubjson/
    static void to_ubjson(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static std::vector<std::uint8_t> to_bjdata(const basic_json& j,
            const bool use_size = false,
            const bool use_type = false,
            const bjdata_version_t version = bjdata_version_t::draft2)
    {
        std::vector<std::uint8_t> result;
        to_bjdata(j, result, use_size, use_type, version);
        return result;
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<std::uint8_t> o,
                          const bool use_size = false, const bool use_type = false,
                          const bjdata_version_t version = bjdata_version_t::draft2)
    {
        binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type, true, true, version);
    }

    /// @brief create a BJData serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bjdata/
    static void to_bjdata(const basic_json& j, detail::output_adapter<char> o,
                          const bool use_size = false, const bool use_type = false,
                          const bjdata_version_t version = bjdata_version_t::draft2)
    {
        binary_writer<char>(o).write_ubjson(j, use_size, use_type, true, true, version);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static std::vector<std::uint8_t> to_bson(const basic_json& j)
    {
        std::vector<std::uint8_t> result;
        to_bson(j, result);
        return result;
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<std::uint8_t> o)
    {
        binary_writer<std::uint8_t>(o).write_bson(j);
    }

    /// @brief create a BSON serialization of a given JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/to_bson/
    static void to_bson(const basic_json& j, detail::output_adapter<char> o)
    {
        binary_writer<char>(o).write_bson(j);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in CBOR format
    /// @sa https://json.nlohmann.me/api/basic_json/from_cbor/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_cbor(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        return from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))
    static basic_json from_cbor(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true,
                                const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::cbor).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(InputType&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in MessagePack format
    /// @sa https://json.nlohmann.me/api/basic_json/from_msgpack/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_msgpack(IteratorType first, IteratorType last,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(const T* ptr, std::size_t len,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        return from_msgpack(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))
    static basic_json from_msgpack(detail::span_input_adapter&& i,
                                   const bool strict = true,
                                   const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::msgpack).sax_parse(input_format_t::msgpack, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in UBJSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_ubjson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_ubjson(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(const T* ptr, std::size_t len,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        return from_ubjson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))
    static basic_json from_ubjson(detail::span_input_adapter&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::ubjson).sax_parse(input_format_t::ubjson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(InputType&& i,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BJData format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bjdata/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bjdata(IteratorType first, IteratorType last,
                                  const bool strict = true,
                                  const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bjdata).sax_parse(input_format_t::bjdata, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename InputType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(InputType&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::forward<InputType>(i));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    /// @brief create a JSON value from an input in BSON format
    /// @sa https://json.nlohmann.me/api/basic_json/from_bson/
    template<typename IteratorType>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json from_bson(IteratorType first, IteratorType last,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = detail::input_adapter(std::move(first), std::move(last));
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }

    template<typename T>
    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(const T* ptr, std::size_t len,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        return from_bson(ptr, ptr + len, strict, allow_exceptions);
    }

    JSON_HEDLEY_WARN_UNUSED_RESULT
    JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))
    static basic_json from_bson(detail::span_input_adapter&& i,
                                const bool strict = true,
                                const bool allow_exceptions = true)
    {
        basic_json result;
        auto ia = i.get();
        detail::json_sax_dom_parser<basic_json, decltype(ia)> sdp(result, allow_exceptions);
        // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)
        const bool res = binary_reader<decltype(ia)>(std::move(ia), input_format_t::bson).sax_parse(input_format_t::bson, &sdp, strict); // cppcheck-suppress[accessMoved]
        return res ? result : basic_json(value_t::discarded);
    }
    /// @}

    //////////////////////////
    // JSON Pointer support //
    //////////////////////////

    /// @name JSON Pointer functions
    /// @{

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    reference operator[](const json_pointer& ptr)
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/operator%5B%5D/
    const_reference operator[](const json_pointer& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference operator[](const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_unchecked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    reference at(const json_pointer& ptr)
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr)
    {
        return ptr.get_checked(this);
    }

    /// @brief access specified element via JSON Pointer
    /// @sa https://json.nlohmann.me/api/basic_json/at/
    const_reference at(const json_pointer& ptr) const
    {
        return ptr.get_checked(this);
    }

    template<typename BasicJsonType, detail::enable_if_t<detail::is_basic_json<BasicJsonType>::value, int> = 0>
    JSON_HEDLEY_DEPRECATED_FOR(3.11.0, basic_json::json_pointer or nlohmann::json_pointer<basic_json::string_t>) // NOLINT(readability/alt_tokens)
    const_reference at(const ::nlohmann::json_pointer<BasicJsonType>& ptr) const
    {
        return ptr.get_checked(this);
    }

    /// @brief return flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/flatten/
    basic_json flatten() const
    {
        basic_json result(value_t::object);
        json_pointer::flatten("", *this, result);
        return result;
    }

    /// @brief unflatten a previously flattened JSON value
    /// @sa https://json.nlohmann.me/api/basic_json/unflatten/
    basic_json unflatten() const
    {
        return json_pointer::unflatten(*this);
    }

    /// @}

    //////////////////////////
    // JSON Patch functions //
    //////////////////////////

    /// @name JSON Patch functions
    /// @{

    /// @brief applies a JSON patch in-place without copying the object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    void patch_inplace(const basic_json& json_patch)
    {
        basic_json& result = *this;
        // the valid JSON Patch operations
        enum class patch_operations {add, remove, replace, move, copy, test, invalid};

        const auto get_op = [](const string_t& op)
        {
            if (op == "add")
            {
                return patch_operations::add;
            }
            if (op == "remove")
            {
                return patch_operations::remove;
            }
            if (op == "replace")
            {
                return patch_operations::replace;
            }
            if (op == "move")
            {
                return patch_operations::move;
            }
            if (op == "copy")
            {
                return patch_operations::copy;
            }
            if (op == "test")
            {
                return patch_operations::test;
            }

            return patch_operations::invalid;
        };

        // wrapper for "add" operation; add value at ptr
        const auto operation_add = [&result](json_pointer & ptr, const basic_json & val)
        {
            // adding to the root of the target document means replacing it
            if (ptr.empty())
            {
                result = val;
                return;
            }

            // make sure the top element of the pointer exists
            json_pointer const top_pointer = ptr.top();
            if (top_pointer != ptr)
            {
                result.at(top_pointer);
            }

            // get reference to the parent of the JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            // parent must exist when performing patch add per RFC6902 specs
            basic_json& parent = result.at(ptr);

            switch (parent.m_data.m_type)
            {
                case value_t::null:
                case value_t::object:
                {
                    // use operator[] to add value
                    parent[last_path] = val;
                    break;
                }

                case value_t::array:
                {
                    if (last_path == "-")
                    {
                        // special case: append to back
                        parent.push_back(val);
                    }
                    else
                    {
                        const auto idx = json_pointer::template array_index<basic_json_t>(last_path);
                        if (JSON_HEDLEY_UNLIKELY(idx > parent.size()))
                        {
                            // avoid undefined behavior
                            JSON_THROW(out_of_range::create(401, detail::concat("array index ", std::to_string(idx), " is out of range"), &parent));
                        }

                        // default case: insert add offset
                        parent.insert(parent.begin() + static_cast<difference_type>(idx), val);
                    }
                    break;
                }

                // if there exists a parent, it cannot be primitive
                case value_t::string: // LCOV_EXCL_LINE
                case value_t::boolean: // LCOV_EXCL_LINE
                case value_t::number_integer: // LCOV_EXCL_LINE
                case value_t::number_unsigned: // LCOV_EXCL_LINE
                case value_t::number_float: // LCOV_EXCL_LINE
                case value_t::binary: // LCOV_EXCL_LINE
                case value_t::discarded: // LCOV_EXCL_LINE
                default:            // LCOV_EXCL_LINE
                    JSON_ASSERT(false); // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE
            }
        };

        // wrapper for "remove" operation; remove value at ptr
        const auto operation_remove = [this, & result](json_pointer & ptr)
        {
            // get reference to the parent of the JSON pointer ptr
            const auto last_path = ptr.back();
            ptr.pop_back();
            basic_json& parent = result.at(ptr);

            // remove child
            if (parent.is_object())
            {
                // perform range check
                auto it = parent.find(last_path);
                if (JSON_HEDLEY_LIKELY(it != parent.end()))
                {
                    parent.erase(it);
                }
                else
                {
                    JSON_THROW(out_of_range::create(403, detail::concat("key '", last_path, "' not found"), this));
                }
            }
            else if (parent.is_array())
            {
                // note erase performs range check
                parent.erase(json_pointer::template array_index<basic_json_t>(last_path));
            }
        };

        // type check: top level value must be an array
        if (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))
        {
            JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &json_patch));
        }

        // iterate and apply the operations
        for (const auto& val : json_patch)
        {
            // wrapper to get a value for an operation
            const auto get_value = [&val](const string_t& op,
                                          const string_t& member,
                                          bool string_type) -> basic_json &
            {
                // find value
                auto it = val.m_data.m_value.object->find(member);

                // context-sensitive error message
                const auto error_msg = (op == "op") ? "operation" : detail::concat("operation '", op, '\''); // NOLINT(bugprone-unused-local-non-trivial-variable)

                // check if the desired value is present
                if (JSON_HEDLEY_UNLIKELY(it == val.m_data.m_value.object->end()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have member '", member, "'"), &val));
                }

                // check if the result is of type string
                if (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))
                {
                    // NOLINTNEXTLINE(performance-inefficient-string-concatenation)
                    JSON_THROW(parse_error::create(105, 0, detail::concat(error_msg, " must have string member '", member, "'"), &val));
                }

                // no error: return value
                return it->second;
            };

            // type check: every element of the array must be an object
            if (JSON_HEDLEY_UNLIKELY(!val.is_object()))
            {
                JSON_THROW(parse_error::create(104, 0, "JSON patch must be an array of objects", &val));
            }

            // collect mandatory members
            const auto op = get_value("op", "op", true).template get<string_t>();
            const auto path = get_value(op, "path", true).template get<string_t>();
            json_pointer ptr(path);

            switch (get_op(op))
            {
                case patch_operations::add:
                {
                    operation_add(ptr, get_value("add", "value", false));
                    break;
                }

                case patch_operations::remove:
                {
                    operation_remove(ptr);
                    break;
                }

                case patch_operations::replace:
                {
                    // the "path" location must exist - use at()
                    result.at(ptr) = get_value("replace", "value", false);
                    break;
                }

                case patch_operations::move:
                {
                    const auto from_path = get_value("move", "from", true).template get<string_t>();
                    json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The move operation is functionally identical to a
                    // "remove" operation on the "from" location, followed
                    // immediately by an "add" operation at the target
                    // location with the value that was just removed.
                    operation_remove(from_ptr);
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::copy:
                {
                    const auto from_path = get_value("copy", "from", true).template get<string_t>();
                    const json_pointer from_ptr(from_path);

                    // the "from" location must exist - use at()
                    basic_json const v = result.at(from_ptr);

                    // The copy is functionally identical to an "add"
                    // operation at the target location using the value
                    // specified in the "from" member.
                    operation_add(ptr, v);
                    break;
                }

                case patch_operations::test:
                {
                    bool success = false;
                    JSON_TRY
                    {
                        // check if "value" matches the one at "path"
                        // the "path" location must exist - use at()
                        success = (result.at(ptr) == get_value("test", "value", false));
                    }
                    JSON_INTERNAL_CATCH (out_of_range&)
                    {
                        // ignore out of range errors: success remains false
                    }

                    // throw an exception if the test fails
                    if (JSON_HEDLEY_UNLIKELY(!success))
                    {
                        JSON_THROW(other_error::create(501, detail::concat("unsuccessful: ", val.dump()), &val));
                    }

                    break;
                }

                case patch_operations::invalid:
                default:
                {
                    // op must be "add", "remove", "replace", "move", "copy", or
                    // "test"
                    JSON_THROW(parse_error::create(105, 0, detail::concat("operation value '", op, "' is invalid"), &val));
                }
            }
        }
    }

    /// @brief applies a JSON patch to a copy of the current object
    /// @sa https://json.nlohmann.me/api/basic_json/patch/
    basic_json patch(const basic_json& json_patch) const
    {
        basic_json result = *this;
        result.patch_inplace(json_patch);
        return result;
    }

    /// @brief creates a diff as a JSON patch
    /// @sa https://json.nlohmann.me/api/basic_json/diff/
    JSON_HEDLEY_WARN_UNUSED_RESULT
    static basic_json diff(const basic_json& source, const basic_json& target,
                           const string_t& path = "")
    {
        // the patch
        basic_json result(value_t::array);

        // if the values are the same, return an empty patch
        if (source == target)
        {
            return result;
        }

        if (source.type() != target.type())
        {
            // different types: replace value
            result.push_back(
            {
                {"op", "replace"}, {"path", path}, {"value", target}
            });
            return result;
        }

        switch (source.type())
        {
            case value_t::array:
            {
                // first pass: traverse common elements
                std::size_t i = 0;
                while (i < source.size() && i < target.size())
                {
                    // recursive call to compare array values at index i
                    auto temp_diff = diff(source[i], target[i], detail::concat<string_t>(path, '/', detail::to_string<string_t>(i)));
                    result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    ++i;
                }

                // We now reached the end of at least one array
                // in a second pass, traverse the remaining elements

                // remove my remaining elements
                const auto end_index = static_cast<difference_type>(result.size());
                while (i < source.size())
                {
                    // add operations in reverse order to avoid invalid
                    // indices
                    result.insert(result.begin() + end_index, object(
                    {
                        {"op", "remove"},
                        {"path", detail::concat<string_t>(path, '/', detail::to_string<string_t>(i))}
                    }));
                    ++i;
                }

                // add other remaining elements
                while (i < target.size())
                {
                    result.push_back(
                    {
                        {"op", "add"},
                        {"path", detail::concat<string_t>(path, "/-")},
                        {"value", target[i]}
                    });
                    ++i;
                }

                break;
            }

            case value_t::object:
            {
                // first pass: traverse this object's elements
                for (auto it = source.cbegin(); it != source.cend(); ++it)
                {
                    // escape the key name to be used in a JSON patch
                    const auto path_key = detail::concat<string_t>(path, '/', detail::escape(it.key()));

                    if (target.find(it.key()) != target.end())
                    {
                        // recursive call to compare object values at key it
                        auto temp_diff = diff(it.value(), target[it.key()], path_key);
                        result.insert(result.end(), temp_diff.begin(), temp_diff.end());
                    }
                    else
                    {
                        // found a key that is not in o -> remove it
                        result.push_back(object(
                        {
                            {"op", "remove"}, {"path", path_key}
                        }));
                    }
                }

                // second pass: traverse other object's elements
                for (auto it = target.cbegin(); it != target.cend(); ++it)
                {
                    if (source.find(it.key()) == source.end())
                    {
                        // found a key that is not in this -> add it
                        const auto path_key = detail::concat<string_t>(path, '/', detail::escape(it.key()));
                        result.push_back(
                        {
                            {"op", "add"}, {"path", path_key},
                            {"value", it.value()}
                        });
                    }
                }

                break;
            }

            case value_t::null:
            case value_t::string:
            case value_t::boolean:
            case value_t::number_integer:
            case value_t::number_unsigned:
            case value_t::number_float:
            case value_t::binary:
            case value_t::discarded:
            default:
            {
                // both primitive types: replace value
                result.push_back(
                {
                    {"op", "replace"}, {"path", path}, {"value", target}
                });
                break;
            }
        }

        return result;
    }
    /// @}

    ////////////////////////////////
    // JSON Merge Patch functions //
    ////////////////////////////////

    /// @name JSON Merge Patch functions
    /// @{

    /// @brief applies a JSON Merge Patch
    /// @sa https://json.nlohmann.me/api/basic_json/merge_patch/
    void merge_patch(const basic_json& apply_patch)
    {
        if (apply_patch.is_object())
        {
            if (!is_object())
            {
                *this = object();
            }
            for (auto it = apply_patch.begin(); it != apply_patch.end(); ++it)
            {
                if (it.value().is_null())
                {
                    erase(it.key());
                }
                else
                {
                    operator[](it.key()).merge_patch(it.value());
                }
            }
        }
        else
        {
            *this = apply_patch;
        }
    }

    /// @}
};

/// @brief user-defined to_string function for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/to_string/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
std::string to_string(const NLOHMANN_BASIC_JSON_TPL& j)
{
    return j.dump();
}

inline namespace literals
{
inline namespace json_literals
{

/// @brief user-defined string literal for JSON values
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json operator""_json(const char* s, std::size_t n)
#else
    // GCC 4.8 requires a space between "" and suffix
    inline nlohmann::json operator"" _json(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::parse(s, s + n);
}

#if defined(__cpp_char8_t)
JSON_HEDLEY_NON_NULL(1)
inline nlohmann::json operator""_json(const char8_t* s, std::size_t n)
{
    return nlohmann::json::parse(reinterpret_cast<const char*>(s),
                                 reinterpret_cast<const char*>(s) + n);
}
#endif

/// @brief user-defined string literal for JSON pointer
/// @sa https://json.nlohmann.me/api/basic_json/operator_literal_json_pointer/
JSON_HEDLEY_NON_NULL(1)
#if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
    inline nlohmann::json::json_pointer operator""_json_pointer(const char* s, std::size_t n)
#else
    // GCC 4.8 requires a space between "" and suffix
    inline nlohmann::json::json_pointer operator"" _json_pointer(const char* s, std::size_t n)
#endif
{
    return nlohmann::json::json_pointer(std::string(s, n));
}

#if defined(__cpp_char8_t)
inline nlohmann::json::json_pointer operator""_json_pointer(const char8_t* s, std::size_t n)
{
    return nlohmann::json::json_pointer(std::string(reinterpret_cast<const char*>(s), n));
}
#endif

}  // namespace json_literals
}  // namespace literals
NLOHMANN_JSON_NAMESPACE_END

///////////////////////
// nonmember support //
///////////////////////

namespace std // NOLINT(cert-dcl58-cpp)
{

/// @brief hash value for JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_hash/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
struct hash<nlohmann::NLOHMANN_BASIC_JSON_TPL> // NOLINT(cert-dcl58-cpp)
{
    std::size_t operator()(const nlohmann::NLOHMANN_BASIC_JSON_TPL& j) const
    {
        return nlohmann::detail::hash(j);
    }
};

// specialization for std::less<value_t>
template<>
struct less< ::nlohmann::detail::value_t> // do not remove the space after '<', see https://github.com/nlohmann/json/pull/679
{
    /*!
    @brief compare two value_t enum values
    @since version 3.0.0
    */
    bool operator()(::nlohmann::detail::value_t lhs,
                    ::nlohmann::detail::value_t rhs) const noexcept
    {
#if JSON_HAS_THREE_WAY_COMPARISON
        return std::is_lt(lhs <=> rhs); // *NOPAD*
#else
        return ::nlohmann::detail::operator<(lhs, rhs);
#endif
    }
};

// C++20 prohibit function specialization in the std namespace.
#ifndef JSON_HAS_CPP_20

/// @brief exchanges the values of two JSON objects
/// @sa https://json.nlohmann.me/api/basic_json/std_swap/
NLOHMANN_BASIC_JSON_TPL_DECLARATION
inline void swap(nlohmann::NLOHMANN_BASIC_JSON_TPL& j1, nlohmann::NLOHMANN_BASIC_JSON_TPL& j2) noexcept(  // NOLINT(readability-inconsistent-declaration-parameter-name, cert-dcl58-cpp)
    is_nothrow_move_constructible<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value&&                          // NOLINT(misc-redundant-expression,cppcoreguidelines-noexcept-swap,performance-noexcept-swap)
    is_nothrow_move_assignable<nlohmann::NLOHMANN_BASIC_JSON_TPL>::value)
{
    j1.swap(j2);
}

#endif

}  // namespace std

#if JSON_USE_GLOBAL_UDLS
    #if !defined(JSON_HEDLEY_GCC_VERSION) || JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0)
        using nlohmann::literals::json_literals::operator""_json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator""_json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #else
        // GCC 4.8 requires a space between "" and suffix
        using nlohmann::literals::json_literals::operator"" _json; // NOLINT(misc-unused-using-decls,google-global-names-in-headers)
        using nlohmann::literals::json_literals::operator"" _json_pointer; //NOLINT(misc-unused-using-decls,google-global-names-in-headers)
    #endif
#endif

// #include <nlohmann/detail/macro_unscope.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



// restore clang diagnostic settings
#if defined(__clang__)
    #pragma clang diagnostic pop
#endif

// clean up
#undef JSON_ASSERT
#undef JSON_INTERNAL_CATCH
#undef JSON_THROW
#undef JSON_PRIVATE_UNLESS_TESTED
#undef NLOHMANN_BASIC_JSON_TPL_DECLARATION
#undef NLOHMANN_BASIC_JSON_TPL
#undef JSON_EXPLICIT
#undef NLOHMANN_CAN_CALL_STD_FUNC_IMPL
#undef JSON_INLINE_VARIABLE
#undef JSON_NO_UNIQUE_ADDRESS
#undef JSON_DISABLE_ENUM_SERIALIZATION
#undef JSON_USE_GLOBAL_UDLS

#ifndef JSON_TEST_KEEP_MACROS
    #undef JSON_CATCH
    #undef JSON_TRY
    #undef JSON_HAS_CPP_11
    #undef JSON_HAS_CPP_14
    #undef JSON_HAS_CPP_17
    #undef JSON_HAS_CPP_20
    #undef JSON_HAS_CPP_23
    #undef JSON_HAS_CPP_26
    #undef JSON_HAS_FILESYSTEM
    #undef JSON_HAS_EXPERIMENTAL_FILESYSTEM
    #undef JSON_HAS_THREE_WAY_COMPARISON
    #undef JSON_HAS_RANGES
    #undef JSON_HAS_STATIC_RTTI
    #undef JSON_USE_LEGACY_DISCARDED_VALUE_COMPARISON
#endif

// #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>
//     __ _____ _____ _____
//  __|  |   __|     |   | |  JSON for Modern C++
// |  |  |__   |  |  | | | |  version 3.12.0
// |_____|_____|_____|_|___|  https://github.com/nlohmann/json
//
// SPDX-FileCopyrightText: 2013-2026 Niels Lohmann <https://nlohmann.me>
// SPDX-License-Identifier: MIT



#undef JSON_HEDLEY_ALWAYS_INLINE
#undef JSON_HEDLEY_ARM_VERSION
#undef JSON_HEDLEY_ARM_VERSION_CHECK
#undef JSON_HEDLEY_ARRAY_PARAM
#undef JSON_HEDLEY_ASSUME
#undef JSON_HEDLEY_BEGIN_C_DECLS
#undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_BUILTIN
#undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_CLANG_HAS_EXTENSION
#undef JSON_HEDLEY_CLANG_HAS_FEATURE
#undef JSON_HEDLEY_CLANG_HAS_WARNING
#undef JSON_HEDLEY_COMPCERT_VERSION
#undef JSON_HEDLEY_COMPCERT_VERSION_CHECK
#undef JSON_HEDLEY_CONCAT
#undef JSON_HEDLEY_CONCAT3
#undef JSON_HEDLEY_CONCAT3_EX
#undef JSON_HEDLEY_CONCAT_EX
#undef JSON_HEDLEY_CONST
#undef JSON_HEDLEY_CONSTEXPR
#undef JSON_HEDLEY_CONST_CAST
#undef JSON_HEDLEY_CPP_CAST
#undef JSON_HEDLEY_CRAY_VERSION
#undef JSON_HEDLEY_CRAY_VERSION_CHECK
#undef JSON_HEDLEY_C_DECL
#undef JSON_HEDLEY_DEPRECATED
#undef JSON_HEDLEY_DEPRECATED_FOR
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS
#undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION
#undef JSON_HEDLEY_DIAGNOSTIC_POP
#undef JSON_HEDLEY_DIAGNOSTIC_PUSH
#undef JSON_HEDLEY_DMC_VERSION
#undef JSON_HEDLEY_DMC_VERSION_CHECK
#undef JSON_HEDLEY_EMPTY_BASES
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION
#undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK
#undef JSON_HEDLEY_END_C_DECLS
#undef JSON_HEDLEY_FLAGS
#undef JSON_HEDLEY_FLAGS_CAST
#undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_BUILTIN
#undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GCC_HAS_EXTENSION
#undef JSON_HEDLEY_GCC_HAS_FEATURE
#undef JSON_HEDLEY_GCC_HAS_WARNING
#undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK
#undef JSON_HEDLEY_GCC_VERSION
#undef JSON_HEDLEY_GCC_VERSION_CHECK
#undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_BUILTIN
#undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_GNUC_HAS_EXTENSION
#undef JSON_HEDLEY_GNUC_HAS_FEATURE
#undef JSON_HEDLEY_GNUC_HAS_WARNING
#undef JSON_HEDLEY_GNUC_VERSION
#undef JSON_HEDLEY_GNUC_VERSION_CHECK
#undef JSON_HEDLEY_HAS_ATTRIBUTE
#undef JSON_HEDLEY_HAS_BUILTIN
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE
#undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS
#undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE
#undef JSON_HEDLEY_HAS_EXTENSION
#undef JSON_HEDLEY_HAS_FEATURE
#undef JSON_HEDLEY_HAS_WARNING
#undef JSON_HEDLEY_IAR_VERSION
#undef JSON_HEDLEY_IAR_VERSION_CHECK
#undef JSON_HEDLEY_IBM_VERSION
#undef JSON_HEDLEY_IBM_VERSION_CHECK
#undef JSON_HEDLEY_IMPORT
#undef JSON_HEDLEY_INLINE
#undef JSON_HEDLEY_INTEL_CL_VERSION
#undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK
#undef JSON_HEDLEY_INTEL_VERSION
#undef JSON_HEDLEY_INTEL_VERSION_CHECK
#undef JSON_HEDLEY_IS_CONSTANT
#undef JSON_HEDLEY_IS_CONSTEXPR_
#undef JSON_HEDLEY_LIKELY
#undef JSON_HEDLEY_MALLOC
#undef JSON_HEDLEY_MCST_LCC_VERSION
#undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK
#undef JSON_HEDLEY_MESSAGE
#undef JSON_HEDLEY_MSVC_VERSION
#undef JSON_HEDLEY_MSVC_VERSION_CHECK
#undef JSON_HEDLEY_NEVER_INLINE
#undef JSON_HEDLEY_NON_NULL
#undef JSON_HEDLEY_NO_ESCAPE
#undef JSON_HEDLEY_NO_RETURN
#undef JSON_HEDLEY_NO_THROW
#undef JSON_HEDLEY_NULL
#undef JSON_HEDLEY_PELLES_VERSION
#undef JSON_HEDLEY_PELLES_VERSION_CHECK
#undef JSON_HEDLEY_PGI_VERSION
#undef JSON_HEDLEY_PGI_VERSION_CHECK
#undef JSON_HEDLEY_PREDICT
#undef JSON_HEDLEY_PRINTF_FORMAT
#undef JSON_HEDLEY_PRIVATE
#undef JSON_HEDLEY_PUBLIC
#undef JSON_HEDLEY_PURE
#undef JSON_HEDLEY_REINTERPRET_CAST
#undef JSON_HEDLEY_REQUIRE
#undef JSON_HEDLEY_REQUIRE_CONSTEXPR
#undef JSON_HEDLEY_REQUIRE_MSG
#undef JSON_HEDLEY_RESTRICT
#undef JSON_HEDLEY_RETURNS_NON_NULL
#undef JSON_HEDLEY_SENTINEL
#undef JSON_HEDLEY_STATIC_ASSERT
#undef JSON_HEDLEY_STATIC_CAST
#undef JSON_HEDLEY_STRINGIFY
#undef JSON_HEDLEY_STRINGIFY_EX
#undef JSON_HEDLEY_SUNPRO_VERSION
#undef JSON_HEDLEY_SUNPRO_VERSION_CHECK
#undef JSON_HEDLEY_TINYC_VERSION
#undef JSON_HEDLEY_TINYC_VERSION_CHECK
#undef JSON_HEDLEY_TI_ARMCL_VERSION
#undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL2000_VERSION
#undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL430_VERSION
#undef JSON_HEDLEY_TI_CL430_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL6X_VERSION
#undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CL7X_VERSION
#undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK
#undef JSON_HEDLEY_TI_CLPRU_VERSION
#undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK
#undef JSON_HEDLEY_TI_VERSION
#undef JSON_HEDLEY_TI_VERSION_CHECK
#undef JSON_HEDLEY_UNAVAILABLE
#undef JSON_HEDLEY_UNLIKELY
#undef JSON_HEDLEY_UNPREDICTABLE
#undef JSON_HEDLEY_UNREACHABLE
#undef JSON_HEDLEY_UNREACHABLE_RETURN
#undef JSON_HEDLEY_VERSION
#undef JSON_HEDLEY_VERSION_DECODE_MAJOR
#undef JSON_HEDLEY_VERSION_DECODE_MINOR
#undef JSON_HEDLEY_VERSION_DECODE_REVISION
#undef JSON_HEDLEY_VERSION_ENCODE
#undef JSON_HEDLEY_WARNING
#undef JSON_HEDLEY_WARN_UNUSED_RESULT
#undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG
#undef JSON_HEDLEY_FALL_THROUGH



#endif  // INCLUDE_NLOHMANN_JSON_HPP_


--- .\include\PhasorFFI.h ---
#ifndef PHASOR_FFI_HPP
#define PHASOR_FFI_HPP

#ifdef __cplusplus
#include <cstdint>
#include <cstddef>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

/*
 * Phasor Foreign Function Interface
 *
 * This header provides the necessary definitions for creating third-party
 * plugins for the Phasor scripting engine. It is designed to be a stable,
 * C-compatible interface.
 *
 * USAGE:
 * 1. Include this header in your C or C++ source file.
 * 2. Implement the entry point function:
 *    void phasor_plugin_entry(const PhasorAPI* api, PhasorVM* vm);
 * 3. Inside this function, use the provided `api` object to register
 *    your own native functions.
 * 4. Compile your code as a shared library (.dll, .so, .dylib).
 */

#if defined(_WIN32) && defined(PHASOR_FFI_BUILD_DLL)
#define PHASOR_FFI_EXPORT __declspec(dllexport)
#elif defined(__GNUC__) || defined(__clang__)
#define PHASOR_FFI_EXPORT __attribute__((visibility("default")))
#else
#define PHASOR_FFI_EXPORT
#endif

#ifdef __cplusplus
extern "C"
{
#endif

	// Opaque pointer to the Phasor Virtual Machine.
	typedef struct PhasorVM PhasorVM;

	// An enumeration of possible types a PhasorValue can hold.
	typedef enum
	{
		PHASOR_TYPE_NULL,
		PHASOR_TYPE_BOOL,
		PHASOR_TYPE_INT,
		PHASOR_TYPE_FLOAT,
		PHASOR_TYPE_STRING,
		PHASOR_TYPE_ARRAY,
		// Note: Structs are not directly supported in this version of the FFI
		// for simplicity, but can be added in the future.
	} PhasorValueType;

	// Forward declare for self-reference in the union
	typedef struct PhasorValue PhasorValue;

	// Represents a value in the Phasor VM.
	// It's a tagged union holding one of several possible types.
	struct PhasorValue
	{
		PhasorValueType type;
		union {
			bool        b;
			int64_t     i;
			double      f;
			const char *s; // Note: For strings returned from the VM, this is valid.
			// For strings passed to the VM, the VM makes a copy.
			struct
			{
				const PhasorValue *elements;
				size_t             count;
			} a;
		} as;
	};

	// -----------------------------------------------------------------------------
	// Value Manipulation Functions (static inline for self-containment)
	// -----------------------------------------------------------------------------

	// Helper functions to create PhasorValue instances.
	static inline PhasorValue phasor_make_null()
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_NULL;
		return val;
	}

	static inline PhasorValue phasor_make_bool(bool b)
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_BOOL;
		val.as.b = b;
		return val;
	}

	static inline PhasorValue phasor_make_int(int64_t i)
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_INT;
		val.as.i = i;
		return val;
	}

	static inline PhasorValue phasor_make_float(double f)
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_FLOAT;
		val.as.f = f;
		return val;
	}

	static inline PhasorValue phasor_make_string(const char *s)
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_STRING;
		val.as.s = s;
		return val;
	}

	static inline PhasorValue phasor_make_array(const PhasorValue *elements, size_t count)
	{
		PhasorValue val;
		val.type = PHASOR_TYPE_ARRAY;
		val.as.a.elements = elements;
		val.as.a.count = count;
		return val;
	}

	// Helper functions to check the type of a PhasorValue.
	static inline bool phasor_is_null(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_NULL;
	}
	static inline bool phasor_is_bool(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_BOOL;
	}
	static inline bool phasor_is_int(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_INT;
	}
	static inline bool phasor_is_float(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_FLOAT;
	}
	static inline bool phasor_is_string(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_STRING;
	}
	static inline bool phasor_is_array(PhasorValue val)
	{
		return val.type == PHASOR_TYPE_ARRAY;
	}
	static inline bool phasor_is_number(PhasorValue val)
	{
		return phasor_is_int(val) || phasor_is_float(val);
	}

	// Helper functions to get the underlying value from a PhasorValue.
	// Note: These do not perform type checking. Use the `phasor_is_*` functions first.
	static inline bool phasor_to_bool(PhasorValue val)
	{
		return val.as.b;
	}
	static inline int64_t phasor_to_int(PhasorValue val)
	{
		return val.as.i;
	}
	static inline double phasor_to_float(PhasorValue val)
	{
		if (phasor_is_int(val))
			return (double)val.as.i;
		return val.as.f;
	}
	static inline const char *phasor_to_string(PhasorValue val)
	{
		return val.as.s;
	}

	// -----------------------------------------------------------------------------
	// FFI API Definitions
	// -----------------------------------------------------------------------------

	// Signature for a native C function that can be registered with the Phasor VM.
	typedef PhasorValue (*PhasorNativeFunction)(PhasorVM *vm, int argc, const PhasorValue *argv);

	// Function pointer type for the function that registers a native function with the VM.
	typedef void (*PhasorRegisterFunction)(PhasorVM *vm, const char *name, PhasorNativeFunction func);

	// The collection of API functions that the Phasor host provides to the plugin.
	typedef struct
	{
		// Registers a native C function with the given name.
		PhasorRegisterFunction register_function;
	} PhasorAPI;

	// -----------------------------------------------------------------------------
	// Plugin Entry Point
	// -----------------------------------------------------------------------------

	/**
	 * @brief The one and only entry point for a Phasor plugin.
	 *
	 * A Phasor-compatible shared library MUST export a C function with this exact
	 * signature. The Phasor host will call this function when the plugin is loaded,
	 * providing the plugin with a pointer to the host's API functions and the
	 * current VM instance.
	 *
	 * @param api A pointer to a struct containing function pointers that the plugin
	 *            can use to interact with the host (e.g., register functions).
	 * @param vm  An opaque pointer to the VM instance. This should be passed back
	 *            to any API functions that require it.
	 */
	PHASOR_FFI_EXPORT void phasor_plugin_entry(const PhasorAPI *api, PhasorVM *vm);

#ifdef __cplusplus
} // extern "C"
#endif

#endif // PHASOR_FFI_HPP

--- .\include\PhasorRT.h ---
#ifndef PHASOR_RT_H
#define PHASOR_RT_H

#include <stddef.h> // For size_t

#ifdef _WIN32
#ifdef PHASOR_EXPORTS
#define PHASOR_API __declspec(dllexport)
#else
#define PHASOR_API __declspec(dllimport)
#endif
#elif defined(__GNUC__) || defined(__clang__)
#ifdef PHASOR_EXPORTS
#define PHASOR_API __attribute__((visibility("default")))
#else
#define PHASOR_API
#endif
#else
#define PHASOR_API
#endif

#ifdef __cplusplus
extern "C"
{
#endif

	/**
	 * @brief Executes pre-compiled Phasor bytecode.
	 *
	 * @param embeddedBytecode An array of unsigned chars containing the Phasor bytecode.
	 * @param embeddedBytecodeSize The size of the bytecode array.
	 * @param moduleName The name of the module, used for error reporting.
	 * @param nativeFunctionsVector A pointer to a vector of pairs, where each pair contains a function name and a
	 * function pointer.
	 * @param argc The number of command-line arguments.
	 * @param argv An array of strings representing the command-line arguments.
	 */
	PHASOR_API void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
	                     const void *nativeFunctionsVector, const int argc, const char **argv);

	/**
	 * @brief Executes a Phasor script using Just-In-Time (JIT) compilation.
	 *
	 * @param script A string containing the Phasor script to execute.
	 * @param moduleName The name of the module, used for error reporting.
	 * @param nativeFunctionsVector A pointer to a vector of pairs, where each pair contains a function name and a
	 * function pointer.
	 */
	PHASOR_API void jitExec(const char *script, const char *moduleName, const void *nativeFunctionsVector);

	/**
	 * @brief Executes a Phasor script within an existing VM instance.
	 *
	 * @param vm A pointer to the Phasor VM instance.
	 * @param script A string containing the Phasor script to execute.
	 */
	PHASOR_API void executeScript(void *vm, const char *script);

#ifdef __cplusplus
}
#endif

#endif // PHASOR_RT_H


--- .\include\Value.hpp ---
#pragma once
#include <iostream>
#include <string>
#include <variant>
#include <unordered_map>
#include <memory>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @brief Runtime value types for the VM
 */
enum class ValueType
{
	Null,
	Bool,
	Int,
	Float,
	String,
	Struct,
	Array
};

/**
 * @brief A value in the Phasor VM
 *
 * Uses std::variant for type-safe union
 */
class Value
{
  public:
	struct StructInstance
	{
		std::string                            structName;
		std::unordered_map<std::string, Value> fields;
	};
	using ArrayInstance = std::vector<Value>;

  private:
	using DataType = std::variant<std::monostate, bool, int64_t, double, std::string, std::shared_ptr<StructInstance>,
	                              std::shared_ptr<ArrayInstance>>;

	DataType data;

  public:
	/// @brief Default constructor
	Value() : data(std::monostate{})
	{
	}
	/// @brief Boolean constructor
	Value(bool b) : data(b)
	{
	}
	/// @brief Integer constructor
	Value(int64_t i) : data(i)
	{
	}
	/// @brief Integer constructor
	Value(int i) : data(static_cast<int64_t>(i))
	{
	}
	/// @brief Double constructor
	Value(double d) : data(d)
	{
	}
	/// @brief String constructor
	Value(const std::string &s) : data(s)
	{
	}
	/// @brief String constructor
	Value(const char *s) : data(std::string(s))
	{
	}
	/// @brief Struct constructor
	Value(std::shared_ptr<StructInstance> s) : data(std::move(s))
	{
	}
	/// @brief Array constructor
	Value(std::shared_ptr<ArrayInstance> a) : data(std::move(a))
	{
	}

	/// @brief Get the type of the value
	ValueType getType() const
	{
		if (std::holds_alternative<std::monostate>(data))
			return ValueType::Null;
		if (std::holds_alternative<bool>(data))
			return ValueType::Bool;
		if (std::holds_alternative<int64_t>(data))
			return ValueType::Int;
		if (std::holds_alternative<double>(data))
			return ValueType::Float;
		if (std::holds_alternative<std::string>(data))
			return ValueType::String;
		if (std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			return ValueType::Struct;
		if (std::holds_alternative<std::shared_ptr<ArrayInstance>>(data))
			return ValueType::Array;
		return ValueType::Null; // Should not be reached if default constructed
	}

	/// @brief Check if the value is null
	bool isNull() const
	{
		return getType() == ValueType::Null;
	}
	/// @brief Check if the value is a boolean
	bool isBool() const
	{
		return getType() == ValueType::Bool;
	}
	/// @brief Check if the value is an integer
	bool isInt() const
	{
		return getType() == ValueType::Int;
	}
	/// @brief Check if the value is a double
	bool isFloat() const
	{
		return getType() == ValueType::Float;
	}
	/// @brief Check if the value is a string
	bool isString() const
	{
		return getType() == ValueType::String;
	}
	/// @brief Check if the value is a number
	bool isNumber() const
	{
		return isInt() || isFloat();
	}
	/// @brief Check if the value is an array
	bool isArray() const
	{
		return std::holds_alternative<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Get the value as a boolean
	bool asBool() const
	{
		return std::get<bool>(data);
	}
	/// @brief Get the value as an integer
	int64_t asInt() const
	{
		if (isInt())
			return std::get<int64_t>(data);
		if (isFloat())
			return static_cast<int64_t>(std::get<double>(data));
		return 0;
	}
	/// @brief Get the value as a double
	double asFloat() const
	{
		if (isFloat())
			return std::get<double>(data);
		if (isInt())
			return static_cast<double>(std::get<int64_t>(data));
		return 0.0;
	}
	/// @brief Get the value as a string
	std::string asString() const
	{
		if (isString())
			return std::get<std::string>(data);
		return toString();
	}
	/// @brief Get the value as an array
	std::shared_ptr<ArrayInstance> asArray()
	{
		return std::get<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Get the value as an array (const)
	const std::shared_ptr<const ArrayInstance> asArray() const
	{
		return std::get<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Add two values
	Value operator+(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() + other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() + other.asFloat());
		if (isString() && other.isString())
			return Value(asString() + other.asString());
		throw std::runtime_error("Cannot add these value types");
	}

	/// @brief Subtract two values
	Value operator-(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() - other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() - other.asFloat());
		throw std::runtime_error("Cannot subtract these value types");
	}

	/// @brief Multiply two values
	Value operator*(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() * other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() * other.asFloat());
		throw std::runtime_error("Cannot multiply these value types");
	}

	/// @brief Divide two values
	Value operator/(const Value &other) const
	{
		if (isInt() && other.isInt())
		{
			if (other.asInt() == 0)
				throw std::runtime_error("Division by zero");
			return Value(asInt() / other.asInt());
		}
		if (isNumber() && other.isNumber())
		{
			if (other.asFloat() == 0.0)
				throw std::runtime_error("Division by zero");
			return Value(asFloat() / other.asFloat());
		}
		throw std::runtime_error("Cannot divide these value types");
	}

	/// @brief Modulo two values
	Value operator%(const Value &other) const
	{
		if (isInt() && other.isInt())
		{
			if (other.asInt() == 0)
				throw std::runtime_error("Modulo by zero");
			return Value(asInt() % other.asInt());
		}
		throw std::runtime_error("Modulo requires integer operands");
	}

	/// @brief Unary negation
	Value operator-() const
	{
		if (isInt())
			return Value(-asInt());
		if (isFloat())
			return Value(-asFloat());
		throw std::runtime_error("Cannot negate this value type");
	}

	/// @brief Logical negation
	Value operator!() const
	{
		return Value(!isTruthy());
	}

	/// @brief Logical AND
	Value logicalAnd(const Value &other) const
	{
		return Value(isTruthy() && other.isTruthy());
	}

	/// @brief Logical OR
	Value logicalOr(const Value &other) const
	{
		return Value(isTruthy() || other.isTruthy());
	}

	/// @brief Helper to determine truthiness
	bool isTruthy() const
	{
		if (isNull())
			return false;
		if (isBool())
			return asBool();
		if (isInt())
			return asInt() != 0;
		if (isFloat())
			return asFloat() != 0.0;
		if (isString())
		{
			if (asString() == "true" || asString() == "1")
				return true;
			else if (asString() == "false" || asString() == "0")
				return false;
			return !asString().empty();
		}
		return false;
	}

	/// @brief Comparison operations
	bool operator==(const Value &other) const
	{
		if (getType() != other.getType())
			return false;
		if (isNull())
			return true;
		if (isBool())
			return asBool() == other.asBool();
		if (isInt())
			return asInt() == other.asInt();
		if (isFloat())
			return asFloat() == other.asFloat();
		if (isString())
			return asString() == other.asString();
		if (isArray())
		{
			if (!other.isArray())
				return false;
			const auto &self_arr = *asArray();
			const auto &other_arr = *other.asArray();
			return self_arr == other_arr;
		}
		return false;
	}

	/// @brief Inequality comparison
	bool operator!=(const Value &other) const
	{
		return !(*this == other);
	}

	/// @brief Less than comparison
	bool operator<(const Value &other) const
	{
		if (isInt() && other.isInt())
			return asInt() < other.asInt();
		if (isNumber() && other.isNumber())
			return asFloat() < other.asFloat();
		if (isString() && other.isString())
			return asString() < other.asString();
		throw std::runtime_error("Cannot compare these value types ");
	}

	/// @brief Greater than comparison
	bool operator>(const Value &other) const
	{
		if (isInt() && other.isInt())
			return asInt() > other.asInt();
		if (isNumber() && other.isNumber())
			return asFloat() > other.asFloat();
		if (isString() && other.isString())
			return asString() > other.asString();
		throw std::runtime_error("Cannot compare these value types ");
	}

	/// @brief Less than or equal to comparison
	bool operator<=(const Value &other) const
	{
		return !(*this > other);
	}
	/// @brief Greater than or equal to comparison
	bool operator>=(const Value &other) const
	{
		return !(*this < other);
	}

	/// @brief Convert to string for printing
	std::string toString() const
	{
		if (isNull())
			return "null";
		if (isBool())
			return asBool() ? "true" : "false";
		if (isInt())
			return std::to_string(asInt());
		if (isFloat())
			return std::to_string(asFloat());
		if (isString())
			return asString();
		if (isArray())
		{
			std::string result = "[";
			const auto &arr = *asArray();
			for (size_t i = 0; i < arr.size(); ++i)
			{
				result += arr[i].toString();
				if (i < arr.size() - 1)
				{
					result += ", ";
				}
			}
			result += "]";
			return result;
		}
		return "unknown";
	}

	/// @brief Convert to C Style String
	const char *c_str() const
	{
		if (!isString())
			throw std::runtime_error("c_str() can only be called on string values");
		return std::get<std::string>(data).c_str();
	}

	/// @brief Print to output stream
	friend std::ostream &operator<<(std::ostream &os, const Value &v)
	{
		os << v.toString();
		return os;
	}

	bool isStruct() const
	{
		return std::holds_alternative<std::shared_ptr<StructInstance>>(data);
	}

	std::shared_ptr<StructInstance> asStruct()
	{
		return std::get<std::shared_ptr<StructInstance>>(data);
	}

	const std::shared_ptr<const StructInstance> asStruct() const
	{
		return std::get<std::shared_ptr<StructInstance>>(data);
	}

	static Value createStruct(const std::string &name)
	{
		return Value(std::make_shared<StructInstance>(StructInstance{name}));
	}

	static Value createArray(std::vector<Value> elements = {})
	{
		return Value(std::make_shared<ArrayInstance>(std::move(elements)));
	}

	Value getField(const std::string &name) const
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			throw std::runtime_error("getField() called on non-struct value");
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		auto it = s->fields.find(name);
		if (it == s->fields.end())
			return Value();
		return it->second;
	}

	void setField(const std::string &name, Value value)
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			throw std::runtime_error("setField() called on non-struct value");
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		s->fields[name] = std::move(value);
	}

	bool hasField(const std::string &name) const
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			return false;
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		return s->fields.find(name) != s->fields.end();
	}
};
} // namespace Phasor


--- .\license ---
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


--- .\PKGBUILD ---
# Maintainer: Daniel McGuire <danielmcguire2023@gmail.com>
pkgname=phasor-dev
PACKAGER="Daniel McGuire <danielmcguire2023@gmail.com>"
pkgver=3.0.0.dev
pkgrel=1
pkgdesc="Phasor Programming Language Toolchain"
arch=('x86_64')
url="https://github.com/DanielLMcGuire/Phasor"
license=('0BSD')
makedepends=('git' 'gcc' 'cmake' 'ninja')
optdepends=('gcc: For building Phasor Native wrappers.')
conflicts=('phasor' 'phasor-git')
options=(strip !debug)
install=scripts/phasor.install
source=()
sha256sums=()

pkgver() {
    cd "$startdir"
    tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "3.0.0")
    commits_since_tag=$(git rev-list "${tag}"..HEAD --count 2>/dev/null || echo 0)
    if [ "$commits_since_tag" -eq 0 ]; then
        echo "$tag.dev"
    else
        echo "${tag}.r${commits_since_tag}.dev"
    fi
}

build() {
    cd "$startdir"
    "$startdir/pmake-bootstrap.sh"
    "$startdir/pmake" linux-64-rel -s "$startdir" -b
}

package() {
    cd "$startdir"
    "$startdir/pmake" -i "$pkgdir"
    
    # Install man pages
    for section in 1 3 5 7; do
        src="$startdir/docs/man/man$section"
        dest="$pkgdir/usr/share/man/man$section"
        mkdir -p "$dest"
        for file in "$src"/*."$section"; do
            [ -f "$file" ] && install -Dm644 "$file" "$dest"/
        done
    done
    
    install -Dm644 "$startdir/src/Extensions/unix/phasor.magic" \
        "$pkgdir/usr/share/file/magic/phasor"
}


--- .\pmake-bootstrap.bat ---
@echo off
setlocal
set SCRIPT_DIR=%~dp0
set TMP_DIR=%SCRIPT_DIR%.tmp

set ARCH=%1
if "%1"=="" (
    echo Usage: %0 [32^|64^|arm64]
    echo.
    echo   32     - Build for 32-bit x86
    echo   64     - Build for 64-bit x86-64
    echo   arm64  - Build for ARM64
    set /p ARCH="Enter a number: "
    cls      
)

powershell -Command "Write-Host -NoNewline \"Building pmake \"; git -C thirdparty/pmake rev-parse --short HEAD"

if /i "%ARCH%"=="32" (
    set CMAKE_PRESET=windows-32-rel
    set VSBUILD_ARCH=x86
    set VSBUILD_HOST_ARCH=x86
    set VSSTUDIO_COMPONENT=Microsoft.VisualStudio.Component.VC.Tools.x86.x64
    set PMAKE_TARGET=windows-32-rel
) else if /i "%ARCH%"=="64" (
    set CMAKE_PRESET=windows-32-rel
    set VSBUILD_ARCH=x86
    set VSBUILD_HOST_ARCH=x64
    set VSSTUDIO_COMPONENT=Microsoft.VisualStudio.Component.VC.Tools.x86.x64
    set PMAKE_TARGET=windows-64-rel
) else if /i "%ARCH%"=="arm64" (
    set CMAKE_PRESET=windows-arm64-rel
    set VSBUILD_ARCH=arm64
    set VSBUILD_HOST_ARCH=x64
    set VSSTUDIO_COMPONENT=Microsoft.VisualStudio.Component.VC.Tools.x86.x64
    set PMAKE_TARGET=windows-arm64-rel
) else (
    echo Invalid architecture: %ARCH%
    echo Valid options: 32, 64, arm64
    exit /b 1
)                           
powershell -Command "Write-Host -NoNewline \"`n[----------] SYNC\""
git submodule update --init 2>&1 1>nul
if errorlevel 1 (
    echo Failed to update git submodules
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[----------]                              `r[=---------] CFG vs-vswhere\""
set "VSWHERE=%ProgramFiles(x86)%\Microsoft Visual Studio\Installer\vswhere.exe"
if not exist "%VSWHERE%" (
    echo vswhere.exe not found
    exit /b 1
)
for /f "usebackq tokens=*" %%i in (`"%VSWHERE%" -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath`) do set "VS_PATH=%%i"
if not defined VS_PATH (
    echo No Visual Studio installation with required C++ tools found
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[=---------]                                         `r[==--------] CFG vs-vcvars\""
call "%VS_PATH%\Common7\Tools\VsDevCmd.bat" -arch=%VSBUILD_ARCH% -host_arch=%VSBUILD_HOST_ARCH% -no_logo
if errorlevel 1 (
    echo Failed to initialize Visual Studio environment
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[==--------]                                        `r[===-------] CFG phasor-cmake\""
cmake -S "%SCRIPT_DIR:~0,-1%" -B "%TMP_DIR%" --preset %CMAKE_PRESET% 2>&1 1>nul
if errorlevel 1 (
    echo CMake configuration failed
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[===-------]                                        `r[====------] CXX phasor_native_runtime_static\""
ninja -C "%TMP_DIR%" phasor_native_runtime_static 2>&1 1>nul
if errorlevel 1 (
    echo Building runtime failed
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[=====-----]                                        `r[======----] CXX phasor_cxx_transpiler\""
ninja -C "%TMP_DIR%" phasor_cxx_transpiler 2>&1 1>nul
if errorlevel 1 (
    echo Building compiler failed
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[=======---]                                        `r[=======---] PHS pmake.phs\""
ninja -C "%TMP_DIR%" pmake 2>&1 1>nul
if errorlevel 1 (
    echo Building pmake failed
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[=========-]                                        `r[=========-] INST pmake.exe .\""
copy "%TMP_DIR%\thirdparty\pmake\Executable\pmake\pmake.exe" "%SCRIPT_DIR%pmake.exe" /Y 2>&1 1>nul
if errorlevel 1 (
    echo Copying pmake.exe failed
    exit /b 1
)
powershell -Command "Write-Host -NoNewline \"`r[=========-]                                        `r[=========-] CLEAN\""
rmdir /s /q "%TMP_DIR%"
if errorlevel 1 (
    echo Failed to remove temporary files
    exit /b 1
)
powershell -Command "Write-Host \"`r[==========]                                        `r[==========] DONE\""
)  
endlocal

--- .\pmake-bootstrap.sh ---
#!/usr/bin/env bash
set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
TMP_DIR="$SCRIPT_DIR/.tmp"
BUILD_TYPE="rel"

if [ ! -d "$SCRIPT_DIR" ]; then
    echo "Cannot determine script directory"
    exit 1
fi

OS_NAME=$(uname -s)
case "$OS_NAME" in
    Darwin)
        OS="macos"
        ;;
    Linux)
        OS="linux"
        ;;
    *)
        OS="linux"
        ;;
esac

ARCH_NAME=$(uname -m)
case "$ARCH_NAME" in
    x86_64|amd64)
        ARCH=64
        ;;
    i386|i686)
        ARCH=32
        ;;
    arm64|aarch64)
        ARCH=arm64
        ;;
    *)
        echo "Unsupported architecture: $ARCH_NAME"
        exit 1
        ;;
esac

CMAKE_PRESET="${OS}-${ARCH}-${BUILD_TYPE}"

echo "SYNC"
git submodule update --init --recursive

echo "CFG phasor-cmake"
cmake -S "$SCRIPT_DIR" -B "$TMP_DIR" --preset "$CMAKE_PRESET"

echo "CXX phasor_native_runtime_static"
ninja -C "$TMP_DIR" phasor_native_runtime_static

echo "CXX phasor_cxx_transpiler"
ninja -C "$TMP_DIR" phasor_cxx_transpiler

echo "PHS pmake.phs"
ninja -C "$TMP_DIR" pmake

echo "INST pmake"
cp "$TMP_DIR/thirdparty/pmake/Executable/pmake/pmake" "$SCRIPT_DIR/pmake"

echo "CLEAN"
rm -rf "$TMP_DIR"

echo "DONE"

--- .\project.pmake ---
Phasor
3.0.0
git rev-parse --short HEAD
out
.
.pmake

--- .\README.md ---
# Phasor <img src="https://phasor.pages.dev/assets/logo.svg" alt="Phasor Logo (Hand-drawn sinewave)" width="320" height="160"> Language

A statically typed, compiled programming language with a hybrid stack/register-based bytecode virtual machine, *designed* for flexibility.

Phasor is still in beta, as I wish for a **smooth, stable experience** for the final language. The existing implementation still needs a vast amount of work. Although it's perfectly stable now, at least enough for me to prototype with.

> [!NOTE]
> 
> This software will not available in the US state of California starting January 1st, 2027.
>
> This software will not available in the US state of Colorado starting January 1st, 2028.
>
> [See more](https://github.com/DanielLMcGuire/Phasor/wiki/Political-Disclaimer)

You can check out the [website](https://phasor.pages.dev/) as well.

---

## Language Features

- **Dynamic typing** with integers, floats (IEEE 754, double-percision), strings, booleans, and null. ```var x = 21; // int```
- **Type annotations** (only in function declarations) ```fn func(input: string) -> void { ... }```
- **Control flow**: if/else, while, for, switch/case, break/continue
- **Standard library** ```using(featureName: string)```
- **Plugin/FFI API** [PhasorFFI.h](https://github.com/DanielLMcGuire/Phasor/blob/master/include/PhasorFFI.h)
- **Runtime API** [PhasorRT.h](https://github.com/DanielLMcGuire/Phasor/blob/master/include/PhasorRT.h)
- **Minimal Windows and POSIX API Bindings**
- Supports *most* [**C format specifiers**](https://www.geeksforgeeks.org/c/format-specifiers-in-c/)

```javascript
// Print (keyword)
print "Hello World!\n"; // Print to console
// Or via std
using("stdio"); // Import io for puts
puts("Hello World!"); // Print string with newline
```
```javascript
using("stdsys", "stdio"); // Import sys, io
// Variables
var code = 15; // int
var fmt = "Code = %d"; // string
// Formatting
printf("Exiting with code %d", code);
putf("%d", code);
var fmtStr = c_fmt(fmt, code);
// Exit with a code other than 0
shutdown(code); // from stdsys
```

## Upcoming 
> [!IMPORTANT]
>
> Some may *appear* to work before actual implementation

- **Structs** with C style static field access ```struct.member = 14;```
- **Arrays** with C syntax ```var arrayName[arraySize];``` 
- **[Translation units / Modules](https://github.com/DanielLMcGuire/Phasor/issues/5)** 

---

## Q/A

> **Q** - Are you just ripping off the best from every language?
>
> **A** - No, the idea started before I knew much about other languages, some inspiration however did come from the majority of the programming languages I use. <sub>(Like C++, Python, TS, C to name a few)</sub>
>
> **Q** - What is this? Why would I even need this?
>
> **A** - You probably don't.
>
> **Q** - Is this better than 'Java' or '.NET'?
>
> **A** - Phasor doesn't beat anything without PGO (which even this is determinisic)
>
> **Q** - How is it somewhat fast without JIT?
>
> **A** - Easy! Just pray the entire core end up into L1/L2, then just let the CPU handle it! (Yes, this actually works, no joke)

## Quick Start

```bash
# Compile and run a program
phasorjit input.phs # or use 'phasor input.phs'

# Interactive REPL 
phasorrepl # or use 'phasor'

# Compile to bytecode
phasorcompiler input.phs (-o, --output output.phsb)

# Run bytecode
phasorvm output.phsb # or use 'phasor output.phsb'

# Run a script raw
cat input.phs | phasor
```

### Example Program

```javascript
using("stdio", "stdtype");

puts("Enter a number:");
var input = gets();
var num1 = to_int(input);
var num2 = 25;
putf("%d + %d = %d\n", num, num2, num1 + num2);
```

---

## Documentation

> [!NOTE]
>
> Documentation may be partially AI generated, always confirm the feature works first
>
> This will change once I have more time for this project


- **[Language Guide](https://phasor.pages.dev/document?file=https%3A%2F%2Fphasor-docs.pages.dev%2Fcontent%2Fguide_phasor_language.md&name=Language%20Guide)** - Complete syntax and language features
- **[VM Internals](https://phasor.pages.dev/document?file=https%3A%2F%2Fphasor-docs.pages.dev%2Fcontent%2Fguide_vm_internals.md&name=VM%20Internals)** - Virtual machine architecture details
- **[Adding Opcodes](https://phasor.pages.dev/document?file=https%3A%2F%2Fphasor-docs.pages.dev%2Fcontent%2Fguide_adding_opcodes.md&name=Adding%20Opcodes)** - Contributor guide for VM extensions
- **[Doxygen](https://phasor-docs.pages.dev)** - Documentation and call graphs generated from source code
- **Manuals/Man Pages:** `https://phasor-docs.pages.dev/man?f=[filename]`, e.g. `/man?f=Phasor.3`, `/man?f=phasorvm.1`, `/man?f=PHIR.5`, etc.

## Contributing

1. Read the [VM Internals](https://phasor.pages.dev/document?file=https%3A%2F%2Fphasor-docs.pages.dev%2Fcontent%2Fguide_vm_internals.md&name=VM%20Internals) and [Adding Opcodes](https://phasor.pages.dev/document?file=https%3A%2F%2Fphasor-docs.pages.dev%2Fcontent%2Fguide_adding_opcodes.md&name=Adding%20Opcodes) guides
2. Follow the existing code style (see `.clang-format`)
3. Add tests for new features
4. Update documentation as needed

## Applications

- **phasor** - Combines the JIT Runtime, VM Runtime, and REPL, as well as adding pipe-in for raw scripts, and supports shabangs
- **phasor-lsp** - JSON-RPC 2.0 LSP Protocol Handler for the Phasor Language
- **REPL** ([`phasorrepl`](https://phasor-docs.pages.dev/man?f=phasorrepl.1)) - Interactive interpreter
- **Bytecode Compiler** ([`phasorcompiler`](https://phasor-docs.pages.dev/man?f=phasorcompiler.1)) - Script to bytecode compiler
- **Native Compiler** ([`phasornative`](https://phasor-docs.pages.dev/man?f=phasornative.1)) - Script to C++ transpiler
- **VM Runtime** ([`phasorvm`](https://phasor-docs.pages.dev/man?f=phasorvm.1)) - Bytecode executor
- **JIT Runtime** ([`phasorjit`](https://phasor-docs.pages.dev/man?f=phasorjit.1)) - Direct script executor
- **Shell** (`shell`) - Phasor-based command shell **PREVIEW**
- **Core Utils** (`cat-phs`, `cp-phs`, `echo-phs`, `ls-phs`, `mv-phs`, `rm-phs`, `touch-phs`) - Unix-like utilities **PREVIEW**

---

## Overview

This repo contains:

- Frontend:
  - [Phasor Language](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Language/Phasor) ([Specifications](https://github.com/DanielLMcGuire/Phasor/blob/master/docs/man/man5/PHS.5), C++)
  - [Pulsar Language](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Language/Pulsar) (C++)
  - [Phasor Runtime](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Runtime) / [VM](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Runtime/VM) ([ISA Specs](https://github.com/DanielLMcGuire/Phasor/blob/master/docs/man/man7/phasor-isa.7), C/C++/Assembly)
  - [Phasor Standard Library](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Runtime/Stdlib) ([Specifications](https://github.com/DanielLMcGuire/Phasor/tree/master/docs/man/man3), C/C++)
 
- Backend:
  - [Phasor Compiler Infrastructure](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Backend) (C++)
  - [FFI API](https://github.com/DanielLMcGuire/Phasor/blob/master/include/PhasorFFI.h) (C)
  - [Runtime API](https://github.com/DanielLMcGuire/Phasor/blob/master/include/PhasorRT.h) (C)

- Extensions:
  - [Phasor](https://github.com/DanielLMcGuire/Phasor/blob/master/src/Extensions/Phasor.tmLanguage) & [Phasor IR](https://github.com/DanielLMcGuire/Phasor/blob/master/src/Extensions/phasor-ir.tmLanguage) TextMate Grammar
  -  [Phasor Visual Studio Code Extension](https://github.com/DanielLMcGuire/Phasor/tree/master/src/Extensions/vscode) (Typescript)

---

## Building

<sub>Using Arch BTW? Just run `makepkg -si`</sub>

### Prerequisites

- CMake 3.10+
- C++20 compiler (MSVC, GCC, Clang)
- Ninja

### Build Steps

[Moved over to the wiki](https://github.com/DanielLMcGuire/Phasor/wiki/Building-Phasor)

### Plugin locations
(Like win32 api, posix) are available in different locations based on your OS:

- Unix - `opt/Phasor/plugins/`
- macOS - `library/Application Support/org.Phasor.Phasor/plugins`
- Windows - `bin/plugins` 

---

**Phasor** - Fast, flexible programming/scripting with *near* native VM performance.

- Phasor Language / ISA / VM / Toolchain / Standard Library | [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0.txt)
- Phasor Shell | [MIT License](https://opensource.org/license/mit)
- Phasor coreutils implementation | [GNU General Public License 3.0](https://www.gnu.org/licenses/gpl-3.0.en.html)

Mentions of 'coreutils', the Free Software Foundation, Inc., 'Java™', Oracle® Corporation, '.NET™', Microsoft® Corporation, Google® LLC, or other third-party companies, products, or trademarks do not imply any affiliation, endorsement, or sponsorship by those third parties, or thier affiliates, unless explicitly stated otherwise.

Phasor and the "sinewave Phasor" logo are trademarks of Daniel McGuire.


--- .\scripts\bootstrap-pmake.phs ---
using("stdsys", "stdstr", "stdio");

var scriptDir = fcd();
var tmp_dir = concat(scriptDir, ".tmp");
var preset;
var supported = false;


if (sys_argc() == 2)
    var arch = sys_argv(1);

if (!arch || arch == 64 || arch == 32 || arch == "arm64") { 
    supported = true;
    preset = c_fmt("%s-%s-rel", sys_os(), to_string(arch));
}
if (!supported) {
    putf(`
Usage: %s [32|64|arm64]
  32     - Build for 32-bit x86
  64     - Build for 64-bit x86-64
  arm64  - Build for ARM64`, sys_argv(0));
    shutdown(1);
}

print("Building pmake ");
sys_fork("git", "-C", "thirdparty/pmake", "rev-parse", "--short", "HEAD");

// SYNC
// CFG
// 

--- .\scripts\build.pul ---
#!/usr/bin/env pulsar
using("stdsys", "stdio", "stdstr", "stdfile", "stdtype")

let conf = "build.conf"
let g_clean = false
let show_help = false

func printHelp() {
	putf(`
phasor %s [option] CONFIG 

    CONFIG      - Configuration File (defaults to build.conf)

Options:
    -c, --clean - Clean build files
    -h, --help  - Show this help message

Example Config File:
    in.phs
    out.phsb
    phasorcompiler
    --no-logo -o %%s %%s`, 
	sys_argv(0))

	if (fexists(conf)) {
		putf(`
Current Config:

    Source:   %s
    Binary:   %s
    Compiler: %s
    Flags:    %s
    Command:  %s`, 
	src, 
	dest, 
	comp, 
	args, 
	c_fmt("%s %s", comp, c_fmt(args, dest, src)))
	}
}

func build(src: string, dest: string, comp: string, args: string) -> bool {
    putf("Using compiler: %s\n\nBuilding Phasor Binary: %s -> %s", comp, src, dest)
    return to_bool(sys_execute(c_fmt("%s %s", comp, c_fmt(args, dest, src))))
}

if (sys_argc() >= 2) {
    var argument = sys_argv(1)
	if (argument == "--help" || argument == "-h") {
		show_help = true
	} else if (argument == "--clean" || argument == "-c") {
        g_clean = true
    } else {
		conf = argument
	}
	if (sys_argc() == 3)
		conf = sys_argv(2)
}

if (conf != null || conf != "") {
	src = freadln(conf, 0)  // 1 - Source File
	dest = freadln(conf, 1)  // 2 - Out File
    comp = freadln(conf, 2) // 3 - Compiler
    args = freadln(conf, 3) // 4 - Compiler Flags
} else {
	puts("Invalid configuration file!")
}

if (show_help) {
    printHelp()
    shutdown(0)
}

if (g_clean) {
    var stat = !frm(dest)
    putf("Cleaned %s", dest)
    shutdown(stat)
}

shutdown(!build(src, dest, comp, args))


--- .\scripts\dist_linux.sh ---
#!/bin/bash
set -e

if [ ! -f "linuxdeploy-x86_64.AppImage" ]; then
    wget https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage
    chmod +x linuxdeploy-x86_64.AppImage
fi

cmake -S . -B build -G Ninja
cmake --build build --target phasor_compiler
cmake --build build --target phasor_repl
cmake --build build --target phasor_runtime_exe
cmake --build build --target phasor_interpreter

convert_ico_to_png() {
    local ico_file=$1
    local png_file=$2
    
    if [ -f "$ico_file" ] && [ ! -f "$png_file" ]; then
        convert "$ico_file" -thumbnail 256x256 -alpha on -background none -flatten "$png_file"
    fi
}
convert_ico_to_png "assets/Compiler.ico" "phasorcompiler.png"
convert_ico_to_png "assets/Repl.ico" "phasorrepl.png"
convert_ico_to_png "assets/BinaryRuntime.ico" "phasorvm.png"
convert_ico_to_png "assets/ScriptingRuntime.ico" "phasorjit.png"

build_with_linuxdeploy() {
    local executable=$1
    local appname=$2
    local icon_file=$3
    
    local desktop_file=$(mktemp --suffix=.desktop)
    cat > "$desktop_file" <<EOF
[Desktop Entry]
Type=Application
Name=$appname
Exec=$executable
Icon=$executable
Categories=Development;
Terminal=true
EOF
    
    ./linuxdeploy-x86_64.AppImage \
        --appdir AppDir-temp \
        --executable="build/$executable" \
        --desktop-file="$desktop_file" \
        --icon-file="$icon_file" \
        --output appimage

    rm "$desktop_file"
	rm "$icon_file"
    rm -rf AppDir-temp
}
build_with_linuxdeploy "phasorcompiler" "Phasor Compiler" "phasorcompiler.png"
build_with_linuxdeploy "phasorrepl" "Phasor REPL" "phasorrepl.png"
build_with_linuxdeploy "phasorvm" "Phasor Runtime" "phasorvm.png"
build_with_linuxdeploy "phasorjit" "Phasor Interpreter" "phasorjit.png"

--- .\scripts\installer.nsi ---
!include "x64.nsh"
!define APP_NAME "Phasor Programming Language"
!define COMP_NAME "Phasor"
!define VERSION "3.0.0.0"
!define COPYRIGHT "(C) 2026 Daniel McGuire"
!define LICENSE_TXT "license.txt"
!define DESCRIPTION "Functional VM Compiled Programming Language"
!define INSTALLER_NAME "phasor-3.0.0_setup.exe"
!define INSTALL_TYPE "SetShellVarContext all"
!define REG_ROOT "HKLM"
!define MAIN_APP_EXE "bin\phasor.exe"
!define REG_APP_PATH "Software\Microsoft\Windows\CurrentVersion\App Paths\${MAIN_APP_EXE}"
!define UNINSTALL_PATH "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_NAME}"

######################################################################

VIProductVersion  "${VERSION}"
VIAddVersionKey "ProductName"  "${APP_NAME}"
VIAddVersionKey "CompanyName"  "${COMP_NAME}"
VIAddVersionKey "LegalCopyright"  "${COPYRIGHT}"
VIAddVersionKey "FileDescription"  "${DESCRIPTION}"
VIAddVersionKey "FileVersion"  "${VERSION}"

######################################################################

SetCompressor /SOLID /FINAL LZMA
Name "${APP_NAME}"
Caption "${APP_NAME}"
OutFile "${INSTALLER_NAME}"
BrandingText "${COMP_NAME}"
XPStyle on
InstallDirRegKey "${REG_ROOT}" "${REG_APP_PATH}" ""
InstallDir "$PROGRAMFILES64\Phasor Programming Language"


######################################################################

!include "MUI2.nsh"
!include "x64.nsh"

!define MUI_ABORTWARNING
!define MUI_UNABORTWARNING

!insertmacro MUI_PAGE_WELCOME

!ifdef LICENSE_TXT
!insertmacro MUI_PAGE_LICENSE "${LICENSE_TXT}"
!endif

!insertmacro MUI_PAGE_DIRECTORY

!insertmacro MUI_PAGE_INSTFILES

!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_UNPAGE_CONFIRM

!insertmacro MUI_UNPAGE_INSTFILES

!insertmacro MUI_UNPAGE_FINISH

!insertmacro MUI_LANGUAGE "English"

######################################################################

Function .onInit
    ${If} ${RunningX64}
    ${Else}
        MessageBox MB_OK|MB_ICONEXCLAMATION "This program requires a 64-bit processor."
        Abort
    ${EndIf}
FunctionEnd

######################################################################

Section -MainProgram
${INSTALL_TYPE}
SetOverwrite ifnewer
SetOutPath "$INSTDIR"
file /r "..\out\"
file "..\assets\phasor.ico"


SectionEnd

######################################################################

Section -Icons_Reg
SetOutPath "$INSTDIR"

WriteUninstaller "$INSTDIR\uninstall.exe"

WriteRegStr ${REG_ROOT} "${REG_APP_PATH}" "" "$INSTDIR\${MAIN_APP_EXE}"
WriteRegStr ${REG_ROOT} "${UNINSTALL_PATH}"  "DisplayName" "${APP_NAME}"
WriteRegStr ${REG_ROOT} "${UNINSTALL_PATH}"  "UninstallString" "$INSTDIR\uninstall.exe"
WriteRegStr ${REG_ROOT} "${UNINSTALL_PATH}"  "DisplayIcon" "$INSTDIR\phasor.ico"
WriteRegStr ${REG_ROOT} "${UNINSTALL_PATH}"  "DisplayVersion" "${VERSION}"
WriteRegStr ${REG_ROOT} "${UNINSTALL_PATH}"  "Publisher" "${COMP_NAME}"

; Ensure 64-bit registry view
SetRegView 64
ClearErrors

; Read Installed DWORD
ReadRegDWORD $R0 HKLM "SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x64" "Installed"
SetRegView 32 ; restore default

; Check if read failed or value is not 1
IfErrors DownloadVC
IntCmp $R0 1 SkipDownload DownloadVC

SkipDownload:
  DetailPrint "Visual C++ Redistributable (x64) is already installed."
  Goto EndVC

DownloadVC:
  DetailPrint "Downloading Visual C++ Redistributable (x64)..."
  NSISdl::download "https://aka.ms/vs/17/release/vc_redist.x64.exe" "$PLUGINSDIR\vc_redist.x64.exe"
  Pop $R0
  StrCmp $R0 "success" 0 +3
    MessageBox MB_OK "Download failed: $R0"
    Abort

  DetailPrint "Installing Visual C++ Redistributable (x64)..."
  ExecWait '"$PLUGINSDIR\vc_redist.x64.exe" /install /passive /norestart /log "$PLUGINSDIR\vslog.txt"'
  StrCmp $R0 "0" 0 +2
    MessageBox MB_OK "VC++ Redistributable installation might have failed."

EndVC:

; .phir -> PhasorIR
WriteRegStr HKCU "Software\Classes\.phir" "" "PhasorIR"
; .phs -> PhasorSource
WriteRegStr HKCU "Software\Classes\.phs" "" "PhasorSource"
; .phsb -> PhasorBinary
WriteRegStr HKCU "Software\Classes\.phsb" "" "PhasorBinary"
; .pul -> PulsarScript
WriteRegStr HKCU "Software\Classes\.pul" "" "PulsarScript"

; PhasorBinary
WriteRegStr HKCU "Software\Classes\PhasorBinary" "" "Phasor Binary File"
WriteRegStr HKCU "Software\Classes\PhasorBinary\shell\open" "Icon" "$INSTDIR\${MAIN_APP_EXE}"
WriteRegStr HKCU "Software\Classes\PhasorBinary\shell\open\command" "" '"$INSTDIR\${MAIN_APP_EXE}" "%1" %*'
; PhasorIR
WriteRegStr HKCU "Software\Classes\PhasorIR" "" "Phasor IR File"
WriteRegStr HKCU "Software\Classes\PhasorIR\shell\open" "Icon" "$INSTDIR\bin\phasorcompiler.exe"
; PhasorSource
WriteRegStr HKCU "Software\Classes\PhasorSource" "" "Phasor Source File"
WriteRegStr HKCU "Software\Classes\PhasorSource\shell\open" "Icon" "$INSTDIR\bin\phasorjit.exe"
WriteRegStr HKCU "Software\Classes\PhasorSource\shell\open\command" "" '"$INSTDIR\bin\phasorjit.exe" "%1" %*'
; PulsarScript
WriteRegStr HKCU "Software\Classes\PulsarScript" "" "Pulsar Script File"
WriteRegStr HKCU "Software\Classes\PulsarScript\shell\open" "Icon" "$INSTDIR\bin\pulsar.exe"
WriteRegStr HKCU "Software\Classes\PulsarScript\shell\open\command" "" '"$INSTDIR\bin\pulsar.exe" "%1" %*'

EnVar::SetHKLM
EnVar::AddValue "PATH" "$INSTDIR\bin"

System::Call 'shell32::SHChangeNotify(i 0x08000000, i 0, i 0, i 0)'
SectionEnd

######################################################################

Section Uninstall
${INSTALL_TYPE}
Delete "$INSTDIR\${MAIN_APP_EXE}"
RmDir /r "$INSTDIR"

DeleteRegKey ${REG_ROOT} "${REG_APP_PATH}"
DeleteRegKey ${REG_ROOT} "${UNINSTALL_PATH}"

; Remove type associations
DeleteRegKey HKCU "Software\Classes\.phir"
DeleteRegKey HKCU "Software\Classes\.phs"
DeleteRegKey HKCU "Software\Classes\.phsb"

; Remove PhasorBinary
DeleteRegKey HKCU "Software\Classes\PhasorBinary\shell\open\command"
DeleteRegKey HKCU "Software\Classes\PhasorBinary\shell\open"
DeleteRegKey HKCU "Software\Classes\PhasorBinary\shell"
DeleteRegKey HKCU "Software\Classes\PhasorBinary"

; Remove PhasorIR
DeleteRegKey HKCU "Software\Classes\PhasorIR\shell\open"
DeleteRegKey HKCU "Software\Classes\PhasorIR\shell"
DeleteRegKey HKCU "Software\Classes\PhasorIR"

; Remove PhasorScript
DeleteRegKey HKCU "Software\Classes\PhasorScript\shell\open\command"
DeleteRegKey HKCU "Software\Classes\PhasorScript\shell\open"
DeleteRegKey HKCU "Software\Classes\PhasorScript\shell"
DeleteRegKey HKCU "Software\Classes\PhasorScript"

EnVar::SetHKLM
EnVar::DeleteValue "PATH" "$INSTDIR\bin"

System::Call 'shell32::SHChangeNotify(i 0x08000000, i 0, i 0, i 0)'
SectionEnd

######################################################################



--- .\scripts\license.txt ---
Phasor End User License Agreement (EULA) 1.1

IMPORTANT - READ CAREFULLY: This is a legal agreement between you (the user) and Daniel McGuire.

This agreement applies only to precompiled binary distributions of the Phasor Programming Language.

This agreement does not apply to builds compiled from source, including, but not limited to, nightly or CI releases generated via GitHub Actions, Azure DevOps, or similar first- or third-party services.

1. License Grant
Subject to your compliance with this agreement, you may install and use Phasor Toolchain on your devices for personal/commercial use. This license does not grant rights to modify, reverse engineer, redistribute, or create derivative works of the binary release of Phasor.

2. Restrictions
You may not:
a) Redistribute Phasor or any part of it,
b) Modify Phasor except for personal experimentation,
c) Use Phasor to create competing programming languages, virtual machines, or standard libraries,
d) Use modifications provided or generated by users using the Phasor Programming Language source code.

3. Termination
This license remains effective until terminated. Any violation of these terms automatically terminates your rights under this agreement.

4. Disclaimer
Phasor is provided "as is," without any warranty of any kind. The author is not responsible for any damage or loss arising from its use.

By installing or using Phasor, you agree to be bound by the terms of this agreement.


--- .\scripts\phasor.install ---
post_install() {
    echo "==> Rebuilding file magic database..."
    cd /usr/share/file/misc
    file -C -m /usr/share/file/magic
}

post_upgrade() {
    post_install
}

post_remove() {
    echo "==> Rebuilding file magic database..."
    cd /usr/share/file/misc
    file -C -m /usr/share/file/magic
}

--- .\scripts\PKGBUILD.git ---
# Maintainer: Daniel McGuire <danielmcguire2023@gmail.com>
pkgname=phasor-git
PACKAGER="Daniel McGuire <danielmcguire2023@gmail.com>"
pkgver=3.0.0.git
pkgrel=1
pkgdesc="Phasor Programming Language Toolchain"
arch=('x86_64')
url="https://github.com/DanielLMcGuire/Phasor"
license=('0BSD')
makedepends=('git' 'gcc' 'cmake' 'ninja')
optdepends=('gcc: For building Phasor Native wrappers.')
conflicts=('phasor' 'phasor-dev')
options=(strip !debug)
install=phasor.install
depends=()
source=("git+https://github.com/DanielLMcGuire/Phasor.git")
sha256sums=('SKIP')

pkgver() {
    cd "$srcdir/Phasor"
    tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "3.0.0")
    commits_since_tag=$(git rev-list "${tag}"..HEAD --count 2>/dev/null || echo 0)
    short_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "")
    if [ "$commits_since_tag" -eq 0 ]; then
        echo "$tag.git"
    else
        echo "${tag}.r${commits_since_tag}.${short_hash}"
    fi
}

build() {
    cd "$srcdir/Phasor"
    cmake -S . -B build -G Ninja --preset linux-64-rel
    cmake --build build
}

package() {
    cd "$srcdir/Phasor/build"
    cmake --install . --prefix "$pkgdir"
    for section in 1 3 5 7; do
        src="$srcdir/Phasor/docs/man/man$section"
        dest="$pkgdir/usr/share/man/man$section"
        mkdir -p "$dest"
        for file in "$src"/*."$section"; do
            [ -f "$file" ] && install -Dm644 "$file" "$dest"/
        done
    done
	
	install -Dm644 "$srcdir/Phasor/src/Extensions/unix/phasor.magic" \
        "$pkgdir/usr/share/file/magic/phasor"
}


--- .\scripts\PKGBUILD.main ---
# Maintainer: Daniel McGuire <danielmcguire2023@gmail.com>
pkgname=phasor
PACKAGER="Daniel McGuire <danielmcguire2023@gmail.com>"
pkgver=3.0.0
pkgrel=1
pkgdesc="Phasor Programming Language Toolchain"
arch=('x86_64')
url="https://github.com/DanielLMcGuire/Phasor"
license=('0BSD')
makedepends=('gcc' 'cmake' 'ninja')
optdepends=('gcc: For building Phasor Native wrappers.')
conflicts=('phasor-git' 'phasor-dev')
options=(strip !debug)
install=phasor.install
depends=()
source=("https://github.com/DanielLMcGuire/Phasor/archive/refs/tags/3.0.0.tar.gz")
sha256sums=('342D1C1FC04354A74B52EF3D7AE7BC4A0C5A59342B856EE342416F1E360D959F')

build() {
    cd "$srcdir/Phasor-3.0.0"
    cmake -S . -B build -G Ninja --preset linux-64-rel
    cmake --build build --config Release
}

package() {
    cd "$srcdir/Phasor-3.0.0/build"
    cmake --install . --prefix "$pkgdir"
    for section in 1 3 5 7; do
        src="$srcdir/Phasor-3.0.0/docs/man/man$section"
        dest="$pkgdir/usr/share/man/man$section"
        mkdir -p "$dest"
        for file in "$src"/*."$section"; do
            [ -f "$file" ] && install -Dm644 "$file" "$dest"/
        done
    done
	
	install -Dm644 "$srcdir/Phasor-3.0.0/src/Extensions/unix/phasor.magic" \
        "$pkgdir/usr/share/file/magic/phasor"
}


--- .\scripts\winapi.h ---
DWORD GetTickCount(void);
DWORD GetTickCount64(void);
DWORD GetCurrentProcessId(void);
DWORD GetCurrentThreadId(void);
DWORD GetLastError(void);
DWORD GetVersion(void);
BOOL  Beep(DWORD dwFreq, DWORD dwDuration);
DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);
DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);
BOOL  SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);
BOOL  SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);
UINT  GetACP(void);
UINT  GetOEMCP(void);
UINT  GetConsoleCP(void);
UINT  GetConsoleOutputCP(void);
ULONG MulDiv(ULONG nNumber, ULONG nNumerator, ULONG nDenominator);
int   MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
int   MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
int  MessageBoxTimeoutA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId, DWORD dwMilliseconds);
int  MessageBoxTimeoutW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId,
                        DWORD dwMilliseconds);
BOOL SetCursorPos(int X, int Y);
BOOL GetCursorPos(LPPOINT lpPoint);
int  GetSystemMetrics(int nIndex);
BOOL ShowWindow(HWND hWnd, int nCmdShow);
BOOL EnableWindow(HWND hWnd, BOOL bEnable);
HWND GetForegroundWindow();
HWND GetDesktopWindow();
HANDLE    GetStdHandle(DWORD nStdHandle);
HMODULE   GetModuleHandleA(LPCSTR lpModuleName);
HMODULE   GetModuleHandleW(LPCWSTR lpModuleName);
HINSTANCE LoadLibraryA(LPCSTR lpLibFileName);
HINSTANCE LoadLibraryW(LPCWSTR lpLibFileName);
BOOL      CloseHandle(HANDLE hObject);
BOOL      IsWindow(HWND hWnd);
BOOL      SetWindowTextA(HWND hWnd, LPCSTR lpString);
BOOL      SetWindowTextW(HWND hWnd, LPCWSTR lpString);
BOOL      GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount);
BOOL      GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
BOOL      ShowCursor(BOOL bShow);
UINT      GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
UINT      GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);


--- .\SECURITY.md ---
# Security Policy

## Supported Versions

| Version | Supported          |
| ------- | ------------------ |
| >= 2.1.X   | :white_check_mark: |
| < 2.1.X | :x:                |

## Report a Security Issue

https://github.com/DanielLMcGuire/Phasor/security/advisories/new


--- .\src\AST\AST.hpp ---
#pragma once
#include <iostream>
#include <memory>
#include <string>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{
/// @brief Token types for the lexer
enum class TokenType
{
	Identifier,
	Number,
	String,
	Keyword,
	Symbol,
	EndOfFile,
	Unknown
};
/// @brief Token structure
struct Token
{
	TokenType   type;
	std::string lexeme;
	size_t      line;
	size_t      column;
};

/// @brief Abstract Syntax Tree (AST) namespace
namespace AST
{

// Forward declarations
struct Node;
struct Expression;
struct Statement;
struct Program;

/// @brief AST Node
struct Node
{
	virtual ~Node() = default;
	virtual void print(int indent = 0) const = 0;
	size_t       line = 0;
	size_t       column = 0;
};

/// @brief Expression Node
struct Expression : public Node
{
};

/// @brief Statement Node
struct Statement : public Node
{
};

/// @brief Program Node
struct Program : public Node
{
	std::vector<std::unique_ptr<Statement>> statements;
	void                                    print(int indent = 0) const override
	{
		for (const auto &stmt : statements)
		{
			stmt->print(indent);
		}
	}
};

/// @brief Type Node
struct TypeNode : public Node
{
	std::string      name;
	bool             isPointer = false;
	std::vector<int> arrayDimensions;

	TypeNode(std::string n, bool ptr = false, std::vector<int> dims = {})
	    : name(n), isPointer(ptr), arrayDimensions(std::move(dims))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "Type: " << name << (isPointer ? "*" : "") << "\n";
		for (int dim : arrayDimensions)
		{
			std::cout << std::string(indent + 2, ' ') << "ArrayDim: " << dim << "\n";
		}
	}
};

/// @brief Numeral Expression Node
struct NumberExpr : public Expression
{
	std::string value;
	NumberExpr(std::string v) : value(v)
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "Number: " << value << "\n";
	}
};

/// @brief String Expression Node
struct StringExpr : public Expression
{
	std::string value;
	StringExpr(std::string v) : value(v)
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "String: " << value << "\n";
	}
};

/// @brief Identifier Expression Node
struct IdentifierExpr : public Expression
{
	std::string name;
	IdentifierExpr(std::string n) : name(n)
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "Identifier: " << name << "\n";
	}
};

/// @brief Boolean Expression Node
struct BooleanExpr : public Expression
{
	bool value;
	BooleanExpr(bool v) : value(v)
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "Boolean: " << (value ? "true" : "false") << "\n";
	}
};

/// @brief NULL Expression Node
struct NullExpr : public Expression
{
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "Null\n";
	}
};

/// @brief Unary operator types
enum class UnaryOp
{
	Negate,     // -x
	Not,        // !x
	AddressOf,  // &x
	Dereference // *x
};

/// @brief Binary operator types
enum class BinaryOp
{
	Add,
	Subtract,
	Multiply,
	Divide,
	Modulo,
	And,
	Or,
	Equal,
	NotEqual,
	LessThan,
	GreaterThan,
	LessEqual,
	GreaterEqual
};

/// @brief Postfix operator types
enum class PostfixOp
{
	Increment, // x++
	Decrement  // x--
};

/// @brief Postfix Expression Node
struct PostfixExpr : public Expression
{
	PostfixOp                   op;
	std::unique_ptr<Expression> operand;

	PostfixExpr(PostfixOp o, std::unique_ptr<Expression> expr) : op(o), operand(std::move(expr))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "PostfixExpr: ";
		switch (op)
		{
		case PostfixOp::Increment:
			std::cout << "++\n";
			break;
		case PostfixOp::Decrement:
			std::cout << "--\n";
			break;
		}
		operand->print(indent + 2);
	}
};

/// @brief Unary Expression Node
struct UnaryExpr : public Expression
{
	UnaryOp                     op;
	std::unique_ptr<Expression> operand;

	UnaryExpr(UnaryOp o, std::unique_ptr<Expression> expr) : op(o), operand(std::move(expr))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "UnaryExpr: ";
		switch (op)
		{
		case UnaryOp::Negate:
			std::cout << "-\n";
			break;
		case UnaryOp::Not:
			std::cout << "!\n";
			break;
		case UnaryOp::AddressOf:
			std::cout << "&\n";
			break;
		case UnaryOp::Dereference:
			std::cout << "*\n";
			break;
		}
		operand->print(indent + 2);
	}
};

/// @brief Binary Expression Node
struct BinaryExpr : public Expression
{
	std::unique_ptr<Expression> left;
	BinaryOp                    op;
	std::unique_ptr<Expression> right;

	BinaryExpr(std::unique_ptr<Expression> l, BinaryOp o, std::unique_ptr<Expression> r)
	    : left(std::move(l)), op(o), right(std::move(r))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "BinaryExpr: ";
		switch (op)
		{
		case BinaryOp::Add:
			std::cout << "+\n";
			break;
		case BinaryOp::Subtract:
			std::cout << "-\n";
			break;
		case BinaryOp::Multiply:
			std::cout << "*\n";
			break;
		case BinaryOp::Divide:
			std::cout << "/\n";
			break;
		case BinaryOp::Modulo:
			std::cout << "%\n";
			break;
		case BinaryOp::And:
			std::cout << "&&\n";
			break;
		case BinaryOp::Or:
			std::cout << "||\n";
			break;
		case BinaryOp::Equal:
			std::cout << "==\n";
			break;
		case BinaryOp::NotEqual:
			std::cout << "!=\n";
			break;
		case BinaryOp::LessThan:
			std::cout << "<\n";
			break;
		case BinaryOp::GreaterThan:
			std::cout << ">\n";
			break;
		case BinaryOp::LessEqual:
			std::cout << "<=\n";
			break;
		case BinaryOp::GreaterEqual:
			std::cout << ">=\n";
			break;
		}
		left->print(indent + 2);
		right->print(indent + 2);
	}
};

/// @brief Array Access Expression Node
struct ArrayAccessExpr : public Expression
{
	std::unique_ptr<Expression> array;
	std::unique_ptr<Expression> index;

	ArrayAccessExpr(std::unique_ptr<Expression> arr, std::unique_ptr<Expression> idx)
	    : array(std::move(arr)), index(std::move(idx))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ArrayAccess:\n";
		array->print(indent + 2);
		std::cout << std::string(indent + 2, ' ') << "Index:\n";
		index->print(indent + 4);
	}
};

/// @brief Array Literal Expression Node
struct ArrayLiteralExpr : public Expression
{
	std::vector<std::unique_ptr<Expression>> elements;
	ArrayLiteralExpr(std::vector<std::unique_ptr<Expression>> elems) : elements(std::move(elems))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ArrayLiteral:\n";
		for (const auto &elem : elements)
			elem->print(indent + 2);
	}
};

/// @brief Member Access Expression Node
struct MemberAccessExpr : public Expression
{
	std::unique_ptr<Expression> object;
	std::string                 member;

	MemberAccessExpr(std::unique_ptr<Expression> obj, std::string mem) : object(std::move(obj)), member(mem)
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "MemberAccess: ." << member << "\n";
		object->print(indent + 2);
	}
};

/// @brief Call Expression Node
struct CallExpr : public Expression
{
	std::string                              callee;
	std::vector<std::unique_ptr<Expression>> arguments;

	CallExpr(std::string name, std::vector<std::unique_ptr<Expression>> args) : callee(name), arguments(std::move(args))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "CallExpr: " << callee << "\n";
		for (const auto &arg : arguments)
		{
			arg->print(indent + 2);
		}
	}
};

/// @brief Assignment Expression Node
struct AssignmentExpr : public Expression
{
	std::unique_ptr<Expression> target;
	std::unique_ptr<Expression> value;

	AssignmentExpr(std::unique_ptr<Expression> t, std::unique_ptr<Expression> v)
	    : target(std::move(t)), value(std::move(v))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "AssignmentExpr:\n";
		std::cout << std::string(indent + 2, ' ') << "Target:\n";
		target->print(indent + 4);
		std::cout << std::string(indent + 2, ' ') << "Value:\n";
		value->print(indent + 4);
	}
};

/// @brief Variable Declaration Node
struct VarDecl : public Statement
{
	std::string                 name;
	std::unique_ptr<Expression> initializer;
	VarDecl(std::string n, std::unique_ptr<Expression> init) : name(n), initializer(std::move(init))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "VarDecl: " << name << "\n";
		if (initializer)
			initializer->print(indent + 2);
	}
};

/// @brief Expression Statement Node
struct ExpressionStmt : public Statement
{
	std::unique_ptr<Expression> expression;
	ExpressionStmt(std::unique_ptr<Expression> expr) : expression(std::move(expr))
	{
	}
	void print(int indent = 0) const override
	{
		expression->print(indent);
	}
};

/// @brief Print Statement Node
struct PrintStmt : public Statement
{
	std::unique_ptr<Expression> expression;
	PrintStmt(std::unique_ptr<Expression> expr) : expression(std::move(expr))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "PrintStmt:\n";
		expression->print(indent + 2);
	}
};

/// @brief Import Statement Node
struct ImportStmt : public Statement
{
	std::string modulePath;
	ImportStmt(std::string path) : modulePath(path)
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ImportStmt: " << modulePath << "\n";
	}
};

/// @brief Export Statement Node
struct ExportStmt : public Statement
{
	std::unique_ptr<Statement> declaration;
	ExportStmt(std::unique_ptr<Statement> decl) : declaration(std::move(decl))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ExportStmt:\n";
		declaration->print(indent + 2);
	}
};

/// @brief Block Statement Node
struct BlockStmt : public Statement
{
	std::vector<std::unique_ptr<Statement>> statements;
	BlockStmt(std::vector<std::unique_ptr<Statement>> stmts) : statements(std::move(stmts))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "BlockStmt:\n";
		for (const auto &stmt : statements)
		{
			stmt->print(indent + 2);
		}
	}
};

/// @brief Return Statement Node
struct ReturnStmt : public Statement
{
	std::unique_ptr<Expression> value;
	ReturnStmt(std::unique_ptr<Expression> val) : value(std::move(val))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ReturnStmt:\n";
		if (value)
			value->print(indent + 2);
	}
};

/// @brief Break Statement Node
struct BreakStmt : public Statement
{
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "BreakStmt\n";
	}
};

/// @brief Continue Statement Node
struct ContinueStmt : public Statement
{
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ContinueStmt\n";
	}
};

/// @brief If Statement Node
struct IfStmt : public Statement
{
	std::unique_ptr<Expression> condition;
	std::unique_ptr<Statement>  thenBranch;
	std::unique_ptr<Statement>  elseBranch;

	IfStmt(std::unique_ptr<Expression> cond, std::unique_ptr<Statement> thenB, std::unique_ptr<Statement> elseB)
	    : condition(std::move(cond)), thenBranch(std::move(thenB)), elseBranch(std::move(elseB))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "IfStmt:\n";
		condition->print(indent + 2);
		thenBranch->print(indent + 2);
		if (elseBranch)
		{
			std::cout << std::string(indent, ' ') << "Else:\n";
			elseBranch->print(indent + 2);
		}
	}
};

/// @brief While Statement Node
struct WhileStmt : public Statement
{
	std::unique_ptr<Expression> condition;
	std::unique_ptr<Statement>  body;

	WhileStmt(std::unique_ptr<Expression> cond, std::unique_ptr<Statement> b)
	    : condition(std::move(cond)), body(std::move(b))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "WhileStmt:\n";
		condition->print(indent + 2);
		body->print(indent + 2);
	}
};

/// @brief For Statement Node
struct ForStmt : public Statement
{
	std::unique_ptr<Statement>  initializer;
	std::unique_ptr<Expression> condition;
	std::unique_ptr<Expression> increment;
	std::unique_ptr<Statement>  body;

	ForStmt(std::unique_ptr<Statement> init, std::unique_ptr<Expression> cond, std::unique_ptr<Expression> incr,
	        std::unique_ptr<Statement> b)
	    : initializer(std::move(init)), condition(std::move(cond)), increment(std::move(incr)), body(std::move(b))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "ForStmt:\n";
		if (initializer)
			initializer->print(indent + 2);
		if (condition)
			condition->print(indent + 2);
		if (increment)
			increment->print(indent + 2);
		body->print(indent + 2);
	}
};

/// @brief Unsafe Block Statement Node
struct UnsafeBlockStmt : public Statement
{
	std::unique_ptr<BlockStmt> block;
	UnsafeBlockStmt(std::unique_ptr<BlockStmt> b) : block(std::move(b))
	{
	}
	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "UnsafeBlockStmt:\n";
		block->print(indent + 2);
	}
};

/// @brief Function Declaration Node
struct FunctionDecl : public Statement
{
	std::string name;
	struct Param
	{
		std::string               name;
		std::unique_ptr<TypeNode> type;
	};
	std::vector<Param>         params;
	std::unique_ptr<TypeNode>  returnType;
	std::unique_ptr<BlockStmt> body;

	FunctionDecl(std::string n, std::vector<Param> p, std::unique_ptr<TypeNode> rt, std::unique_ptr<BlockStmt> b)
	    : name(n), params(std::move(p)), returnType(std::move(rt)), body(std::move(b))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "FunctionDecl: " << name << "\n";
		for (const auto &param : params)
		{
			std::cout << std::string(indent + 2, ' ') << "Param: " << param.name << " Type: ";
			param.type->print(0);
		}
		std::cout << std::string(indent + 2, ' ') << "Return Type: ";
		if (returnType)
			returnType->print(0);
		else
			std::cout << "void\n";
		if (body)
			body->print(indent + 2);
	}
};

/// @brief Struct Field Node
struct StructField
{
	std::string               name;
	std::unique_ptr<TypeNode> type;

	StructField(std::string n, std::unique_ptr<TypeNode> t) : name(std::move(n)), type(std::move(t))
	{
	}
};

/// @brief Struct Declaration Node
struct StructDecl : public Statement
{
	std::string              name;
	std::vector<StructField> fields;

	StructDecl(std::string n, std::vector<StructField> f) : name(std::move(n)), fields(std::move(f))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "StructDecl: " << name << "\n";
		for (const auto &field : fields)
		{
			std::cout << std::string(indent + 2, ' ') << field.name << ": ";
			field.type->print(0);
		}
	}
};

/// @brief Struct Instance Expression Node
struct StructInstanceExpr : public Expression
{
	std::string                                                      structName;
	std::vector<std::pair<std::string, std::unique_ptr<Expression>>> fieldValues;

	StructInstanceExpr(std::string name, std::vector<std::pair<std::string, std::unique_ptr<Expression>>> fields)
	    : structName(std::move(name)), fieldValues(std::move(fields))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "StructInstance: " << structName << "\n";
		for (const auto &field : fieldValues)
		{
			std::cout << std::string(indent + 2, ' ') << field.first << ":\n";
			field.second->print(indent + 4);
		}
	}
};

/// @brief Field Access Expression Node
struct FieldAccessExpr : public Expression
{
	std::unique_ptr<Expression> object;
	std::string                 fieldName;

	FieldAccessExpr(std::unique_ptr<Expression> obj, std::string field)
	    : object(std::move(obj)), fieldName(std::move(field))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "FieldAccess: ." << fieldName << "\n";
		object->print(indent + 2);
	}
};

/// @brief Case Clause Node
struct CaseClause
{
	std::unique_ptr<Expression>             value;
	std::vector<std::unique_ptr<Statement>> statements;

	CaseClause(std::unique_ptr<Expression> v, std::vector<std::unique_ptr<Statement>> stmts)
	    : value(std::move(v)), statements(std::move(stmts))
	{
	}
};

/// @brief Switch Statement Node
struct SwitchStmt : public Statement
{
	std::unique_ptr<Expression>             expr;
	std::vector<CaseClause>                 cases;
	std::vector<std::unique_ptr<Statement>> defaultStmts;

	SwitchStmt(std::unique_ptr<Expression> e, std::vector<CaseClause> c, std::vector<std::unique_ptr<Statement>> d)
	    : expr(std::move(e)), cases(std::move(c)), defaultStmts(std::move(d))
	{
	}

	void print(int indent = 0) const override
	{
		std::cout << std::string(indent, ' ') << "SwitchStmt:\n";
		expr->print(indent + 2);
		for (const auto &c : cases)
		{
			std::cout << std::string(indent + 2, ' ') << "case:\n";
			c.value->print(indent + 4);
			for (const auto &stmt : c.statements)
			{
				stmt->print(indent + 4);
			}
		}
		if (!defaultStmts.empty())
		{
			std::cout << std::string(indent + 2, ' ') << "default:\n";
			for (const auto &stmt : defaultStmts)
			{
				stmt->print(indent + 4);
			}
		}
	}
};
} // namespace AST
} // namespace Phasor

--- .\src\Bindings\win32\handle.hpp ---
#pragma once

#include <unordered_map>
#include <cstdint>
/// @brief Handle system for managed win32 resources
namespace HandleSystem
{
using HandleId = uint32_t;

inline HandleId &nextId()
{
	static HandleId id = 1;
	return id;
}

template <typename T> struct Table
{
	static std::unordered_map<HandleId, T> &idToHandle()
	{
		static std::unordered_map<HandleId, T> map;
		return map;
	}

	static std::unordered_map<T, HandleId> &handleToId()
	{
		static std::unordered_map<T, HandleId> map;
		return map;
	}
};

template <typename T> inline HandleId store(T handle)
{
	if (!handle)
		return 0;

	auto &h2i = Table<T>::handleToId();
	auto &i2h = Table<T>::idToHandle();

	auto it = h2i.find(handle);
	if (it != h2i.end())
		return it->second;

	HandleId id = nextId()++;
	h2i[handle] = id;
	i2h[id] = handle;
	return id;
}

template <typename T> inline T resolve(HandleId id)
{
	if (id == 0)
		return T{};

	auto &i2h = Table<T>::idToHandle();
	auto  it = i2h.find(id);
	if (it == i2h.end())
		return T{};

	return it->second;
}

template <typename T> inline void remove(HandleId id)
{
	auto &i2h = Table<T>::idToHandle();
	auto &h2i = Table<T>::handleToId();

	auto it = i2h.find(id);
	if (it == i2h.end())
		return;

	h2i.erase(it->second);
	i2h.erase(it);
}
} // namespace HandleSystem


--- .\src\CMakeLists.txt ---
add_subdirectory(Runtime)
add_subdirectory(Language)
add_subdirectory(Codegen)
add_subdirectory(Frontend)
add_subdirectory(Repl)
add_subdirectory(Compiler)
add_subdirectory(LSP)
add_subdirectory(Executable)

--- .\src\Codegen\Bytecode\BytecodeDeserializer.cpp ---
#include "BytecodeDeserializer.hpp"
#include <cstring>
#include <stdexcept>
#include <filesystem>
#include "metadata.h"

// Section IDs
const uint8_t SECTION_CONSTANTS = 0x01;    //< Constants Section
const uint8_t SECTION_VARIABLES = 0x02;    //< Variables Section
const uint8_t SECTION_INSTRUCTIONS = 0x03; //< Instructions Section
const uint8_t SECTION_FUNCTIONS = 0x04;    //< Functions Section

static uint32_t crc32_table[256]; //< CRC32 lookup table
static bool     crc32_table_initialized = false;

/// @brief Deserialize CRC32 Table
void init_crc32_table_deserializer()
{
	for (uint32_t i = 0; i < 256; i++)
	{
		uint32_t crc = i;
		for (int j = 0; j < 8; j++)
		{
			if (crc & 1)
			{
				crc = (crc >> 1) ^ 0xEDB88320;
			}
			else
			{
				crc >>= 1;
			}
		}
		crc32_table[i] = crc;
	}
	crc32_table_initialized = true;
}

namespace Phasor
{

uint32_t BytecodeDeserializer::calculateCRC32(const uint8_t *data, size_t size)
{
	if (!crc32_table_initialized)
	{
		init_crc32_table_deserializer();
	}

	uint32_t crc = 0xFFFFFFFF;
	for (size_t i = 0; i < size; i++)
	{
		crc = (crc >> 8) ^ crc32_table[(crc ^ data[i]) & 0xFF];
	}
	return crc ^ 0xFFFFFFFF;
}

uint8_t BytecodeDeserializer::readUInt8()
{
	if (position >= dataSize)
	{
		throw std::runtime_error("Unexpected end of bytecode data");
	}
	return _data[position++];
}

uint16_t BytecodeDeserializer::readUInt16()
{
	uint16_t value = 0;
	value |= static_cast<uint16_t>(readUInt8());
	value |= static_cast<uint16_t>(readUInt8()) << 8;
	return value;
}

uint32_t BytecodeDeserializer::readUInt32()
{
	uint32_t value = 0;
	value |= static_cast<uint32_t>(readUInt8());
	value |= static_cast<uint32_t>(readUInt8()) << 8;
	value |= static_cast<uint32_t>(readUInt8()) << 16;
	value |= static_cast<uint32_t>(readUInt8()) << 24;
	return value;
}

int32_t BytecodeDeserializer::readInt32()
{
	return static_cast<int32_t>(readUInt32());
}

int64_t BytecodeDeserializer::readInt64()
{
	int64_t value = 0;
	for (int i = 0; i < 8; i++)
	{
		value |= static_cast<int64_t>(readUInt8()) << (i * 8);
	}
	return value;
}

double BytecodeDeserializer::readDouble()
{
	uint64_t bits = 0;
	for (int i = 0; i < 8; i++)
	{
		bits |= static_cast<uint64_t>(readUInt8()) << (i * 8);
	}
	double value;
	std::memcpy(&value, &bits, sizeof(double));
	return value;
}

std::string BytecodeDeserializer::readString()
{
	uint16_t    length = readUInt16();
	std::string str;
	str.reserve(length);
	for (uint16_t i = 0; i < length; i++)
	{
		str.push_back(static_cast<char>(readUInt8()));
	}
	return str;
}

void BytecodeDeserializer::readHeader(uint32_t &checksum)
{
	uint32_t magic = readUInt32();
	if (magic != MAGIC_NUMBER)
	{
		throw std::runtime_error("Invalid bytecode file: incorrect magic number");
	}

	uint32_t version = readUInt32();
	if (version != VERSION)
	{
		throw std::runtime_error("Incompatible bytecode version");
	}

	uint32_t flags = readUInt32(); // Reserved for future use
	(void)flags;

	checksum = readUInt32();
}

void BytecodeDeserializer::readConstantPool(Bytecode &bytecode)
{
	uint8_t sectionId = readUInt8();
	if (sectionId != SECTION_CONSTANTS)
	{
		throw std::runtime_error("Expected constant pool section");
	}

	uint32_t count = readUInt32();
	bytecode.constants.reserve(count);

	for (uint32_t i = 0; i < count; i++)
	{
		uint8_t typeTag = readUInt8();

		switch (typeTag)
		{
		case 0: // Null
			bytecode.constants.push_back(Value());
			break;
		case 1: // Bool
		{
			uint8_t boolValue = readUInt8();
			bytecode.constants.push_back(Value(boolValue != 0));
			break;
		}
		case 2: // Int
		{
			int64_t intValue = readInt64();
			bytecode.constants.push_back(Value(intValue));
			break;
		}
		case 3: // Float
		{
			double floatValue = readDouble();
			bytecode.constants.push_back(Value(floatValue));
			break;
		}
		case 4: // String
		{
			std::string strValue = readString();
			bytecode.constants.push_back(Value(strValue));
			break;
		}
		default:
			throw std::runtime_error("Unknown value type in constant pool");
		}
	}
}

void BytecodeDeserializer::readVariableMapping(Bytecode &bytecode)
{
	uint8_t sectionId = readUInt8();
	if (sectionId != SECTION_VARIABLES)
	{
		throw std::runtime_error("Expected variable mapping section");
	}

	uint32_t count = readUInt32();
	bytecode.nextVarIndex = readInt32();

	for (uint32_t i = 0; i < count; i++)
	{
		std::string name = readString();
		int32_t     index = readInt32();
		bytecode.variables[name] = index;
	}
}

void BytecodeDeserializer::readInstructions(Bytecode &bytecode)
{
	uint8_t sectionId = readUInt8();
	if (sectionId != SECTION_INSTRUCTIONS)
	{
		throw std::runtime_error("Expected instructions section");
	}

	uint32_t count = readUInt32();
	bytecode.instructions.reserve(count);

	for (uint32_t i = 0; i < count; i++)
	{
		uint8_t opcode = readUInt8();
		int32_t op1 = readInt32();
		int32_t op2 = readInt32();
		int32_t op3 = readInt32();
		int32_t op4 = readInt32();
		int32_t op5 = readInt32();
		bytecode.instructions.push_back(Instruction(static_cast<OpCode>(opcode), op1, op2, op3, op4, op5));
	}
}

void BytecodeDeserializer::readFunctionEntries(Bytecode &bytecode)
{
	uint8_t sectionId = readUInt8();
	if (sectionId != SECTION_FUNCTIONS)
	{
		throw std::runtime_error("Expected function entries section");
	}

	uint32_t count = readUInt32();

	for (uint32_t i = 0; i < count; i++)
	{
		std::string name = readString();
		int32_t     address = readInt32();
		bytecode.functionEntries[name] = address;
	}
}

Bytecode BytecodeDeserializer::deserialize(const std::vector<uint8_t> &buffer)
{
	_data = buffer.data();
	dataSize = buffer.size();
	position = 0;

	Bytecode bytecode;

	// Read header
	uint32_t expectedChecksum;
	readHeader(expectedChecksum);

	// Calculate checksum of data section
	size_t   dataStart = position;
	uint32_t actualChecksum = calculateCRC32(_data + dataStart, dataSize - dataStart);

	if (actualChecksum != expectedChecksum)
	{
		throw std::runtime_error("Bytecode file corrupted: checksum mismatch");
	}

	// Read sections
	readConstantPool(bytecode);
	readVariableMapping(bytecode);
	readFunctionEntries(bytecode);
	readInstructions(bytecode);

	return bytecode;
}

Bytecode BytecodeDeserializer::loadFromFile(const std::filesystem::path &filename)
{
	std::ifstream file(filename, std::ios::binary | std::ios::ate);
	if (!file.is_open())
	{
		throw std::runtime_error("Failed to open bytecode file: " + filename.string());
	}

	std::streamsize size = file.tellg();
	file.seekg(0, std::ios::beg);

	std::vector<uint8_t> buffer(size);
	if (!file.read(reinterpret_cast<char *>(buffer.data()), size))
	{
		throw std::runtime_error("Failed to read bytecode file: " + filename.string());
	}

	file.close();

	return deserialize(buffer);
}
} // namespace Phasor

--- .\src\Codegen\Bytecode\BytecodeDeserializer.hpp ---
#pragma once
#include "../CodeGen.hpp"
#include <cstdint>
#include <fstream>
#include <string>
#include <vector>
#include <filesystem>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 *  @class BytecodeDeserializer
 *  @brief Bytecode binary format deserializer
 */
class BytecodeDeserializer
{
  public:
	/// @brief Deserialize bytecode from binary buffer
	Bytecode deserialize(const std::vector<uint8_t> &data);

	/// @brief Load bytecode from .phsb file
	Bytecode loadFromFile(const std::filesystem::path &filename);

  private:
	const uint8_t *_data;
	size_t         position;
	size_t         dataSize;

	uint8_t     readUInt8();  ///< Helper method to read UInt8
	uint16_t    readUInt16(); ///< Helper method to read UInt16
	uint32_t    readUInt32(); ///< Helper method to read UInt32
	int32_t     readInt32();  ///< Helper method to read Int32
	int64_t     readInt64();  //< Helper method to read Int64
	double      readDouble(); //< Helper method to read Double
	std::string readString(); //< Helper method to read String

	void readHeader(uint32_t &checksum);          ///< Helper method to read Header
	void readConstantPool(Bytecode &bytecode);    ///< Helper method to read Constants Table
	void readVariableMapping(Bytecode &bytecode); ///< Helper method to read Variable Table
	void readInstructions(Bytecode &bytecode);    ///< Helper method to read Instuctions Table
	void readFunctionEntries(Bytecode &bytecode); ///< Helper method to read Function Entries

	/// @brief Calculate CRC32 checksum
	uint32_t calculateCRC32(const uint8_t *data, size_t size);
};
} // namespace Phasor

--- .\src\Codegen\Bytecode\BytecodeSerializer.cpp ---
#include "BytecodeSerializer.hpp"
#include <cstring>
#include <stdexcept>
#include <filesystem>
#include <fstream>
#include "metadata.h"

#if defined(_MSC_VER)
#define COMPILE_MESSAGE(msg) __pragma(message(msg))
#elif defined(__GNUC__) || defined(__clang__)
#define DO_PRAGMA(x) _Pragma(#x)
#define COMPILE_MESSAGE(msg) DO_PRAGMA(message msg)
#else
#define COMPILE_MESSAGE(msg)
#endif
#define STR2(x) #x
#define STR(x) STR2(x)

// Section IDs
const uint8_t SECTION_CONSTANTS = 0x01;    //< Constants Section
const uint8_t SECTION_VARIABLES = 0x02;    //< Variables Section
const uint8_t SECTION_INSTRUCTIONS = 0x03; //< Instructions Section
const uint8_t SECTION_FUNCTIONS = 0x04;    //< Functions Section

static uint32_t crc32_table[256]; //< CRC32 lookup table
static bool     crc32_table_initialized = false;

/// @brief Init CRC32 Table
void init_crc32_table()
{
	for (uint32_t i = 0; i < 256; i++)
	{
		uint32_t crc = i;
		for (int j = 0; j < 8; j++)
		{
			if (crc & 1)
			{
				crc = (crc >> 1) ^ 0xEDB88320;
			}
			else
			{
				crc >>= 1;
			}
		}
		crc32_table[i] = crc;
	}
	crc32_table_initialized = true;
}

namespace Phasor
{

uint32_t BytecodeSerializer::calculateCRC32(const std::vector<uint8_t> &data)
{
	if (!crc32_table_initialized)
	{
		init_crc32_table();
	}

	uint32_t crc = 0xFFFFFFFF;
	for (uint8_t byte : data)
	{
		crc = (crc >> 8) ^ crc32_table[(crc ^ byte) & 0xFF];
	}
	return crc ^ 0xFFFFFFFF;
}

void BytecodeSerializer::writeUInt8(uint8_t value)
{
	buffer.push_back(value);
}

void BytecodeSerializer::writeUInt16(uint16_t value)
{
	buffer.push_back(static_cast<uint8_t>(value & 0xFF));
	buffer.push_back(static_cast<uint8_t>((value >> 8) & 0xFF));
}

void BytecodeSerializer::writeUInt32(uint32_t value)
{
	buffer.push_back(static_cast<uint8_t>(value & 0xFF));
	buffer.push_back(static_cast<uint8_t>((value >> 8) & 0xFF));
	buffer.push_back(static_cast<uint8_t>((value >> 16) & 0xFF));
	buffer.push_back(static_cast<uint8_t>((value >> 24) & 0xFF));
}

void BytecodeSerializer::writeInt32(int32_t value)
{
	writeUInt32(static_cast<uint32_t>(value));
}

void BytecodeSerializer::writeInt64(int64_t value)
{
	for (int i = 0; i < 8; i++)
	{
		buffer.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFF));
	}
}

void BytecodeSerializer::writeDouble(double value)
{
	uint64_t bits;
	std::memcpy(&bits, &value, sizeof(double));
	for (int i = 0; i < 8; i++)
	{
		buffer.push_back(static_cast<uint8_t>((bits >> (i * 8)) & 0xFF));
	}
}

void BytecodeSerializer::writeString(const std::string &str)
{
	writeUInt16(static_cast<uint16_t>(str.length()));
	for (char c : str)
	{
		buffer.push_back(static_cast<uint8_t>(c));
	}
}

void BytecodeSerializer::writeHeader(uint32_t dataChecksum)
{
	writeUInt32(MAGIC_NUMBER);
	writeUInt32(VERSION);
	writeUInt32(0); // Flags (reserved)
	writeUInt32(dataChecksum);
}

void BytecodeSerializer::writeConstantPool(const std::vector<Value> &constants)
{
	writeUInt8(SECTION_CONSTANTS);
	writeUInt32(static_cast<uint32_t>(constants.size()));

	for (const auto &constant : constants)
	{
		ValueType type = constant.getType();

		// Write type tag
		switch (type)
		{
		case ValueType::Null:
			writeUInt8(0);
			break;
		case ValueType::Bool:
			writeUInt8(1);
			writeUInt8(constant.asBool() ? 1 : 0);
			break;
		case ValueType::Int:
			writeUInt8(2);
			writeInt64(constant.asInt());
			break;
		case ValueType::Float:
			writeUInt8(3);
			writeDouble(constant.asFloat());
			break;
		case ValueType::String:
			writeUInt8(4);
			writeString(constant.asString());
			break;
		case ValueType::Struct:
			COMPILE_MESSAGE("Warning: PHS_01 Structs have not been implemented! Line " STR(__LINE__))
			throw std::runtime_error("Structs have not been implemented!");
			break;
		case ValueType::Array:
			COMPILE_MESSAGE("Warning: PHS_02 Arrays have not been implemented! Line " STR(__LINE__))
			throw std::runtime_error("Arrays have not been implemented!");
			break;
		}
	}
}

void BytecodeSerializer::writeVariableMapping(const std::map<std::string, int> &variables, int nextVarIndex)
{
	writeUInt8(SECTION_VARIABLES);
	writeUInt32(static_cast<uint32_t>(variables.size()));
	writeInt32(nextVarIndex);

	for (const auto &[name, index] : variables)
	{
		writeString(name);
		writeInt32(index);
	}
}

void BytecodeSerializer::writeInstructions(const std::vector<Instruction> &instructions)
{
	writeUInt8(SECTION_INSTRUCTIONS);
	writeUInt32(static_cast<uint32_t>(instructions.size()));

	for (const auto &instr : instructions)
	{
		writeUInt8(static_cast<uint8_t>(instr.op));
		writeInt32(instr.operand1);
		writeInt32(instr.operand2);
		writeInt32(instr.operand3);
		writeInt32(instr.operand4);
		writeInt32(instr.operand5);
	}
}

void BytecodeSerializer::writeFunctionEntries(const std::map<std::string, int> &functionEntries)
{
	writeUInt8(SECTION_FUNCTIONS);
	writeUInt32(static_cast<uint32_t>(functionEntries.size()));

	for (const auto &[name, address] : functionEntries)
	{
		writeString(name);
		writeInt32(address);
	}
}

std::vector<uint8_t> BytecodeSerializer::serialize(const Bytecode &bytecode)
{
	buffer.clear();

	for (int i = 0; i < 16; i++)
	{
		buffer.push_back(0);
	}

	// Write all sections
	size_t dataStartPos = buffer.size();
	writeConstantPool(bytecode.constants);
	writeVariableMapping(bytecode.variables, bytecode.nextVarIndex);
	writeFunctionEntries(bytecode.functionEntries);
	writeInstructions(bytecode.instructions);

	// Calculate checksum of data (everything after header)
	std::vector<uint8_t> dataSection(buffer.begin() + dataStartPos, buffer.end());
	uint32_t             checksum = calculateCRC32(dataSection);

	// Write header at the beginning
	std::vector<uint8_t> tempBuffer = buffer;
	buffer.clear();
	writeHeader(checksum);

	// Append the data sections
	buffer.insert(buffer.end(), tempBuffer.begin() + 16, tempBuffer.end());

	return buffer;
}

bool BytecodeSerializer::saveToFile(const Bytecode &bytecode, const std::filesystem::path &filename)
{
	try
	{
		std::vector<uint8_t> data = serialize(bytecode);

		std::ofstream file(filename, std::ios::binary);
		if (!file.is_open())
		{
			return false;
		}

		file.write(reinterpret_cast<const char *>(data.data()), data.size());
		file.close();

		return true;
	}
	catch (const std::exception &)
	{
		return false;
	}
}
} // namespace Phasor


--- .\src\Codegen\Bytecode\BytecodeSerializer.hpp ---
#pragma once
#include "../CodeGen.hpp"
#include <cstdint>
#include <fstream>
#include <string>
#include <vector>
#include <filesystem>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class BytecodeSerializer
 * @brief Bytecode binary format serializer
 */
class BytecodeSerializer
{
  public:
	/// @brief Serialize bytecode to binary buffer
	std::vector<uint8_t> serialize(const Bytecode &bytecode);

	/// @brief Save bytecode to .phsb file
	bool saveToFile(const Bytecode &bytecode, const std::filesystem::path &filename);

  private:
	std::vector<uint8_t> buffer;

	void writeUInt8(uint8_t value);           ///< Helper method to write UInt8
	void writeUInt16(uint16_t value);         ///< Helper method to write UInt16
	void writeUInt32(uint32_t value);         ///< Helper method to write UInt32
	void writeInt32(int32_t value);           ///< Helper method to write Int32
	void writeInt64(int64_t value);           ///< Helper method to write Int64
	void writeDouble(double value);           ///< Helper method to write Double
	void writeString(const std::string &str); ///< Helper method to write String

	/// @brief Section writers
	void writeHeader(uint32_t dataChecksum);                     ///< Helper method to write header
	void writeConstantPool(const std::vector<Value> &constants); ///< Helper method to write Constants Table
	void writeVariableMapping(const std::map<std::string, int> &variables,
	                          int nextVarIndex);                          ///< Helper method to write Variable Map Table
	void writeInstructions(const std::vector<Instruction> &instructions); ///< Helper method to write Instruction Table
	void writeFunctionEntries(
	    const std::map<std::string, int> &functionEntries); ///< Helper method to write Function Table

	/// @brief Calculate CRC32 checksum
	uint32_t calculateCRC32(const std::vector<uint8_t> &data);
};
} // namespace Phasor

--- .\src\Codegen\Bytecode\metadata.h ---
#pragma once
#include <cstdint>

static inline constexpr uint32_t ascii_to_u32_le(const char s[4])
{
	return ((uint32_t)(uint8_t)s[0]) | ((uint32_t)(uint8_t)s[1] << 8) | ((uint32_t)(uint8_t)s[2] << 16) |
	       ((uint32_t)(uint8_t)s[3] << 24);
}

/**
 * @brief Magic number (little endian)
 *
 * 'PHSB'
 */
#define MAGIC_NUMBER ascii_to_u32_le("PHSB")

/**
 * @brief Version number
 *
 * '3.0.0.0'
 */
const uint32_t VERSION = 0x03000000;

--- .\src\Codegen\CMakeLists.txt ---
set(CODEGEN_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/CodeGen.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Bytecode/BytecodeSerializer.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Bytecode/BytecodeDeserializer.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/IR/PhasorIR.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Cpp/CppCodeGenerator.cpp
)

set(CODEGEN_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/CodeGen.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Bytecode/BytecodeSerializer.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Bytecode/BytecodeDeserializer.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/IR/PhasorIR.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Cpp/CppCodeGenerator.hpp
    ${CMAKE_SOURCE_DIR}/src/AST/AST.hpp
)

add_library(PhasorCodegen STATIC ${CODEGEN_SOURCES} ${CODEGEN_HEADERS})

--- .\src\Codegen\CodeGen.cpp ---
#include "CodeGen.hpp"
#include <iostream>

namespace Phasor
{

Bytecode CodeGenerator::generate(const AST::Program &program, const std::map<std::string, int> &existingVars,
                                 int nextVarIdx, bool replMode)
{
	bytecode = Bytecode(); // Reset bytecode
	bytecode.variables = existingVars;
	bytecode.nextVarIndex = nextVarIdx;
	isRepl = replMode;

	for (const auto &stmt : program.statements)
	{
		generateStatement(stmt.get());
	}
	bytecode.emit(OpCode::HALT);
	return bytecode;
}

bool CodeGenerator::isLiteralExpression(const AST::Expression *expr, Value &outValue)
{
	if (auto numExpr = dynamic_cast<const AST::NumberExpr *>(expr))
	{
		try
		{
			if (numExpr->value.find('.') != std::string::npos)
			{
				outValue = Value(std::stod(numExpr->value));
			}
			else
			{
				outValue = Value(static_cast<int64_t>(std::stoll(numExpr->value)));
			}
			return true;
		}
		catch (...)
		{
			return false;
		}
	}
	if (auto strExpr = dynamic_cast<const AST::StringExpr *>(expr))
	{
		outValue = Value(strExpr->value);
		return true;
	}
	if (auto boolExpr = dynamic_cast<const AST::BooleanExpr *>(expr))
	{
		outValue = Value(boolExpr->value);
		return true;
	}
	if (dynamic_cast<const AST::NullExpr *>(expr))
	{
		outValue = Value();
		return true;
	}
	return false;
}

ValueType CodeGenerator::inferExpressionType(const AST::Expression *expr, bool &known)
{
	// If literal, we know the type immediately
	Value lit;
	if (isLiteralExpression(expr, lit))
	{
		known = true;
		return lit.getType();
	}

	// If identifier and we've inferred its type previously, return that
	if (auto ident = dynamic_cast<const AST::IdentifierExpr *>(expr))
	{
		auto it = inferredTypes.find(ident->name);
		if (it != inferredTypes.end())
		{
			known = true;
			return it->second;
		}
	}

	// Unknown
	known = false;
	return ValueType::Float; // default when unknown (not used unless known==true)
}

void CodeGenerator::generateStatement(const AST::Statement *stmt)
{
	if (auto varDecl = dynamic_cast<const AST::VarDecl *>(stmt))
	{
		generateVarDecl(varDecl);
	}
	else if (auto exprStmt = dynamic_cast<const AST::ExpressionStmt *>(stmt))
	{
		generateExpressionStmt(exprStmt);
	}
	else if (auto printStmt = dynamic_cast<const AST::PrintStmt *>(stmt))
	{
		generatePrintStmt(printStmt);
	}

	else if (auto importStmt = dynamic_cast<const AST::ImportStmt *>(stmt))
	{
		generateImportStmt(importStmt);
	}
	else if (auto exportStmt = dynamic_cast<const AST::ExportStmt *>(stmt))
	{
		generateExportStmt(exportStmt);
	}
	else if (auto blockStmt = dynamic_cast<const AST::BlockStmt *>(stmt))
	{
		generateBlockStmt(blockStmt);
	}
	else if (auto ifStmt = dynamic_cast<const AST::IfStmt *>(stmt))
	{
		generateIfStmt(ifStmt);
	}
	else if (auto whileStmt = dynamic_cast<const AST::WhileStmt *>(stmt))
	{
		generateWhileStmt(whileStmt);
	}
	else if (auto forStmt = dynamic_cast<const AST::ForStmt *>(stmt))
	{
		generateForStmt(forStmt);
	}
	else if (auto returnStmt = dynamic_cast<const AST::ReturnStmt *>(stmt))
	{
		generateReturnStmt(returnStmt);
	}
	else if (auto unsafeStmt = dynamic_cast<const AST::UnsafeBlockStmt *>(stmt))
	{
		generateUnsafeBlockStmt(unsafeStmt);
	}
	else if (auto funcDecl = dynamic_cast<const AST::FunctionDecl *>(stmt))
	{
		generateFunctionDecl(funcDecl);
	}
	else if (auto structDecl = dynamic_cast<const AST::StructDecl *>(stmt))
	{
		generateStructDecl(structDecl);
	}
	else if (dynamic_cast<const AST::BreakStmt *>(stmt))
	{
		generateBreakStmt();
	}
	else if (dynamic_cast<const AST::ContinueStmt *>(stmt))
	{
		generateContinueStmt();
	}
	else if (auto switchStmt = dynamic_cast<const AST::SwitchStmt *>(stmt))
	{
		generateSwitchStmt(switchStmt);
	}
	else
	{
		throw std::runtime_error("Unknown statement type in code generation");
	}
}

void CodeGenerator::generateExpression(const AST::Expression *expr)
{
	if (auto numExpr = dynamic_cast<const AST::NumberExpr *>(expr))
	{
		generateNumberExpr(numExpr);
	}
	else if (auto strExpr = dynamic_cast<const AST::StringExpr *>(expr))
	{
		generateStringExpr(strExpr);
	}
	else if (auto identExpr = dynamic_cast<const AST::IdentifierExpr *>(expr))
	{
		generateIdentifierExpr(identExpr);
	}
	else if (auto unaryExpr = dynamic_cast<const AST::UnaryExpr *>(expr))
	{
		generateUnaryExpr(unaryExpr);
	}
	else if (auto callExpr = dynamic_cast<const AST::CallExpr *>(expr))
	{
		generateCallExpr(callExpr);
	}
	else if (auto binExpr = dynamic_cast<const AST::BinaryExpr *>(expr))
	{
		generateBinaryExpr(binExpr);
	}
	else if (auto boolExpr = dynamic_cast<const AST::BooleanExpr *>(expr))
	{
		generateBooleanExpr(boolExpr);
	}
	else if (auto nullExpr = dynamic_cast<const AST::NullExpr *>(expr))
	{
		generateNullExpr(nullExpr);
	}
	else if (auto assignExpr = dynamic_cast<const AST::AssignmentExpr *>(expr))
	{
		generateAssignmentExpr(assignExpr);
	}
	else if (auto structExpr = dynamic_cast<const AST::StructInstanceExpr *>(expr))
	{
		generateStructInstanceExpr(structExpr);
	}
	else if (auto fieldAccessExpr = dynamic_cast<const AST::FieldAccessExpr *>(expr))
	{
		generateFieldAccessExpr(fieldAccessExpr);
	}
	else if (auto postfixExpr = dynamic_cast<const AST::PostfixExpr *>(expr))
	{
		generatePostfixExpr(postfixExpr);
	}
	else
	{
		throw std::runtime_error("Unknown expression type in code generation");
	}
}

void CodeGenerator::generateVarDecl(const AST::VarDecl *varDecl)
{
	if (varDecl->initializer)
	{
		// Generate initializer code
		generateExpression(varDecl->initializer.get());
		// Try to infer type from initializer
		Value initVal;
		if (isLiteralExpression(varDecl->initializer.get(), initVal))
		{
			inferredTypes[varDecl->name] = initVal.getType();
		}
		else if (auto ident = dynamic_cast<const AST::IdentifierExpr *>(varDecl->initializer.get()))
		{
			// propagate known type from another variable
			auto it = inferredTypes.find(ident->name);
			if (it != inferredTypes.end())
			{
				inferredTypes[varDecl->name] = it->second;
			}
		}

		int varIndex = bytecode.getOrCreateVar(varDecl->name);
		bytecode.emit(OpCode::STORE_VAR, varIndex);
	}
	else
	{
		// Store null value for uninitialized variable
		int constIndex = bytecode.addConstant(Value());
		bytecode.emit(OpCode::PUSH_CONST, constIndex);
		int varIndex = bytecode.getOrCreateVar(varDecl->name);
		bytecode.emit(OpCode::STORE_VAR, varIndex);
	}
}

void CodeGenerator::generateExpressionStmt(const AST::ExpressionStmt *exprStmt)
{
	generateExpression(exprStmt->expression.get());
	if (isRepl)
	{
		bytecode.emit(OpCode::PRINT);
	}
	else
	{
		bytecode.emit(OpCode::POP); // Expression statements discard result
	}
}

void CodeGenerator::generatePrintStmt(const AST::PrintStmt *printStmt)
{
	generateExpression(printStmt->expression.get());
	bytecode.emit(OpCode::PRINT);
}

void CodeGenerator::generateImportStmt(const AST::ImportStmt *importStmt)
{
	int constIndex = bytecode.addConstant(Value(importStmt->modulePath));
	bytecode.emit(OpCode::IMPORT, constIndex);
}

void CodeGenerator::generateExportStmt(const AST::ExportStmt *exportStmt)
{
	// For now, export just executes the declaration in the current scope
	generateStatement(exportStmt->declaration.get());
}

void CodeGenerator::generateNumberExpr(const AST::NumberExpr *numExpr)
{
	// Try to parse as integer first, then as float
	try
	{
		// Check if it has a decimal point
		if (numExpr->value.find('.') != std::string::npos)
		{
			double d = std::stod(numExpr->value);
			int    constIndex = bytecode.addConstant(Value(d));
			bytecode.emit(OpCode::PUSH_CONST, constIndex);
		}
		else
		{
			int64_t i = std::stoll(numExpr->value);
			int     constIndex = bytecode.addConstant(Value(i));
			bytecode.emit(OpCode::PUSH_CONST, constIndex);
		}
	}
	catch (...)
	{
		throw std::runtime_error("Invalid number format: " + numExpr->value);
	}
}

void CodeGenerator::generateStringExpr(const AST::StringExpr *strExpr)
{
	int constIndex = bytecode.addConstant(Value(strExpr->value));
	bytecode.emit(OpCode::PUSH_CONST, constIndex);
}

void CodeGenerator::generateIdentifierExpr(const AST::IdentifierExpr *identExpr)
{
	int varIndex = bytecode.getOrCreateVar(identExpr->name);
	bytecode.emit(OpCode::LOAD_VAR, varIndex);
}

void CodeGenerator::generateUnaryExpr(const AST::UnaryExpr *unaryExpr)
{
	// Generate operand
	generateExpression(unaryExpr->operand.get());

	// Emit operation
	switch (unaryExpr->op)
	{
	case AST::UnaryOp::Negate:
		bytecode.emit(OpCode::NEGATE);
		break;
	case AST::UnaryOp::Not:
		bytecode.emit(OpCode::NOT);
		break;
	case AST::UnaryOp::AddressOf:
		// Not implemented
		//	bytecode.emit(OpCode::ADROF);
		[[fallthrough]]; // for now
	case AST::UnaryOp::Dereference:
		//	bytecode.emit(OpCode::DREF);
		break;
	}
}

void CodeGenerator::generateCallExpr(const AST::CallExpr *callExpr)
{
	// Optimizations
	// Optimizations
	if (callExpr->callee == "len" && callExpr->arguments.size() == 1)
	{
		if (auto strExpr = dynamic_cast<const AST::StringExpr *>(callExpr->arguments[0].get()))
		{
			// Constant fold len("literal")
			int64_t len = strExpr->value.length();
			int     constIndex = bytecode.addConstant(Value(len));
			bytecode.emit(OpCode::PUSH_CONST, constIndex);
			return;
		}
		// Emit specialized opcode for variable strings
		generateExpression(callExpr->arguments[0].get());
		bytecode.emit(OpCode::LEN);
		return;
	}

	if (callExpr->callee == "substr" && callExpr->arguments.size() == 3)
	{
		// Check for substr(s, i, 1) -> char_at(s, i)
		if (auto numExpr = dynamic_cast<const AST::NumberExpr *>(callExpr->arguments[2].get()))
		{
			if (numExpr->value == "1" || numExpr->value == "1.0")
			{
				// Redirect to char_at opcode
				generateExpression(callExpr->arguments[0].get());
				generateExpression(callExpr->arguments[1].get());
				bytecode.emit(OpCode::CHAR_AT);
				return;
			}
		}
	}

	if (callExpr->callee == "char_at" && callExpr->arguments.size() == 2)
	{
		generateExpression(callExpr->arguments[0].get());
		generateExpression(callExpr->arguments[1].get());
		bytecode.emit(OpCode::CHAR_AT);
		return;
	}

	if (callExpr->callee == "starts_with" && callExpr->arguments.size() == 2)
	{
		auto s = dynamic_cast<const AST::StringExpr *>(callExpr->arguments[0].get());
		auto p = dynamic_cast<const AST::StringExpr *>(callExpr->arguments[1].get());
		if (s && p)
		{
			bool result =
			    s->value.length() >= p->value.length() && s->value.compare(0, p->value.length(), p->value) == 0;
			bytecode.emit(result ? OpCode::TRUE_P : OpCode::FALSE_P);
			return;
		}
	}

	if (callExpr->callee == "ends_with" && callExpr->arguments.size() == 2)
	{
		auto s = dynamic_cast<const AST::StringExpr *>(callExpr->arguments[0].get());
		auto suffix = dynamic_cast<const AST::StringExpr *>(callExpr->arguments[1].get());
		if (s && suffix)
		{
			bool result = s->value.length() >= suffix->value.length() &&
			              s->value.compare(s->value.length() - suffix->value.length(), suffix->value.length(),
			                               suffix->value) == 0;
			bytecode.emit(result ? OpCode::TRUE_P : OpCode::FALSE_P);
			return;
		}
	}
	// Push arguments
	for (const auto &arg : callExpr->arguments)
	{
		generateExpression(arg.get());
	}

	// Push argument count
	int constIndex = bytecode.addConstant(Value(static_cast<int64_t>(callExpr->arguments.size())));
	bytecode.emit(OpCode::PUSH_CONST, constIndex);

	// Emit CALL_NATIVE or CALL
	// Check if it's a user function
	if (bytecode.functionEntries.count(callExpr->callee))
	{
		int nameIndex = bytecode.addConstant(Value(callExpr->callee));
		// The best fix of all time: check if the function exists and has the correct number of parameters
		auto itParam = bytecode.functionParamCounts.find(callExpr->callee);
		if (itParam != bytecode.functionParamCounts.end())
		{
			int expected = itParam->second;
			int got = static_cast<int>(callExpr->arguments.size());
			if (expected != got)
			{
				std::cerr << "ERROR: calling function '" << callExpr->callee << "' with " << got
						  << " arguments but it expects " << expected << "\n";
				std::exit(1);
			}
		}
		bytecode.emit(OpCode::CALL, nameIndex);
	}
	else
	{
		int nameIndex = bytecode.addConstant(Value(callExpr->callee));
		bytecode.emit(OpCode::CALL_NATIVE, nameIndex);
	}
}

void CodeGenerator::generateBinaryExpr(const AST::BinaryExpr *binExpr)
{
	Value leftVal;
	Value rightVal;
	if (isLiteralExpression(binExpr->left.get(), leftVal) && isLiteralExpression(binExpr->right.get(), rightVal))
	{
		try
		{
			Value result;
			switch (binExpr->op)
			{
			case AST::BinaryOp::Add:
				result = leftVal + rightVal;
				break;
			case AST::BinaryOp::Subtract:
				result = leftVal - rightVal;
				break;
			case AST::BinaryOp::Multiply:
				result = leftVal * rightVal;
				break;
			case AST::BinaryOp::Divide:
				result = leftVal / rightVal;
				break;
			case AST::BinaryOp::Modulo:
				result = leftVal % rightVal;
				break;
			case AST::BinaryOp::And:
				result = leftVal.logicalAnd(rightVal);
				break;
			case AST::BinaryOp::Or:
				result = leftVal.logicalOr(rightVal);
				break;
			case AST::BinaryOp::Equal:
				result = Value(leftVal == rightVal);
				break;
			case AST::BinaryOp::NotEqual:
				result = Value(leftVal != rightVal);
				break;
			case AST::BinaryOp::LessThan:
				result = Value(leftVal < rightVal);
				break;
			case AST::BinaryOp::GreaterThan:
				result = Value(leftVal > rightVal);
				break;
			case AST::BinaryOp::LessEqual:
				result = Value(leftVal <= rightVal);
				break;
			case AST::BinaryOp::GreaterEqual:
				result = Value(leftVal >= rightVal);
				break;
			}
			if (result.isBool())
			{
				if (result.asBool())
				{
					bytecode.emit(OpCode::TRUE_P);
				}
				else
				{
					bytecode.emit(OpCode::FALSE_P);
				}
			}
			else if (result.isNull())
			{
				bytecode.emit(OpCode::NULL_VAL);
			}
			else
			{
				int constIndex = bytecode.addConstant(result);
				bytecode.emit(OpCode::PUSH_CONST, constIndex);
			}
			return;
		}
		catch (...)
		{
		}
	}

	if (binExpr->op == AST::BinaryOp::And)
	{
		generateExpression(binExpr->left.get());
		int jumpToFalseIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP_IF_FALSE, 0);
		generateExpression(binExpr->right.get());
		int jumpToEndIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP, 0);
		bytecode.instructions[jumpToFalseIndex].operand1 = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::FALSE_P);
		bytecode.instructions[jumpToEndIndex].operand1 = static_cast<int>(bytecode.instructions.size());
		return;
	}
	if (binExpr->op == AST::BinaryOp::Or)
	{
		generateExpression(binExpr->left.get());
		int jumpToTrueIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP_IF_TRUE, 0);
		generateExpression(binExpr->right.get());
		int jumpToEndIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP, 0);
		bytecode.instructions[jumpToTrueIndex].operand1 = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::TRUE_P);
		bytecode.instructions[jumpToEndIndex].operand1 = static_cast<int>(bytecode.instructions.size());
		return;
	}

	uint8_t rLeft = allocateRegister();
	uint8_t rRight = allocateRegister();
	uint8_t rResult = allocateRegister();

	// Reuse literal detection done here to choose appropriate register opcodes.
	Value leftLiteral;
	bool  leftIsLiteral = isLiteralExpression(binExpr->left.get(), leftLiteral);
	if (leftIsLiteral)
	{
		int constIndex = bytecode.addConstant(leftLiteral);
		bytecode.emit(OpCode::LOAD_CONST_R, rLeft, constIndex);
	}
	else
	{
		generateExpression(binExpr->left.get());
		bytecode.emit(OpCode::POP_R, rLeft);
	}

	Value rightLiteral;
	bool  rightIsLiteral = isLiteralExpression(binExpr->right.get(), rightLiteral);
	if (rightIsLiteral)
	{
		int constIndex = bytecode.addConstant(rightLiteral);
		bytecode.emit(OpCode::LOAD_CONST_R, rRight, constIndex);
	}
	else
	{
		generateExpression(binExpr->right.get());
		bytecode.emit(OpCode::POP_R, rRight);
	}

	// Conservative integer decision:
	// treat operand as known-int if it's an integer literal or a variable previously inferred as Int.
	auto exprIsKnownInt = [&](const AST::Expression *e, bool isLiteral, const Value &lit) -> bool {
		if (isLiteral)
			return lit.isInt();
		// variable case
		if (auto ident = dynamic_cast<const AST::IdentifierExpr *>(e))
		{
			auto it = inferredTypes.find(ident->name);
			return it != inferredTypes.end() && it->second == ValueType::Int;
		}
		return false;
	};

	bool leftKnownInt = exprIsKnownInt(binExpr->left.get(), leftIsLiteral, leftLiteral);
	bool rightKnownInt = exprIsKnownInt(binExpr->right.get(), rightIsLiteral, rightLiteral);

	// Choose integer ops only when both operands are known ints.
	if (leftKnownInt && rightKnownInt)
	{
		switch (binExpr->op)
		{
		case AST::BinaryOp::Add:
			bytecode.emit(OpCode::IADD_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Subtract:
			bytecode.emit(OpCode::ISUB_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Multiply:
			bytecode.emit(OpCode::IMUL_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Divide:
			bytecode.emit(OpCode::IDIV_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Modulo:
			bytecode.emit(OpCode::IMOD_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::And:
			bytecode.emit(OpCode::IAND_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Or:
			bytecode.emit(OpCode::IOR_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Equal:
			bytecode.emit(OpCode::IEQ_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::NotEqual:
			bytecode.emit(OpCode::INE_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::LessThan:
			bytecode.emit(OpCode::ILT_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::GreaterThan:
			bytecode.emit(OpCode::IGT_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::LessEqual:
			bytecode.emit(OpCode::ILE_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::GreaterEqual:
			bytecode.emit(OpCode::IGE_R, rResult, rLeft, rRight);
			break;
		}
	}
	else
	{
		// Fallback to float ops when we don't know both operands are integers.
		switch (binExpr->op)
		{
		case AST::BinaryOp::Add:
			bytecode.emit(OpCode::FLADD_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Subtract:
			bytecode.emit(OpCode::FLSUB_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Multiply:
			bytecode.emit(OpCode::FLMUL_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Divide:
			bytecode.emit(OpCode::FLDIV_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Modulo:
			bytecode.emit(OpCode::FLMOD_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::And:
			bytecode.emit(OpCode::FLAND_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Or:
			bytecode.emit(OpCode::FLOR_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::Equal:
			bytecode.emit(OpCode::FLEQ_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::NotEqual:
			bytecode.emit(OpCode::FLNE_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::LessThan:
			bytecode.emit(OpCode::FLLT_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::GreaterThan:
			bytecode.emit(OpCode::FLGT_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::LessEqual:
			bytecode.emit(OpCode::FLLE_R, rResult, rLeft, rRight);
			break;
		case AST::BinaryOp::GreaterEqual:
			bytecode.emit(OpCode::FLGE_R, rResult, rLeft, rRight);
			break;
		}
	}

	freeRegister(rLeft);
	freeRegister(rRight);
	bytecode.emit(OpCode::PUSH_R, rResult);
	freeRegister(rResult);
}

void CodeGenerator::generateBlockStmt(const AST::BlockStmt *blockStmt)
{
	for (const auto &stmt : blockStmt->statements)
	{
		generateStatement(stmt.get());
	}
}

void CodeGenerator::generateIfStmt(const AST::IfStmt *ifStmt)
{
	generateExpression(ifStmt->condition.get());

	// Jump to else if false
	int jumpToElseIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP_IF_FALSE, 0);

	generateStatement(ifStmt->thenBranch.get());

	int jumpToEndIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP, 0);

	// Patch jump to else
	bytecode.instructions[jumpToElseIndex].operand1 = static_cast<int>(bytecode.instructions.size());

	if (ifStmt->elseBranch)
	{
		generateStatement(ifStmt->elseBranch.get());
	}

	// Patch jump to end
	bytecode.instructions[jumpToEndIndex].operand1 = static_cast<int>(bytecode.instructions.size());
}

void CodeGenerator::generateWhileStmt(const AST::WhileStmt *whileStmt)
{
	int loopStartIndex = static_cast<int>(bytecode.instructions.size());

	// Push loop context
	loopStartStack.push_back(loopStartIndex);
	breakJumpsStack.push_back(std::vector<int>());
	continueJumpsStack.push_back(std::vector<int>());

	generateExpression(whileStmt->condition.get());

	int jumpToEndIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP_IF_FALSE, 0);

	generateStatement(whileStmt->body.get());

	// Patch continue jumps to loop start
	for (int continueJump : continueJumpsStack.back())
	{
		bytecode.instructions[continueJump].operand1 = loopStartIndex;
	}

	bytecode.emit(OpCode::JUMP_BACK, loopStartIndex);

	// Patch jump to end and break jumps
	int endIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.instructions[jumpToEndIndex].operand1 = endIndex;
	for (int breakJump : breakJumpsStack.back())
	{
		bytecode.instructions[breakJump].operand1 = endIndex;
	}

	// Pop loop context
	loopStartStack.pop_back();
	breakJumpsStack.pop_back();
	continueJumpsStack.pop_back();
}

void CodeGenerator::generateForStmt(const AST::ForStmt *forStmt)
{
	// Generate initializer
	if (forStmt->initializer)
	{
		generateStatement(forStmt->initializer.get());
	}

	int loopStartIndex = static_cast<int>(bytecode.instructions.size());

	// Push loop context
	loopStartStack.push_back(loopStartIndex);
	breakJumpsStack.push_back(std::vector<int>());
	continueJumpsStack.push_back(std::vector<int>());

	// Generate condition (if present)
	int jumpToEndIndex = -1;
	if (forStmt->condition)
	{
		generateExpression(forStmt->condition.get());
		jumpToEndIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP_IF_FALSE, 0);
	}

	// Generate body
	generateStatement(forStmt->body.get());

	// Continue jumps to increment (or loop start if no increment)
	int incrementIndex = static_cast<int>(bytecode.instructions.size());
	for (int continueJump : continueJumpsStack.back())
	{
		bytecode.instructions[continueJump].operand1 = incrementIndex;
	}

	// Generate increment
	if (forStmt->increment)
	{
		generateExpression(forStmt->increment.get());
		bytecode.emit(OpCode::POP); // Discard increment result
	}

	// Jump back to condition check
	bytecode.emit(OpCode::JUMP_BACK, loopStartIndex);

	// Patch jump to end and break jumps
	int endIndex = static_cast<int>(bytecode.instructions.size());
	if (jumpToEndIndex != -1)
	{
		bytecode.instructions[jumpToEndIndex].operand1 = endIndex;
	}
	for (int breakJump : breakJumpsStack.back())
	{
		bytecode.instructions[breakJump].operand1 = endIndex;
	}

	// Pop loop context
	loopStartStack.pop_back();
	breakJumpsStack.pop_back();
	continueJumpsStack.pop_back();
}

void CodeGenerator::generateBreakStmt()
{
	if (breakJumpsStack.empty())
	{
		throw std::runtime_error("'break' statement outside of loop");
	}
	// Emit jump with placeholder, will be patched later
	int jumpIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP, 0);
	breakJumpsStack.back().push_back(jumpIndex);
}

void CodeGenerator::generateContinueStmt()
{
	if (continueJumpsStack.empty())
	{
		throw std::runtime_error("'continue' statement outside of loop");
	}
	// Emit jump with placeholder, will be patched later
	int jumpIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP, 0);
	continueJumpsStack.back().push_back(jumpIndex);
}

void CodeGenerator::generateReturnStmt(const AST::ReturnStmt *returnStmt)
{
	if (returnStmt->value)
	{
		generateExpression(returnStmt->value.get());
	}
	else
	{
		bytecode.emit(OpCode::NULL_VAL);
	}
	bytecode.emit(OpCode::RETURN);
}

void CodeGenerator::generateUnsafeBlockStmt(const AST::UnsafeBlockStmt *unsafeStmt)
{
	generateBlockStmt(unsafeStmt->block.get());
}

void CodeGenerator::generateFunctionDecl(const AST::FunctionDecl *funcDecl)
{
	// Jump over function body
	int jumpOverIndex = static_cast<int>(bytecode.instructions.size());
	bytecode.emit(OpCode::JUMP, 0);

	// Record entry point
	int entryPoint = static_cast<int>(bytecode.instructions.size());
	bytecode.functionEntries[funcDecl->name] = entryPoint;

	// Record parameter count
	bytecode.functionParamCounts[funcDecl->name] = static_cast<int>(funcDecl->params.size());

	// Pop argument count (it's on the stack when function is called)
	bytecode.emit(OpCode::POP);

	// Pop parameters in reverse order and store in variables
	for (auto it = funcDecl->params.rbegin(); it != funcDecl->params.rend(); ++it)
	{
		int varIndex = bytecode.getOrCreateVar(it->name);
		bytecode.emit(OpCode::STORE_VAR, varIndex);
	}

	// Generate body
	generateBlockStmt(funcDecl->body.get());

	// Ensure return
	bytecode.emit(OpCode::NULL_VAL);
	bytecode.emit(OpCode::RETURN);

	// Patch jump over
	bytecode.instructions[jumpOverIndex].operand1 = static_cast<int>(bytecode.instructions.size());
}

void CodeGenerator::generateBooleanExpr(const AST::BooleanExpr *boolExpr)
{
	if (boolExpr->value)
	{
		bytecode.emit(OpCode::TRUE_P);
	}
	else
	{
		bytecode.emit(OpCode::FALSE_P);
	}
}

void CodeGenerator::generateNullExpr(const AST::NullExpr *)
{
	bytecode.emit(OpCode::NULL_VAL);
}

void CodeGenerator::generateAssignmentExpr(const AST::AssignmentExpr *assignExpr)
{
	// Support assignments to variables and struct fields.
	if (auto identExpr = dynamic_cast<const AST::IdentifierExpr *>(assignExpr->target.get()))
	{
		// Variable assignment: a = value
		// 1. Generate value (pushes value to stack)
		generateExpression(assignExpr->value.get());

		// Try to infer and record type
		Value val;
		if (isLiteralExpression(assignExpr->value.get(), val))
		{
			inferredTypes[identExpr->name] = val.getType();
		}
		else if (auto identRhs = dynamic_cast<const AST::IdentifierExpr *>(assignExpr->value.get()))
		{
			auto it = inferredTypes.find(identRhs->name);
			if (it != inferredTypes.end())
				inferredTypes[identExpr->name] = it->second;
		}

		// 2. Store in variable (pops value)
		int varIndex = bytecode.getOrCreateVar(identExpr->name);
		bytecode.emit(OpCode::STORE_VAR, varIndex);

		// 3. Load it back (assignment is an expression that returns the value)
		bytecode.emit(OpCode::LOAD_VAR, varIndex);
	}
	else if (auto fieldExpr = dynamic_cast<const AST::FieldAccessExpr *>(assignExpr->target.get()))
	{
		// Generate object (pushes struct)
		generateExpression(fieldExpr->object.get());
		// Generate value (pushes value on top)
		generateExpression(assignExpr->value.get());

		// Use dynamic field access since we don't have type information
		int fieldNameIndex = bytecode.addConstant(Value(fieldExpr->fieldName));
		bytecode.emit(OpCode::SET_FIELD, fieldNameIndex);

		// Reload the assigned field value so the assignment expression evaluates to it
		generateExpression(fieldExpr->object.get());
		bytecode.emit(OpCode::GET_FIELD, fieldNameIndex);
	}
	else
	{
		throw std::runtime_error("Invalid assignment target. Only variables and struct fields are supported.");
	}
}

void CodeGenerator::generateStructInstanceExpr(const AST::StructInstanceExpr *expr)
{
	// Prefer static struct instantiation when we have metadata in the struct section.
	auto it = bytecode.structEntries.find(expr->structName);
	if (it != bytecode.structEntries.end())
	{
		int structIndex = it->second;
		// Create instance with defaults from Bytecode::structs / constants
		bytecode.emit(OpCode::NEW_STRUCT_INSTANCE_STATIC, structIndex);

		// Apply any explicit field initializers as overrides using dynamic SET_FIELD.
		for (const auto &[fieldName, fieldValue] : expr->fieldValues)
		{
			generateExpression(fieldValue.get());
			int fieldNameIndex = bytecode.addConstant(Value(fieldName));
			bytecode.emit(OpCode::SET_FIELD, fieldNameIndex);
		}
	}
	else
	{
		// Fallback: use the original dynamic struct creation path.
		int structNameIndex = bytecode.addConstant(Value(expr->structName));
		bytecode.emit(OpCode::NEW_STRUCT, structNameIndex);

		for (const auto &[fieldName, fieldValue] : expr->fieldValues)
		{
			generateExpression(fieldValue.get());
			int fieldNameIndex = bytecode.addConstant(Value(fieldName));
			bytecode.emit(OpCode::SET_FIELD, fieldNameIndex);
		}
	}
}

void CodeGenerator::generateFieldAccessExpr(const AST::FieldAccessExpr *expr)
{
	// Generate code for the object being accessed
	generateExpression(expr->object.get());

	// For now, we'll use dynamic field access since we don't have type information
	// In a future version, we could add type inference or require type annotations
	// to enable static field access
	int fieldNameIndex = bytecode.addConstant(Value(expr->fieldName));
	bytecode.emit(OpCode::GET_FIELD, fieldNameIndex);
}

void CodeGenerator::generatePostfixExpr(const AST::PostfixExpr *expr)
{
	// Only support postfix on identifiers
	auto identExpr = dynamic_cast<const AST::IdentifierExpr *>(expr->operand.get());
	if (!identExpr)
	{
		throw std::runtime_error("Postfix operators only supported on variables");
	}

	int varIndex = bytecode.getOrCreateVar(identExpr->name);

	// Load current value
	bytecode.emit(OpCode::LOAD_VAR, varIndex);

	// Duplicate for return value (postfix returns old value)
	bytecode.emit(OpCode::LOAD_VAR, varIndex);

	// Push 1
	int oneIndex = bytecode.addConstant(Value(static_cast<int64_t>(1)));
	bytecode.emit(OpCode::PUSH_CONST, oneIndex);

	// Add or subtract
	// Prefer integer ops if we have inferred this variable is int
	auto it = inferredTypes.find(identExpr->name);
	bool varIsInt = (it != inferredTypes.end() && it->second == ValueType::Int);
	if (expr->op == AST::PostfixOp::Increment)
	{
		bytecode.emit(varIsInt ? OpCode::IADD : OpCode::FLADD);
	}
	else
	{
		bytecode.emit(varIsInt ? OpCode::ISUBTRACT : OpCode::FLSUBTRACT);
	}

	// Store new value
	bytecode.emit(OpCode::STORE_VAR, varIndex);
	bytecode.emit(OpCode::POP); // Pop the stored value
	                            // Old value is still on stack as return value
}

void CodeGenerator::generateStructDecl(const AST::StructDecl *decl)
{
	// Store a human-readable struct definition in the constant pool (existing behavior)
	std::string structDef = "struct " + decl->name + " {";
	for (const auto &field : decl->fields)
	{
		structDef += " " + field.name + ":" + field.type->name + ",";
	}
	if (!decl->fields.empty())
	{
		structDef.pop_back(); // Remove trailing comma
	}
	structDef += " }";
	bytecode.addConstant(Value(structDef));

	// Register struct metadata in the struct section (no runtime use yet)
	// Allocate placeholder default constants (currently all null) for each field.
	int firstConstIndex = static_cast<int>(bytecode.constants.size());
	for (const auto &field : decl->fields)
	{
		(void)field; // field.type is not yet used for typed defaults
		bytecode.addConstant(Value());
	}

	StructInfo info;
	info.name = decl->name;
	info.firstConstIndex = firstConstIndex;
	info.fieldCount = static_cast<int>(decl->fields.size());
	for (const auto &field : decl->fields)
	{
		info.fieldNames.push_back(field.name);
	}

	// If a struct with this name already exists, do not overwrite it.
	if (bytecode.structEntries.find(decl->name) == bytecode.structEntries.end())
	{
		int index = static_cast<int>(bytecode.structs.size());
		bytecode.structs.push_back(std::move(info));
		bytecode.structEntries[decl->name] = index;
	}
}

void CodeGenerator::generateSwitchStmt(const AST::SwitchStmt *switchStmt)
{
	generateExpression(switchStmt->expr.get());

	std::vector<int> caseJumps;

	for (const auto &caseClause : switchStmt->cases)
	{
		generateExpression(caseClause.value.get());
		bytecode.emit(OpCode::FLEQUAL);
		int jumpIndex = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP_IF_FALSE, 0);
		caseJumps.push_back(jumpIndex);

		for (const auto &stmt : caseClause.statements)
		{
			generateStatement(stmt.get());
		}

		int endJump = static_cast<int>(bytecode.instructions.size());
		bytecode.emit(OpCode::JUMP, 0);
		bytecode.instructions[jumpIndex].operand1 = static_cast<int>(bytecode.instructions.size());
		caseJumps.back() = endJump;
	}

	if (!switchStmt->defaultStmts.empty())
	{
		for (const auto &stmt : switchStmt->defaultStmts)
		{
			generateStatement(stmt.get());
		}
	}

	int endIndex = static_cast<int>(bytecode.instructions.size());
	for (int jumpIdx : caseJumps)
	{
		bytecode.instructions[jumpIdx].operand1 = endIndex;
	}
}
} // namespace Phasor


--- .\src\Codegen\CodeGen.hpp ---
#pragma once
#include "../AST/AST.hpp"
#include <Value.hpp>
#include "../ISA/ISA.hpp"
#include <cstdint>
#include <map>
#include <string>
#include <vector>

namespace Phasor
{
/// @brief Instruction with up to 5 operands
/// Format: instruction operand1, operand2, operand3, operand4, operand5
/// Each instruction uses only the operands it needs
struct Instruction
{
	OpCode  op;       ///< Operation code
	int32_t operand1; ///< First operand
	int32_t operand2; ///< Second operand
	int32_t operand3; ///< Third operand
	int32_t operand4; ///< Fourth operand
	int32_t operand5; ///< Fifth operand

	// Default constructor
	Instruction() : op(OpCode::HALT), operand1(0), operand2(0), operand3(0), operand4(0), operand5(0)
	{
	}

	// Full constructor
	Instruction(OpCode op, int32_t op1 = 0, int32_t op2 = 0, int32_t op3 = 0, int32_t op4 = 0, int32_t op5 = 0)
	    : op(op), operand1(op1), operand2(op2), operand3(op3), operand4(op4), operand5(op5)
	{
	}
};

/// @brief Struct metadata stored alongside bytecode (struct section)
struct StructInfo
{
	std::string              name;            ///< Struct name
	int                      firstConstIndex; ///< Index into constants for the first default value
	int                      fieldCount;      ///< Number of fields in this struct
	std::vector<std::string> fieldNames;      ///< Field names in declaration order
};

/// @brief Complete bytecode structure
struct Bytecode
{
	std::vector<Instruction>   instructions;     ///< List of instructions
	std::vector<Value>         constants;        ///< Constant pool
	std::map<std::string, int> variables;        ///< Variable name -> index mapping
	std::map<std::string, int> functionEntries;  ///< Function name -> instruction index mapping
	std::map<std::string, int> functionParamCounts; ///< Function name -> parameter count
	int                        nextVarIndex = 0; ///< Next available variable index

	// Struct section (planned usage by future struct codegen)
	std::vector<StructInfo>    structs;       ///< List of struct descriptors
	std::map<std::string, int> structEntries; ///< Struct name -> index in structs

	/// @brief Add a constant to the pool and return its index
	int addConstant(const Value &value)
	{
		constants.push_back(value);
		return static_cast<int>(constants.size()) - 1;
	}

	/// @brief Get or create a variable index
	int getOrCreateVar(const std::string &name)
	{
		auto it = variables.find(name);
		if (it != variables.end())
		{
			return it->second;
		}
		int index = nextVarIndex++;
		variables[name] = index;
		return index;
	}

	/// @brief Emit an instruction with operands
	void emit(OpCode op, int32_t op1 = 0, int32_t op2 = 0, int32_t op3 = 0, int32_t op4 = 0, int32_t op5 = 0)
	{
		instructions.push_back(Instruction(op, op1, op2, op3, op4, op5));
	}
};

/**
 * @brief Code generator for Phasor VM
 */
class CodeGenerator
{
  public:
	/**
	 * @brief Generate bytecode from program
	 *
	 * @param program Program to generate bytecode for
	 * @param existingVars Existing variables to use
	 * @param nextVarIdx Next available variable index
	 * @param replMode REPL mode
	 * @return Bytecode Generated bytecode
	 */
	Bytecode generate(const AST::Program &program, const std::map<std::string, int> &existingVars = {},
	                  int nextVarIdx = 0, bool replMode = false);

  private:
	Bytecode bytecode;       ///< Generated bytecode
	bool     isRepl = false; ///< REPL mode
	// Inferred types for variables (simple, flow-insensitive mapping)
	std::map<std::string, ValueType> inferredTypes;

	// Register allocation for v2.0
	uint8_t           nextRegister = 0; ///< Next available register
	std::vector<bool> registerInUse;    ///< Track which registers are in use

	/// @brief Allocate a new register
	uint8_t allocateRegister()
	{
		for (size_t i = 0; i < 32; i++)
		{
			if (i >= registerInUse.size())
			{
				registerInUse.resize(i + 1, false);
			}
			if (!registerInUse[i])
			{
				registerInUse[i] = true;
				return static_cast<uint8_t>(i);
			}
		}
		throw std::runtime_error("Out of registers");
	}

	/// @brief Free a register
	void freeRegister(uint8_t reg)
	{
		if (reg < registerInUse.size())
		{
			registerInUse[reg] = false;
		}
	}

	/// @brief Reset register allocator
	void resetRegisters()
	{
		registerInUse.clear();
		nextRegister = 0;
	}

	/// @brief Check if expression is a compile-time literal
	bool isLiteralExpression(const AST::Expression *expr, Value &outValue);

	/// @brief Simple expression type inference (conservative)
	/// @param expr expression to inspect
	/// @param known set to true when a type is known
	/// @return inferred ValueType (valid only when known == true)
	ValueType inferExpressionType(const AST::Expression *expr, bool &known);

	void generateStatement(const AST::Statement *stmt);                ///< Generate bytecode from Statement
	void generateExpression(const AST::Expression *expr);              ///< Generate bytecode from Expression
	void generateVarDecl(const AST::VarDecl *varDecl);                 ///< Generate bytecode from Variable Declaration
	void generateExpressionStmt(const AST::ExpressionStmt *exprStmt);  ///< Generate bytecode from Expression Statement
	void generatePrintStmt(const AST::PrintStmt *printStmt);           ///< Generate bytecode from Print Statement
	void generateImportStmt(const AST::ImportStmt *importStmt);        ///< Generate bytecode from Import Statement
	void generateExportStmt(const AST::ExportStmt *exportStmt);        ///< Generate bytecode from Export Statement
	void generateNumberExpr(const AST::NumberExpr *numExpr);           ///< Generate bytecode from Numeral Expression
	void generateStringExpr(const AST::StringExpr *strExpr);           ///< Generate bytecode from String Expression
	void generateIdentifierExpr(const AST::IdentifierExpr *identExpr); ///< Generate bytecode from Identifier Expression
	void generateUnaryExpr(const AST::UnaryExpr *unaryExpr);           ///< Generate bytecode from Unary Expression
	void generateCallExpr(const AST::CallExpr *callExpr);              ///< Generate bytecode from Call Expression
	void generateBinaryExpr(const AST::BinaryExpr *binExpr);           ///< Generate bytecode from Binary Expression
	void generateBlockStmt(const AST::BlockStmt *blockStmt);           ///< Generate bytecode from Block Statement
	void generateIfStmt(const AST::IfStmt *ifStmt);                    ///< Generate bytecode from If Statement
	void generateWhileStmt(const AST::WhileStmt *whileStmt);           ///< Generate bytecode from While Statement
	void generateForStmt(const AST::ForStmt *forStmt);                 ///< Generate bytecode from For Statement
	void generateReturnStmt(const AST::ReturnStmt *returnStmt);        ///< Generate bytecode from Return Statement
	void generateUnsafeBlockStmt(
	    const AST::UnsafeBlockStmt *unsafeStmt);                  ///< Generate bytecode from Unsafe Block Statement
	void generateFunctionDecl(const AST::FunctionDecl *funcDecl); ///< Generate bytecode from Function Declaration
	void generateBooleanExpr(const AST::BooleanExpr *boolExpr);   ///< Generate bytecode from Boolean Expression
	void generateNullExpr(const AST::NullExpr *nullExpr);         ///< Generate bytecode from Null Expression
	void generateAssignmentExpr(
	    const AST::AssignmentExpr *assignExpr); ///< Generate bytecode from Assignment Expression
	void generateStructDecl(const AST::StructDecl *decl);
	void generateStructInstanceExpr(const AST::StructInstanceExpr *expr);
	void generateFieldAccessExpr(const AST::FieldAccessExpr *expr);
	void generatePostfixExpr(const AST::PostfixExpr *expr);
	void generateBreakStmt();
	void generateContinueStmt();
	void generateSwitchStmt(const AST::SwitchStmt *switchStmt);

	// Loop context for break/continue
	std::vector<int>              loopStartStack;     // Stack of loop start positions
	std::vector<std::vector<int>> breakJumpsStack;    // Stack of break jump positions to patch
	std::vector<std::vector<int>> continueJumpsStack; // Stack of continue jump positions to patch
};

} // namespace Phasor

--- .\src\Codegen\Cpp\CppCodeGenerator.cpp ---
#include "CppCodeGenerator.hpp"
#include "../Bytecode/BytecodeSerializer.hpp"
#include "../Bytecode/BytecodeDeserializer.hpp"
#include <fstream>
#include <iomanip>
#include <sstream>

namespace Phasor
{

bool CppCodeGenerator::generate(const Bytecode &bc, const std::filesystem::path &outputPath, const std::string &modName)
{
	try
	{
		bytecode = &bc;
		output.str("");
		output.clear();

		// Determine module name
		if (modName.empty())
		{
			moduleName = sanitizeModuleName(outputPath.stem().string());
		}
		else
		{
			moduleName = sanitizeModuleName(modName);
		}

		// Serialize bytecode to binary format
		BytecodeSerializer serializer;
		serializedBytecode = serializer.serialize(bc);

		// Generate header file with module name, bytecode, and size
		generateFileHeader();
		generateModuleName();
		generateEmbeddedBytecode();

		// Write to file
		std::ofstream file(outputPath);
		if (!file.is_open())
		{
			return false;
		}

		file << output.str();
		file.close();

		return true;
	}
	catch (const std::exception &)
	{
		return false;
	}
}

Bytecode CppCodeGenerator::generateBytecodeFromEmbedded(const std::string &input)
{
	std::vector<unsigned char> bytecodeData = parseEmbeddedBytecode(input);
	BytecodeDeserializer       deserializer;
	return deserializer.deserialize(bytecodeData);
}

void CppCodeGenerator::generateFileHeader()
{
	output << "// Phasor VM Program\n";
	output << "// Module: " << moduleName << "\n";
	output << "#pragma once\n";
	output << "#include <cstddef>\n";
	output << "#include <string>\n\n";
}

void CppCodeGenerator::generateModuleName()
{
	output << "std::string moduleName = \"" << moduleName << "\";\n\n";
}

void CppCodeGenerator::generateEmbeddedBytecode()
{
	output << "inline constexpr unsigned char embeddedBytecode[] = {\n";

	// Write bytecode as hex array
	for (size_t i = 0; i < serializedBytecode.size(); i++)
	{
		if (i % 16 == 0)
			output << "\t";

		output << "0x" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(serializedBytecode[i]);

		if (i < serializedBytecode.size() - 1)
			output << ",";

		if (i % 16 == 15)
			output << "\n";
		else if (i < serializedBytecode.size() - 1)
			output << " ";
	}

	output << std::dec << "\n};\n";
	output << "inline const size_t embeddedBytecodeSize = " << serializedBytecode.size() << ";\n";
}

std::vector<unsigned char> CppCodeGenerator::parseEmbeddedBytecode(const std::string &input)
{
	std::vector<unsigned char> result;
	std::istringstream         stream(input);
	std::string                token;

	while (stream >> token)
	{
		// Only process tokens starting with "0x"
		if (token.size() >= 3 && token[0] == '0' && (token[1] == 'x' || token[1] == 'X'))
		{
			unsigned int       byte;
			std::istringstream hexStream(token);
			hexStream >> std::hex >> byte;
			result.push_back(static_cast<unsigned char>(byte));
		}
	}

	return result;
}

std::string CppCodeGenerator::escapeString(const std::string &str)
{
	std::ostringstream escaped;
	for (char c : str)
	{
		switch (c)
		{
		case '\\':
			escaped << "\\\\";
			break;
		case '\"':
			escaped << "\\\"";
			break;
		case '\n':
			escaped << "\\n";
			break;
		case '\r':
			escaped << "\\r";
			break;
		case '\t':
			escaped << "\\t";
			break;
		default:
			if (c >= 32 && c <= 126)
				escaped << c;
			else
				escaped << "\\x" << std::hex << std::setw(2) << std::setfill('0')
				        << static_cast<int>(static_cast<unsigned char>(c));
			break;
		}
	}
	return escaped.str();
}

std::string CppCodeGenerator::getValueTypeString(ValueType type)
{
	switch (type)
	{
	case ValueType::Null:
		return "Null";
	case ValueType::Bool:
		return "Bool";
	case ValueType::Int:
		return "Int";
	case ValueType::Float:
		return "Float";
	case ValueType::String:
		return "String";
	default:
		return "Unknown";
	}
}

std::string CppCodeGenerator::sanitizeModuleName(const std::string &name)
{
	std::string result;
	for (char c : name)
	{
		if (std::isalnum(c) || c == '_')
			result += c;
		else
			result += '_';
	}

	// Ensure it starts with a letter or underscore
	if (!result.empty() && std::isdigit(result[0]))
		result = "_" + result;

	return result.empty() ? "PhasorModule" : result;
}

} // namespace Phasor


--- .\src\Codegen\Cpp\CppCodeGenerator.hpp ---
#pragma once
#include "../CodeGen.hpp"
#include <filesystem>
#include <sstream>
#include <string>

/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class CppCodeGenerator
 * @brief Generates C++ header files with embedded Phasor bytecode
 *
 * This class takes compiled Phasor bytecode and generates a C++ header file
 * that embeds the bytecode as inline data. The header is designed to be
 * included in CppRuntime_main.cpp to provide the module name, bytecode array,
 * and bytecode size.
 */
class CppCodeGenerator
{
  public:
	/**
	 * @brief Generate C++ header file from bytecode
	 *
	 * @param bytecode The compiled bytecode to embed
	 * @param outputPath Path to the output header file
	 * @param moduleName Optional module name (defaults to filename without extension)
	 * @return true if generation succeeded, false otherwise
	 */
	bool generate(const Bytecode &bytecode, const std::filesystem::path &outputPath,
	              const std::string &moduleName = "");

	/**
	 * @brief Generate Bytecode object from embedded bytecode string
	 * @param input The string containing the embedded bytecode array
	 * @return Deserialized Bytecode object
	 *
	 */
	Bytecode generateBytecodeFromEmbedded(const std::string &input);

  private:
	std::ostringstream   output; ///< Output stream for generated code
	const Bytecode      *bytecode = nullptr;
	std::string          moduleName;
	std::vector<uint8_t> serializedBytecode; ///< Serialized bytecode in .phsb format

	// Code generation methods
	void generateFileHeader();
	void generateModuleName();
	void generateIncludes();
	void generateEmbeddedBytecode();
	void generateTempFileWriter();
	void generateMainFunction();

	// Deserialization helper
	std::vector<unsigned char> parseEmbeddedBytecode(const std::string &input);

	// Helper methods
	std::string escapeString(const std::string &str);
	std::string getValueTypeString(ValueType type);
	std::string sanitizeModuleName(const std::string &name);
};

} // namespace Phasor


--- .\src\Codegen\IR\PhasorIR.cpp ---
#include "PhasorIR.hpp"
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <stdexcept>

#if defined(_MSC_VER)
#define COMPILE_MESSAGE(msg) __pragma(message(msg))
#elif defined(__GNUC__) || defined(__clang__)
#define DO_PRAGMA(x) _Pragma(#x)
#define COMPILE_MESSAGE(msg) DO_PRAGMA(message msg)
#else
#define COMPILE_MESSAGE(msg)
#endif
#define STR2(x) #x
#define STR(x) STR2(x)

namespace Phasor
{

const std::unordered_map<OpCode, std::string> PhasorIR::opCodeToStringMap = {
    {OpCode::PUSH_CONST, "PUSH_CONST"},
    {OpCode::POP, "POP"},
    {OpCode::IADD, "IADD"},
    {OpCode::ISUBTRACT, "ISUBTRACT"},
    {OpCode::IMULTIPLY, "IMULTIPLY"},
    {OpCode::IDIVIDE, "IDIVIDE"},
    {OpCode::IMODULO, "IMODULO"},
    {OpCode::FLADD, "FLADD"},
    {OpCode::FLSUBTRACT, "FLSUBTRACT"},
    {OpCode::FLMULTIPLY, "FLMULTIPLY"},
    {OpCode::FLDIVIDE, "FLDIVIDE"},
    {OpCode::FLMODULO, "FLMODULO"},
    {OpCode::SQRT, "SQRT"},
    {OpCode::POW, "POW"},
    {OpCode::LOG, "LOG"},
    {OpCode::EXP, "EXP"},
    {OpCode::SIN, "SIN"},
    {OpCode::COS, "COS"},
    {OpCode::TAN, "TAN"},
    {OpCode::NEGATE, "NEGATE"},
    {OpCode::NOT, "NOT"},
    {OpCode::IAND, "IAND"},
    {OpCode::IOR, "IOR"},
    {OpCode::IEQUAL, "IEQUAL"},
    {OpCode::INOT_EQUAL, "INOT_EQUAL"},
    {OpCode::ILESS_THAN, "ILESS_THAN"},
    {OpCode::IGREATER_THAN, "IGREATER_THAN"},
    {OpCode::ILESS_EQUAL, "ILESS_EQUAL"},
    {OpCode::IGREATER_EQUAL, "IGREATER_EQUAL"},
    {OpCode::FLAND, "FLAND"},
    {OpCode::FLOR, "FLOR"},
    {OpCode::FLEQUAL, "FLEQUAL"},
    {OpCode::FLNOT_EQUAL, "FLNOT_EQUAL"},
    {OpCode::FLLESS_THAN, "FLLESS_THAN"},
    {OpCode::FLGREATER_THAN, "FLGREATER_THAN"},
    {OpCode::FLLESS_EQUAL, "FLLESS_EQUAL"},
    {OpCode::FLGREATER_EQUAL, "FLGREATER_EQUAL"},
    {OpCode::JUMP, "JUMP"},
    {OpCode::JUMP_IF_FALSE, "JUMP_IF_FALSE"},
    {OpCode::JUMP_IF_TRUE, "JUMP_IF_TRUE"},
    {OpCode::JUMP_BACK, "JUMP_BACK"},
    {OpCode::STORE_VAR, "STORE_VAR"},
    {OpCode::LOAD_VAR, "LOAD_VAR"},
    {OpCode::PRINT, "PRINT"},
    {OpCode::PRINTERROR, "PRINTERROR"},
    {OpCode::READLINE, "READLINE"},
    {OpCode::IMPORT, "IMPORT"},
    {OpCode::HALT, "HALT"},
    {OpCode::CALL_NATIVE, "CALL_NATIVE"},
    {OpCode::CALL, "CALL"},
    {OpCode::SYSTEM, "SYSTEM"},
    {OpCode::SYSTEM_OUT, "SYSTEM_OUT"},
    {OpCode::SYSTEM_ERR, "SYSTEM_ERR"},
    {OpCode::RETURN, "RETURN"},
    {OpCode::TRUE_P, "TRUE"},
    {OpCode::FALSE_P, "FALSE"},
    {OpCode::NULL_VAL, "NULL_VAL"},
    {OpCode::LEN, "LEN"},
    {OpCode::CHAR_AT, "CHAR_AT"},
    {OpCode::SUBSTR, "SUBSTR"},
    {OpCode::MOV, "MOV"},
    {OpCode::LOAD_CONST_R, "LOAD_CONST_R"},
    {OpCode::LOAD_VAR_R, "LOAD_VAR_R"},
    {OpCode::STORE_VAR_R, "STORE_VAR_R"},
    {OpCode::IADD_R, "IADD_R"},
    {OpCode::ISUB_R, "ISUB_R"},
    {OpCode::IMUL_R, "IMUL_R"},
    {OpCode::IDIV_R, "IDIV_R"},
    {OpCode::IMOD_R, "IMOD_R"},
    {OpCode::FLADD_R, "FLADD_R"},
    {OpCode::FLSUB_R, "FLSUB_R"},
    {OpCode::FLMUL_R, "FLMUL_R"},
    {OpCode::FLDIV_R, "FLDIV_R"},
    {OpCode::FLMOD_R, "FLMOD_R"},
    {OpCode::SQRT_R, "SQRT_R"},
    {OpCode::POW_R, "POW_R"},
    {OpCode::LOG_R, "LOG_R"},
    {OpCode::EXP_R, "EXP_R"},
    {OpCode::SIN_R, "SIN_R"},
    {OpCode::COS_R, "COS_R"},
    {OpCode::TAN_R, "TAN_R"},
    {OpCode::IAND_R, "IAND_R"},
    {OpCode::IOR_R, "IOR_R"},
    {OpCode::IEQ_R, "IEQ_R"},
    {OpCode::INE_R, "INE_R"},
    {OpCode::ILT_R, "ILT_R"},
    {OpCode::IGT_R, "IGT_R"},
    {OpCode::ILE_R, "ILE_R"},
    {OpCode::IGE_R, "IGE_R"},
    {OpCode::FLAND_R, "FLAND_R"},
    {OpCode::FLOR_R, "FLOR_R"},
    {OpCode::FLEQ_R, "FLEQ_R"},
    {OpCode::FLNE_R, "FLNE_R"},
    {OpCode::FLLT_R, "FLLT_R"},
    {OpCode::FLGT_R, "FLGT_R"},
    {OpCode::FLLE_R, "FLLE_R"},
    {OpCode::FLGE_R, "FLGE_R"},
    {OpCode::PUSH_R, "PUSH_R"},
    {OpCode::PUSH2_R, "PUSH2_R"},
    {OpCode::POP_R, "POP_R"},
    {OpCode::POP2_R, "POP2_R"},
    {OpCode::NEG_R, "NEG_R"},
    {OpCode::NOT_R, "NOT_R"},
    {OpCode::PRINT_R, "PRINT_R"},
    {OpCode::PRINTERROR_R, "PRINTERROR_R"},
    {OpCode::READLINE_R, "READLINE_R"},
    {OpCode::SYSTEM_R, "SYSTEM_R"},
    {OpCode::SYSTEM_OUT_R, "SYSTEM_OUT_R"},
    {OpCode::SYSTEM_ERR_R, "SYSTEM_ERR_R"}};

const std::unordered_map<std::string, OpCode> PhasorIR::stringToOpCodeMap = [] {
	std::unordered_map<std::string, OpCode> map;
	for (const auto &pair : PhasorIR::opCodeToStringMap)
	{
		map[pair.second] = pair.first;
	}
	return map;
}();

int PhasorIR::getOperandCount(OpCode op)
{
	switch (op)
	{
	// 0 operands
	case OpCode::POP:
	case OpCode::IADD:
	case OpCode::ISUBTRACT:
	case OpCode::IMULTIPLY:
	case OpCode::IDIVIDE:
	case OpCode::IMODULO:
	case OpCode::FLADD:
	case OpCode::FLSUBTRACT:
	case OpCode::FLMULTIPLY:
	case OpCode::FLDIVIDE:
	case OpCode::FLMODULO:
	case OpCode::SQRT:
	case OpCode::POW:
	case OpCode::LOG:
	case OpCode::EXP:
	case OpCode::SIN:
	case OpCode::COS:
	case OpCode::TAN:
	case OpCode::NEGATE:
	case OpCode::NOT:
	case OpCode::IAND:
	case OpCode::IOR:
	case OpCode::IEQUAL:
	case OpCode::INOT_EQUAL:
	case OpCode::ILESS_THAN:
	case OpCode::IGREATER_THAN:
	case OpCode::ILESS_EQUAL:
	case OpCode::IGREATER_EQUAL:
	case OpCode::FLEQUAL:
	case OpCode::FLNOT_EQUAL:
	case OpCode::FLLESS_THAN:
	case OpCode::FLGREATER_THAN:
	case OpCode::FLLESS_EQUAL:
	case OpCode::FLGREATER_EQUAL:
	case OpCode::PRINT:
	case OpCode::PRINTERROR:
	case OpCode::READLINE:
	case OpCode::HALT:
	case OpCode::RETURN:
	case OpCode::TRUE_P:
	case OpCode::FALSE_P:
	case OpCode::NULL_VAL:
	case OpCode::LEN:
	case OpCode::CHAR_AT:
	case OpCode::SUBSTR:
		return 0;

	// 1 operand
	case OpCode::PUSH_CONST:
	case OpCode::JUMP:
	case OpCode::JUMP_IF_FALSE:
	case OpCode::JUMP_IF_TRUE:
	case OpCode::JUMP_BACK:
	case OpCode::STORE_VAR:
	case OpCode::LOAD_VAR:
	case OpCode::IMPORT:
	case OpCode::CALL_NATIVE:
	case OpCode::CALL:
	case OpCode::SYSTEM:
	case OpCode::SYSTEM_OUT:
	case OpCode::SYSTEM_ERR:
	case OpCode::PUSH_R:
	case OpCode::POP_R:
	case OpCode::PRINT_R:
	case OpCode::PRINTERROR_R:
	case OpCode::READLINE_R:
	case OpCode::SYSTEM_R:
	case OpCode::SYSTEM_OUT_R:
	case OpCode::SYSTEM_ERR_R:
	case OpCode::NEW_STRUCT:
	case OpCode::GET_FIELD:
	case OpCode::SET_FIELD:
	case OpCode::NEW_STRUCT_INSTANCE_STATIC:
		return 1;

	// 2 operands
	case OpCode::MOV:
	case OpCode::LOAD_CONST_R:
	case OpCode::LOAD_VAR_R:
	case OpCode::STORE_VAR_R:
	case OpCode::SQRT_R:
	case OpCode::LOG_R:
	case OpCode::EXP_R:
	case OpCode::SIN_R:
	case OpCode::COS_R:
	case OpCode::TAN_R:
	case OpCode::NEG_R:
	case OpCode::NOT_R:
	case OpCode::PUSH2_R:
	case OpCode::POP2_R:
	case OpCode::GET_FIELD_STATIC:
	case OpCode::SET_FIELD_STATIC:
		return 2;

	// 3 operands
	case OpCode::IADD_R:
	case OpCode::ISUB_R:
	case OpCode::IMUL_R:
	case OpCode::IDIV_R:
	case OpCode::IMOD_R:
	case OpCode::FLADD_R:
	case OpCode::FLSUB_R:
	case OpCode::FLMUL_R:
	case OpCode::FLDIV_R:
	case OpCode::FLMOD_R:
	case OpCode::POW_R:
	case OpCode::IAND_R:
	case OpCode::IOR_R:
	case OpCode::IEQ_R:
	case OpCode::INE_R:
	case OpCode::ILT_R:
	case OpCode::IGT_R:
	case OpCode::ILE_R:
	case OpCode::IGE_R:
	case OpCode::FLAND_R:
	case OpCode::FLOR_R:
	case OpCode::FLEQ_R:
	case OpCode::FLNE_R:
	case OpCode::FLLT_R:
	case OpCode::FLGT_R:
	case OpCode::FLLE_R:
	case OpCode::FLGE_R:
		return 3;

	default:
		return 0;
	}
}

PhasorIR::OperandType PhasorIR::getOperandType(OpCode op, int operandIndex)
{
	// Stack operations with special indices
	if (op == OpCode::PUSH_CONST && operandIndex == 0)
		return OperandType::CONSTANT_IDX;
	if (op == OpCode::STORE_VAR && operandIndex == 0)
		return OperandType::VARIABLE_IDX;
	if (op == OpCode::LOAD_VAR && operandIndex == 0)
		return OperandType::VARIABLE_IDX;
	if (op == OpCode::IMPORT && operandIndex == 0)
		return OperandType::CONSTANT_IDX;
	if (op == OpCode::CALL_NATIVE && operandIndex == 0)
		return OperandType::CONSTANT_IDX;
	if (op == OpCode::CALL && operandIndex == 0)
		return OperandType::FUNCTION_IDX;
	if (op == OpCode::SYSTEM && operandIndex == 0)
		return OperandType::CONSTANT_IDX;

	// Register operations with mixed types
	if (op == OpCode::LOAD_CONST_R)
	{
		if (operandIndex == 0)
			return OperandType::REGISTER;
		if (operandIndex == 1)
			return OperandType::CONSTANT_IDX;
	}
	if (op == OpCode::LOAD_VAR_R)
	{
		if (operandIndex == 0)
			return OperandType::REGISTER;
		if (operandIndex == 1)
			return OperandType::VARIABLE_IDX;
	}
	if (op == OpCode::STORE_VAR_R)
	{
		if (operandIndex == 0)
			return OperandType::REGISTER;
		if (operandIndex == 1)
			return OperandType::VARIABLE_IDX;
	}

	// JUMP instructions take an offset (INT)
	if (op == OpCode::JUMP || op == OpCode::JUMP_IF_FALSE || op == OpCode::JUMP_IF_TRUE || op == OpCode::JUMP_BACK)
	{
		return OperandType::INT;
	}

	// Register ops use REGISTER for all operands
	if (static_cast<int>(op) >= static_cast<int>(OpCode::MOV))
	{
		return OperandType::REGISTER;
	}

	return OperandType::INT;
}

std::string PhasorIR::opCodeToString(OpCode op)
{
	auto it = opCodeToStringMap.find(op);
	if (it != opCodeToStringMap.end())
	{
		return it->second;
	}
	return "UNKNOWN";
}

OpCode PhasorIR::stringToOpCode(const std::string &str)
{
	auto it = stringToOpCodeMap.find(str);
	if (it != stringToOpCodeMap.end())
	{
		return it->second;
	}
	throw std::runtime_error("Unknown opcode string: " + str);
}

std::string PhasorIR::escapeString(const std::string &str)
{
	std::stringstream ss;
	for (char c : str)
	{
		switch (c)
		{
		case '\n':
			ss << "\\n";
			break;
		case '\r':
			ss << "\\r";
			break;
		case '\t':
			ss << "\\t";
			break;
		case '\\':
			ss << "\\\\";
			break;
		case '"':
			ss << "\\\"";
			break;
		default:
			ss << c;
			break;
		}
	}
	return ss.str();
}

std::string PhasorIR::unescapeString(const std::string &str)
{
	std::string result;
	for (size_t i = 0; i < str.length(); ++i)
	{
		if (str[i] == '\\' && i + 1 < str.length())
		{
			switch (str[i + 1])
			{
			case 'n':
				result += '\n';
				break;
			case 'r':
				result += '\r';
				break;
			case 't':
				result += '\t';
				break;
			case '\\':
				result += '\\';
				break;
			case '"':
				result += '"';
				break;
			default:
				result += str[i];
				result += str[i + 1];
				break;
			}
			i++;
		}
		else
		{
			result += str[i];
		}
	}
	return result;
}

std::vector<uint8_t> PhasorIR::serialize(const Bytecode &bytecode)
{
	std::stringstream ss;

	// Write Header
	ss << ".PHIR 3.0.0" << "\n";

	// Build reverse lookup maps for inline comments
	std::map<int, std::string> indexToVarName;
	for (const auto &[name, index] : bytecode.variables)
	{
		indexToVarName[index] = name;
	}
	std::map<int, std::string> addressToFuncName;
	for (const auto &[name, address] : bytecode.functionEntries)
	{
		addressToFuncName[address] = name;
	}

	// Constants Section
	ss << ".CONSTANTS " << bytecode.constants.size() << "\n";
	for (const auto &val : bytecode.constants)
	{
		switch (val.getType())
		{
		case ValueType::Null:
			ss << "NULL\n";
			break;
		case ValueType::Bool:
			ss << "BOOL " << (val.asBool() ? "true" : "false") << "\n";
			break;
		case ValueType::Int:
			ss << "INT " << val.asInt() << "\n";
			break;
		case ValueType::Float:
			ss << "FLOAT " << val.asFloat() << "\n";
			break;
		case ValueType::String:
			ss << "STRING \"" << escapeString(val.asString()) << "\"\n";
			break;
		case ValueType::Struct:
			COMPILE_MESSAGE("Warning: PHS_01 Structs have not been fully implemented! Line " STR(__LINE__))
			throw std::runtime_error("Structs not implemented!");
			break;
		case ValueType::Array:
			COMPILE_MESSAGE("Warning: PHS_02 Arrays have not been implemented! Line " STR(__LINE__))
			throw std::runtime_error("Arrays not implemented!");
		}
	}

	// Variables Section
	ss << ".VARIABLES " << bytecode.variables.size() << " " << bytecode.nextVarIndex << "\n";
	for (const auto &[name, index] : bytecode.variables)
	{
		ss << name << " " << index << "\n";
	}

	// Functions Section
	ss << ".FUNCTIONS " << bytecode.functionEntries.size() << "\n";
	for (const auto &[name, address] : bytecode.functionEntries)
	{
		ss << name << " " << address << "\n";
	}

	// Structs Section
	ss << ".STRUCTS " << bytecode.structs.size() << "\n";
	for (const auto &info : bytecode.structs)
	{
		// name firstConstIndex fieldCount fieldName0 fieldName1 ...
		ss << info.name << " " << info.firstConstIndex << " " << info.fieldCount;
		for (const auto &fieldName : info.fieldNames)
		{
			ss << " " << fieldName;
		}
		ss << "\n";
	}

	// Instructions Section
	ss << ".INSTRUCTIONS " << bytecode.instructions.size() << "\n";
	for (const auto &instr : bytecode.instructions)
	{
		std::stringstream instrLine;
		instrLine << opCodeToString(instr.op);

		int     operandCount = getOperandCount(instr.op);
		int32_t operands[5] = {instr.operand1, instr.operand2, instr.operand3, instr.operand4, instr.operand5};

		std::string comment;

		for (int i = 0; i < operandCount; ++i)
		{
			OperandType type = getOperandType(instr.op, i);

			if (i > 0)
				instrLine << ",";
			instrLine << " ";

			switch (type)
			{
			case OperandType::REGISTER:
				instrLine << "r" << operands[i];
				break;
			case OperandType::CONSTANT_IDX:
				instrLine << operands[i];
				if (operands[i] >= 0 && operands[i] < static_cast<int>(bytecode.constants.size()))
				{
					const Value &val = bytecode.constants[operands[i]];
					if (val.getType() == ValueType::String)
					{
						std::string str = val.asString();
						if (str.length() > 20)
							str = str.substr(0, 20) + "...";
						comment = "const[" + std::to_string(operands[i]) + "]=\"" + escapeString(str) + "\"";
					}
					else if (val.getType() == ValueType::Int)
					{
						comment = "const[" + std::to_string(operands[i]) + "]=" + std::to_string(val.asInt());
					}
					else if (val.getType() == ValueType::Float)
					{
						comment = "const[" + std::to_string(operands[i]) + "]=" + std::to_string(val.asFloat());
					}
				}
				break;
			case OperandType::VARIABLE_IDX:
				instrLine << operands[i];
				if (indexToVarName.count(operands[i]))
				{
					comment = "var=" + indexToVarName[operands[i]];
				}
				break;
			case OperandType::FUNCTION_IDX:
				instrLine << operands[i];
				if (addressToFuncName.count(operands[i]))
				{
					comment = "func=" + addressToFuncName[operands[i]];
				}
				break;
			default:
				instrLine << operands[i];
				break;
			}
		}

		std::string lineStr = instrLine.str();
		if (!comment.empty())
		{
			const size_t commentColumn = 40;
			if (lineStr.length() < commentColumn)
			{
				lineStr.append(commentColumn - lineStr.length(), ' ');
			}
			else
			{
				lineStr += " ";
			}

			lineStr += "; " + comment;
		}
		ss << lineStr << "\n";
	}

	std::string          textData = ss.str();
	std::vector<uint8_t> buffer;

	// Append text data
	buffer.insert(buffer.end(), textData.begin(), textData.end());

	return buffer;
}

Bytecode PhasorIR::deserialize(const std::vector<uint8_t> &data)
{
	if (data.size() < 8)
	{
		throw std::runtime_error("Invalid Phasor IR file: too small");
	}

	// Parse text data
	std::string       textData(data.begin() + 8, data.end());
	std::stringstream ss(textData);
	std::string       line;
	Bytecode          bytecode;

	std::string section;
	while (ss >> section)
	{
		if (section == ".PHIR")
		{
			std::string version;
			ss >> version;
			if (version < "3.0.0")
			{
				throw std::runtime_error("Incompatible Phasor IR version");
			}
		}
		if (section == ".CONSTANTS")
		{
			int count;
			ss >> count;
			bytecode.constants.reserve(count);
			for (int i = 0; i < count; ++i)
			{
				std::string type;
				ss >> type;
				if (type == "NULL")
				{
					bytecode.constants.push_back(Value());
				}
				else if (type == "BOOL")
				{
					std::string valStr;
					ss >> valStr;
					bytecode.constants.push_back(Value(valStr == "true"));
				}
				else if (type == "INT")
				{
					int64_t val;
					ss >> val;
					bytecode.constants.push_back(Value(val));
				}
				else if (type == "FLOAT")
				{
					double val;
					ss >> val;
					bytecode.constants.push_back(Value(val));
				}
				else if (type == "STRING")
				{
					std::string valStr;
					// Read quoted string, potentially with spaces
					char c;
					while (ss.get(c) && c != '"')
						;                          // Skip until opening quote
					std::getline(ss, valStr, '"'); // Read until closing quote
					bytecode.constants.push_back(Value(unescapeString(valStr)));
				}
			}
		}
		else if (section == ".VARIABLES")
		{
			int count;
			ss >> count >> bytecode.nextVarIndex;
			for (int i = 0; i < count; ++i)
			{
				std::string name;
				int         index;
				ss >> name >> index;
				bytecode.variables[name] = index;
			}
		}
		else if (section == ".FUNCTIONS")
		{
			int count;
			ss >> count;
			for (int i = 0; i < count; ++i)
			{
				std::string name;
				int         address;
				ss >> name >> address;
				bytecode.functionEntries[name] = address;
			}
		}
		else if (section == ".STRUCTS")
		{
			int count;
			ss >> count;
			for (int i = 0; i < count; ++i)
			{
				StructInfo info;
				ss >> info.name >> info.firstConstIndex >> info.fieldCount;
				info.fieldNames.clear();
				for (int f = 0; f < info.fieldCount; ++f)
				{
					std::string fieldName;
					ss >> fieldName;
					info.fieldNames.push_back(fieldName);
				}
				int index = static_cast<int>(bytecode.structs.size());
				bytecode.structs.push_back(std::move(info));
				bytecode.structEntries[bytecode.structs.back().name] = index;
			}
		}
		else if (section == ".INSTRUCTIONS")
		{
			int count;
			ss >> count;
			bytecode.instructions.reserve(count);
			for (int i = 0; i < count; ++i)
			{
				std::string opStr;
				ss >> opStr;

				OpCode  op = stringToOpCode(opStr);
				int     operandCount = getOperandCount(op);
				int32_t operands[5] = {0, 0, 0, 0, 0};

				for (int j = 0; j < operandCount; ++j)
				{
					std::string token;
					ss >> token;

					// Skip if we hit a comment
					if (token.empty() || token[0] == ';')
					{
						// Skip rest of line
						std::getline(ss, token);
						break;
					}

					// Strip trailing comma if present
					if (!token.empty() && token.back() == ',')
					{
						token.pop_back();
					}

					// Parse register format "rN" or plain integer
					if (!token.empty() && token[0] == 'r')
					{
						operands[j] = std::stoi(token.substr(1));
					}
					else
					{
						operands[j] = std::stoi(token);
					}
				}

				// Skip any remaining content on the line (comments)
				char c;
				while (ss.get(c) && c != '\n')
					;

				bytecode.instructions.push_back(
				    Instruction(op, operands[0], operands[1], operands[2], operands[3], operands[4]));
			}
		}
	}

	return bytecode;
}

bool PhasorIR::saveToFile(const Bytecode &bytecode, const std::filesystem::path &filename)
{
	try
	{
		std::vector<uint8_t> data = serialize(bytecode);
		std::ofstream        file(filename, std::ios::binary);
		if (!file.is_open())
			return false;
		file.write(reinterpret_cast<const char *>(data.data()), data.size());
		return true;
	}
	catch (...)
	{
		return false;
	}
}

Bytecode PhasorIR::loadFromFile(const std::filesystem::path &filename)
{
	std::ifstream file(filename, std::ios::binary | std::ios::ate);
	if (!file.is_open())
		throw std::runtime_error("Cannot open file");
	std::streamsize size = file.tellg();
	file.seekg(0, std::ios::beg);
	std::vector<uint8_t> buffer(size);
	if (!file.read(reinterpret_cast<char *>(buffer.data()), size))
		throw std::runtime_error("Cannot read file");
	return deserialize(buffer);
}
} // namespace Phasor


--- .\src\Codegen\IR\PhasorIR.hpp ---
#pragma once
#include "../CodeGen.hpp"
#include <cstdint>
#include <filesystem>
#include <string>
#include <unordered_map>
#include <vector>

/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class PhasorIR
 * @brief Phasor IR Serializer/Deserializer
 */
class PhasorIR
{
  public:
	/// @brief Serialize bytecode to Phasor IR format
	static std::vector<uint8_t> serialize(const Bytecode &bytecode);

	/// @brief Deserialize Phasor IR format to bytecode
	static Bytecode deserialize(const std::vector<uint8_t> &data);

	/// @brief Save bytecode to .phir file
	static bool saveToFile(const Bytecode &bytecode, const std::filesystem::path &filename);

	/// @brief Load bytecode from .phir file
	static Bytecode loadFromFile(const std::filesystem::path &filename);

	/// @brief Helper to convert OpCode to string
	static std::string opCodeToString(OpCode op);

	/// @brief Helper to convert string to OpCode
	static OpCode stringToOpCode(const std::string &str);

	/// @brief Helper to escape strings for text format
	static std::string escapeString(const std::string &str);

	/// @brief Helper to unescape strings from text format
	static std::string unescapeString(const std::string &str);

  private:
	/// @brief Operand types for instructions
	enum class OperandType
	{
		NONE, ///< No operand
		INT,  ///< Integer operand
		REGISTER,  ///< Register operand
		CONSTANT_IDX, ///< Index into constant pool
		VARIABLE_IDX, ///< Index into variable mapping
		FUNCTION_IDX ///< Index into function entries
	};

	static int         getOperandCount(OpCode op);
	static OperandType getOperandType(OpCode op, int operandIndex);

	static const std::unordered_map<OpCode, std::string> opCodeToStringMap;
	static const std::unordered_map<std::string, OpCode> stringToOpCodeMap;
};

} // namespace Phasor

--- .\src\Compiler\CMakeLists.txt ---
add_library(phasor_compiler_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Compiler.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Compiler.hpp
)

target_link_libraries(phasor_compiler_lib phasor_language PhasorCodegen)

add_library(phasor_cxx_transpiler_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/CppCompiler.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/CppCompiler.hpp
)

target_link_libraries(phasor_cxx_transpiler_lib phasor_language PhasorCodegen)

add_library(pulsar_compiler_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Compiler.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Compiler.hpp
)

target_link_libraries(pulsar_compiler_lib pulsar_language PhasorCodegen)

add_library(phasor_disasm_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Shared/Disassembler.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Shared/Disassembler.hpp
)

target_link_libraries(phasor_disasm_lib PhasorCodegen)

--- .\src\Compiler\Phasor\Compiler.cpp ---
#include "Compiler.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../Codegen/Bytecode/BytecodeSerializer.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

namespace Phasor
{

Compiler::Compiler(int argc, char *argv[], char *envp[])
{
	m_args.envp = envp;
	parseArguments(argc, argv);
}

int Compiler::run()
{
	if (m_args.showLogo)
		std::cout << "Phasor Compiler\n(C) 2026 Daniel McGuire\n\n";
	if (m_args.inputFile.empty())
	{
		std::cerr << "Error: No input file provided\n";
		return 1;
	}

	if (m_args.irMode)
		return compileToIR();

	return compileToBytecode();
}

int Compiler::compileToBytecode()
{
	if (std::filesystem::path(m_args.inputFile).extension() == ".phsb")
	{
		std::cerr << "Error: Cannot compile a bytecode file\n";
		return 1;
	}

	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		Lexer         lexer(source);
		Parser        parser(lexer.tokenize());
		auto          program = parser.parse();
		CodeGenerator codegen;
		auto          bytecode = codegen.generate(*program);

		if (m_args.outputFile.empty())
		{
			m_args.outputFile = m_args.inputFile;
			std::filesystem::path path(m_args.outputFile);
			path.replace_extension(".phsb");
			m_args.outputFile = path.string();
		}

		BytecodeSerializer serializer;
		if (!serializer.saveToFile(bytecode, m_args.outputFile))
		{
			std::cerr << "Failed to save bytecode to: " << m_args.outputFile << "\n";
			return 1;
		}

		if (m_args.showLogo)
			std::cout << "Compiled successfully: " << m_args.inputFile << " -> " << m_args.outputFile << "\n";
		return 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Compilation Error: " << e.what() << "\n";
		return 1;
	}
}

int Compiler::compileToIR()
{
	if (std::filesystem::path(m_args.inputFile).extension() == ".phir")
	{
		std::cerr << "Error: Cannot compile a Phasor IR file\n";
		return 1;
	}

	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		Lexer         lexer(source);
		Parser        parser(lexer.tokenize());
		auto          program = parser.parse();
		CodeGenerator codegen;
		auto          bytecode = codegen.generate(*program);

		if (m_args.outputFile.empty())
		{
			m_args.outputFile = m_args.inputFile;
			std::filesystem::path path(m_args.outputFile);
			path.replace_extension(".phir");
			m_args.outputFile = path.string();
		}

		if (!PhasorIR::saveToFile(bytecode, m_args.outputFile))
		{
			std::cerr << "Failed to save Phasor IR to: " << m_args.outputFile << "\n";
			return 1;
		}

		std::cout << "Compiled successfully to IR: " << m_args.inputFile << " -> " << m_args.outputFile << "\n";
		return 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Compilation Error: " << e.what() << "\n";
		return 1;
	}
}

void Compiler::parseArguments(int argc, char *argv[])
{
	int defaultArgLocation = 1;
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "--no-logo")
		{
			m_args.showLogo = false;
		}
		else if (arg == "-o" || arg == "--output")
		{
			if (i + 1 < argc)
			{
				m_args.outputFile = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				exit(1);
			}
		}
		else if (arg == "-i" || arg == "--ir")
		{
			m_args.irMode = true;
		}
		else if (arg == "-h" || arg == "--help")
		{
			showHelp(argv[0]);
			exit(0);
		}
		else
		{
			defaultArgLocation = i;
			m_args.inputFile = arg;
			break; // Stop parsing after finding the input file
		}
	}
	m_args.scriptArgv = argv + defaultArgLocation;
	m_args.scriptArgc = argc - defaultArgLocation;
}

void Compiler::showHelp(const std::string &programName)
{
	std::string filename = std::filesystem::path(programName).filename().string();
	std::cout << "Phasor Compiler\n\n";
	std::cout << "Usage:\n";
	std::cout << "  " << filename << " [options] <file.phs>\n\n";
	std::cout << "Options:\n";
	std::cout << "  -o, --output FILE   Specify output file\n";
	std::cout << "  -i, --ir            Compile to IR format (.phir) instead of bytecode\n";
	std::cout << "  -v, --verbose       Enable verbose output\n";
	std::cout << "  -h, --help          Show this help message\n";
}

} // namespace Phasor


--- .\src\Compiler\Phasor\Compiler.hpp ---
#pragma once

#include <string>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class Compiler
 * @brief CLI wrapper for bytecode generation from Phasor source
 *
 * Compiles Phasor source files to bytecode using the methods provided.
 */
class Compiler
{
  public:
	Compiler(int argc, char *argv[], char *envp[]);
	int run();

  private:
	struct Args
	{
		std::string inputFile;
		std::string outputFile;
		bool        showLogo = true;
		bool        verbose = false;
		bool        irMode = false;
		int         scriptArgc = 0;
		char      **scriptArgv = nullptr;
		char      **envp = nullptr;
	} m_args;

	void parseArguments(int argc, char *argv[]);
	void showHelp(const std::string &programName);

	int compileToBytecode();
	int compileToIR();
};

} // namespace Phasor


--- .\src\Compiler\Phasor\CppCompiler.cpp ---
#include "CppCompiler.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Codegen/Cpp/CppCodeGenerator.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

namespace Phasor
{

CppCompiler::CppCompiler(int argc, char *argv[])
{
	parseArguments(argc, argv);
}

int CppCompiler::run()
{
	if (!m_args.noLogo)
	{
		std::cout << "Phasor C++ Code Generator\n";
		std::cout << "Copyright (c) 2026 Daniel McGuire\n";
		std::cout << "\n";
	}
	if (m_args.showHelp)
	{
		showHelp("phasornative");
		return 0;
	}

	if (m_args.inputFile.empty() && !(m_args.headerOnly || m_args.generateOnly))
	{
		std::cerr << "Error: No input file provided\n";
		std::cerr << "Use --help for usage information\n";
		return 1;
	}

	if (m_args.mainFile.empty() && !m_args.headerOnly)
#ifdef _WIN32
		m_args.mainFile = "C:\\Program Files\\Phasor VM\\Development\\nativestub.cpp";
#else
		m_args.mainFile = "/usr/local/share/phasor/dev/nativestub.cpp";
#endif

	if (m_args.moduleName.empty())
	{
		std::filesystem::path inputPath(m_args.inputFile);
		m_args.moduleName = inputPath.stem().string();
	}

	// Default output file if not specified
	if (m_args.outputFile.empty())
	{
#ifdef _WIN32
		m_args.outputFile = m_args.moduleName + ".exe";
#else
		m_args.outputFile = m_args.moduleName;
#endif
	}

	if (m_args.verbose)
	{
		std::cout << "Input file: " << m_args.inputFile << "\n";
		std::cout << "Output file: " << m_args.outputFile << "\n";
		if (!m_args.moduleName.empty())
			std::cout << "Module name: " << m_args.moduleName << "\n";
	}

	if (m_args.headerOnly)
	{
		generateHeader(m_args.inputFile, m_args.outputFile);
		return 0;
	}

	if (m_args.generateOnly)
	{
		generateHeader(m_args.inputFile, m_args.moduleName + ".h");
		generateSource(m_args.moduleName + ".h", m_args.outputFile);
		return 0;
	}

	if (m_args.objectOnly)
	{
		generateHeader(m_args.inputFile, m_args.moduleName + ".h");
		generateSource(m_args.moduleName + ".h", m_args.moduleName + ".cpp");
		compileSource(m_args.moduleName + ".cpp", m_args.outputFile);
		return 0;
	}

	std::cout << "Generating wrapper...\n";

	if (generateHeader(m_args.inputFile, m_args.moduleName + ".h"))
		std::cout << m_args.inputFile << " -> " << m_args.moduleName + ".h\n";
	else
	{
		std::cerr << "Error: Could not generate header file\n";
		return 1;
	}

	if (generateSource(m_args.mainFile, m_args.moduleName + ".cpp"))
		std::cout << m_args.mainFile.filename() << " -> " << m_args.moduleName + ".cpp\n\n";
	else
	{
		std::cerr << "Could not generate source file\n";
		return 1;
	}

	std::cout << "Compiling...\n";
	std::cout << "[COMPILER] ";
	if (compileSource(m_args.moduleName + ".cpp", m_args.moduleName + ".obj"))
		std::cout << m_args.moduleName + ".cpp -> " << m_args.moduleName + ".obj\n\n";
	else
	{
		std::cerr << "Could not compile program\n";
		return 1;
	}

	std::cout << "Linking...\n";
	std::cout << "[LINKER] ";
	if (linkObject(m_args.moduleName + ".obj", m_args.outputFile))
		std::cout << m_args.moduleName + ".obj -> " << m_args.outputFile << "\n";
	else
	{
		std::cerr << "Could not link program\n";
		return 1;
	}

	return 0;
}

bool CppCompiler::parseArguments(int argc, char *argv[])
{
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-h" || arg == "--help")
		{
			m_args.showHelp = true;
			return true;
		}
		else if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "-o" || arg == "--output")
		{
			if (i + 1 < argc)
			{
				m_args.outputFile = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				m_args.showHelp = true;
				return true;
			}
		}
		else if (arg == "-n" || arg == "--nologo")
		{
			m_args.noLogo = true;
		}
		else if (arg == "-H" || arg == "--header-only")
		{
			m_args.headerOnly = true;
		}
		else if (arg == "-g" || arg == "--generate-only")
		{
			m_args.generateOnly = true;
		}
		else if (arg == "-O" || arg == "--object-only")
		{
			m_args.objectOnly = true;
		}
		else if (arg == "-m" || arg == "--module")
		{
			if (i + 1 < argc)
			{
				m_args.moduleName = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				m_args.showHelp = true;
				return true;
			}
		}
		else if (arg == "-c" || arg == "--compiler")
		{
			if (i + 1 < argc)
			{
				m_args.compiler = argv[++i];
				if (m_args.compiler == "cl" && m_args.linker.empty())
				{
					m_args.linker = "link";
				}
				else if ((m_args.compiler == "clang" || m_args.compiler == "clang++") && m_args.linker.empty())
				{
					m_args.linker = "clang";
				}
				else if ((m_args.compiler == "gcc" || m_args.compiler == "g++") && m_args.linker.empty())
				{
					m_args.linker = "gcc";
				}
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				m_args.showHelp = true;
				return true;
			}
		}
		else if (arg == "-l" || arg == "--linker")
		{
			if (i + 1 < argc)
			{
				m_args.linker = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				m_args.showHelp = true;
				return true;
			}
		}
		else if (arg == "-s" || arg == "--source")
		{
			m_args.mainFile = argv[++i];
		}
		else if (arg[0] == '-')
		{
			std::cerr << "Error: Unknown option: " << arg << "\n";
			m_args.showHelp = true;
			return true;
		}
		else
		{
			// First non-option argument is the input file
			if (m_args.inputFile.empty())
				m_args.inputFile = arg;
			else
			{
				std::cerr << "Error: Multiple input files specified\n";
				m_args.showHelp = true;
				return true;
			}
		}
	}
	return false;
}

bool CppCompiler::showHelp(const std::string &programName)
{
	std::cout << "Usage:\n";
	std::cout << "  " << programName << " [options] <input.phs>\n\n";
	std::cout << "Options:\n";
	std::cout << "  -c, --compiler <name>   Compiler to use (default: g++)\n";
	std::cout << "  -l, --linker <name>     Linker to use (default: g++)\n";
	std::cout << "  -s, --source <name>     The source file to compile with\n";
	std::cout << "  -o, --output <file>   Output file\n";
	std::cout << "  -m, --module <name>   Module name for generated code (default: input filename)\n";
	std::cout << "  -H, --header-only     Generate header file only\n";
	std::cout << "  -g, --generate-only   Generate source file only\n";
	std::cout << "  -O, --object-only     Generate and compile to object only\n";
	std::cout << "  -v, --verbose         Enable verbose output\n";
	std::cout << "  -h, --help            Show this help message\n";
	std::cout << "  -n, --nologo          Do not show banner\n\n";
	std::cout << "Example:\n";
	std::cout << "  " << programName << " program.phs -o program.exe -c clang++ -l lld\n";
	std::cout << "  " << programName << " -O program.phs -o program.obj -c clang++\n";
	std::cout << "  " << programName << " -H program.phs -o program.hpp\n";
	std::cout << "  " << programName << " -g program.phs -o program.cpp\n";
	return true;
}

bool CppCompiler::generateHeader(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath)
{
	try
	{
		Bytecode bytecode;
		if (sourcePath.extension() == ".phir")
		{
			PhasorIR phasorIR;
			bytecode = phasorIR.loadFromFile(sourcePath);
		}
		else
		{
			// Read source file
			if (m_args.verbose)
				std::cout << "Reading source file...\n";

			std::ifstream file(sourcePath);
			if (!file.is_open())
			{
				std::cerr << "Error: Could not open input file: " << sourcePath << "\n";
				return false;
			}

			std::stringstream buffer;
			buffer << file.rdbuf();
			std::string source = buffer.str();
			file.close();

			// Lex
			if (m_args.verbose)
				std::cout << "Lexing...\n";

			Lexer lexer(source);
			auto  tokens = lexer.tokenize();

			// Parse
			if (m_args.verbose)
				std::cout << "Parsing...\n";

			Parser parser(tokens);
			auto   program = parser.parse();

			// Generate bytecode
			if (m_args.verbose)
				std::cout << "Generating bytecode...\n";

			CodeGenerator codegen;
			bytecode = codegen.generate(*program);
		}

		if (bytecode.instructions.empty())
		{
			std::cerr << "Error: No instructions generated\n";
			return false;
		}

		if (m_args.verbose)
		{
			std::cout << "Bytecode statistics:\n";
			std::cout << "  Instructions: " << bytecode.instructions.size() << "\n";
			std::cout << "  Constants: " << bytecode.constants.size() << "\n";
			std::cout << "  Variables: " << bytecode.variables.size() << "\n";
			std::cout << "  Functions: " << bytecode.functionEntries.size() << "\n";
		}

		// Generate C++ code
		if (m_args.verbose)
			std::cout << "Generating C++ code...\n";

		CppCodeGenerator cppGen;
		bool             success = cppGen.generate(bytecode, outputPath, m_args.moduleName);

		if (!success)
		{
			std::cerr << "Error: Failed to generate C++ code\n";
			return false;
		}

		if (m_args.verbose)
			std::cout << "Successfully generated: " << outputPath << "\n";
	}
	catch (const std::exception &e)
	{
		std::cerr << "Compilation Error: " << e.what() << "\n";
		return false;
	}
	return true;
}

bool CppCompiler::generateSource(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath)
{
	std::ifstream file(sourcePath);
	if (!file.is_open())
	{
		std::cerr << "Error: Could not open input file: " << sourcePath << "\n";
		return false;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();
	file.close();

	std::ofstream outputFile(outputPath);
	if (!outputFile.is_open())
	{
		std::cerr << "Error: Could not open output file: " << outputPath << "\n";
		return false;
	}

	// Include the generated header file (which is the output filename with .h extension)
	std::filesystem::path headerPath = outputPath;
	headerPath.replace_extension(".h");

	outputFile << "#include \"" << headerPath.filename().string() << "\"\n";
	outputFile << source;
	outputFile.close();

	return true;
}

bool CppCompiler::compileSource(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath)
{
	std::vector<std::string> flags;
	if (m_args.compiler == "cl")
		flags = {"/std:c++20", "/Ox", "/D",    "NDEBUG", "/MD",     "/GL", "/Gy-",
		         "/GS-",       "/Gw", "/EHsc", "/WX-",   "/nologo", "/c",  ("/Fo" + outputPath.string())};
	else if (m_args.compiler == "g++" || m_args.compiler == "clang++")
		flags = {"-std=c++20",
		         "-O3",
		         "-DNDEBUG",
		         "-fPIC",
		         "-flto",
		         "-fno-function-sections",
		         "-fno-stack-protector",
		         "-fwhole-program",
		         "-fexceptions",
		         "-Wno-error",
		         "-c",
		         ("-o" + outputPath.string())};

	else
	{
		std::cerr << "Error: Unknown compiler: " << m_args.compiler << "\n";
		return false;
	}

	std::string command = m_args.compiler;
	for (const auto &flag : flags)
	{
		command += " " + flag;
	}

	command += " " + sourcePath.string();
	if (std::system(command.c_str()) != 0)
	{
		std::cerr << "Error: Compilation failed\n";
		return false;
	}

	return true;
}

bool CppCompiler::linkObject(const std::filesystem::path &objectPath, const std::filesystem::path &outputPath)
{
	std::string command = m_args.linker;
	command += " " + objectPath.string();
	if (m_args.linker == "link")
		command += " /NOLOGO /LTCG /OPT:REF /OPT:ICF /INCREMENTAL:NO /out:" + outputPath.string();
	else if (m_args.linker == "ld" || m_args.linker == "clang++" || m_args.linker == "clang")
		command += "-flto -pthread -Wl,--gc-sections -o " + outputPath.string();
	else
	{
		std::cerr << "Error: Unknown linker: " << m_args.linker << "\n";
		return false;
	}
	return (std::system(command.c_str()) == 0);
}

} // namespace Phasor


--- .\src\Compiler\Phasor\CppCompiler.hpp ---
#pragma once

#include <string>
#include <filesystem>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class CppCompiler
 * @brief CLI wrapper for C++ code generation from Phasor source
 *
 * Compiles Phasor source files to C++ source files that embed bytecode
 * and link against the phasor-runtime DLL.
 */
class CppCompiler
{
  public:
	CppCompiler(int argc, char *argv[]);
	int run();

  private:
	struct Args
	{
		std::filesystem::path inputFile;
		std::filesystem::path outputFile;
		std::filesystem::path mainFile;
		std::string           moduleName;
		bool                  verbose = false;
		bool                  showHelp = false;
		std::string           compiler;
		std::string           linker;
		bool                  run = false;
		bool                  headerOnly = false;
		bool                  objectOnly = false;
		bool                  generateOnly = false;
		bool                  noLogo = false;
	} m_args;

	bool parseArguments(int argc, char *argv[]);
	bool showHelp(const std::string &programName);
	bool generateHeader(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath);
	bool generateSource(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath);
	bool compileSource(const std::filesystem::path &sourcePath, const std::filesystem::path &outputPath);
	bool linkObject(const std::filesystem::path &objectPath, const std::filesystem::path &outputPath);
};

} // namespace Phasor


--- .\src\Compiler\Pulsar\Compiler.cpp ---
#include "Compiler.hpp"
#include "../../Language/Pulsar/Lexer/Lexer.hpp"
#include "../../Language/Pulsar/Parser/Parser.hpp"
#include "../../Codegen/Bytecode/BytecodeSerializer.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

namespace pulsar
{

Compiler::Compiler(int argc, char *argv[], char *envp[])
{
	m_args.envp = envp;
	parseArguments(argc, argv);
}

int Compiler::run()
{
	if (m_args.showLogo)
		std::cout << "Pulsar Compiler\n(C) 2026 Daniel McGuire\n\n";
	if (m_args.inputFile.empty())
	{
		std::cerr << "Error: No input file provided\n";
		return 1;
	}

	if (m_args.irMode)
		return compileToIR();

	return compileToBytecode();
}

int Compiler::compileToBytecode()
{
	if (std::filesystem::path(m_args.inputFile).extension() == ".phsb")
	{
		std::cerr << "Error: Cannot compile a bytecode file\n";
		return 1;
	}

	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		Lexer         lexer(source);
		Parser        parser(lexer.tokenize());
		auto          program = parser.parse();
		CodeGenerator codegen;
		auto          bytecode = codegen.generate(*program);

		if (m_args.outputFile.empty())
		{
			m_args.outputFile = m_args.inputFile;
			std::filesystem::path path(m_args.outputFile);
			path.replace_extension(".phsb");
			m_args.outputFile = path.string();
		}

		BytecodeSerializer serializer;
		if (!serializer.saveToFile(bytecode, m_args.outputFile))
		{
			std::cerr << "Failed to save bytecode to: " << m_args.outputFile << "\n";
			return 1;
		}

		if (m_args.showLogo)
			std::cout << "Compiled successfully: " << m_args.inputFile << " -> " << m_args.outputFile << "\n";
		return 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Compilation Error: " << e.what() << "\n";
		return 1;
	}
}

int Compiler::compileToIR()
{
	if (std::filesystem::path(m_args.inputFile).extension() == ".phir")
	{
		std::cerr << "Error: Cannot compile a Phasor IR file\n";
		return 1;
	}

	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		Lexer         lexer(source);
		Parser        parser(lexer.tokenize());
		auto          program = parser.parse();
		CodeGenerator codegen;
		auto          bytecode = codegen.generate(*program);

		if (m_args.outputFile.empty())
		{
			m_args.outputFile = m_args.inputFile;
			std::filesystem::path path(m_args.outputFile);
			path.replace_extension(".phir");
			m_args.outputFile = path.string();
		}

		if (!PhasorIR::saveToFile(bytecode, m_args.outputFile))
		{
			std::cerr << "Failed to save Phasor IR to: " << m_args.outputFile << "\n";
			return 1;
		}

		std::cout << "Compiled successfully to IR: " << m_args.inputFile << " -> " << m_args.outputFile << "\n";
		return 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Compilation Error: " << e.what() << "\n";
		return 1;
	}
}

void Compiler::parseArguments(int argc, char *argv[])
{
	int defaultArgLocation = 1;
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "--no-logo")
		{
			m_args.showLogo = false;
		}
		else if (arg == "-o" || arg == "--output")
		{
			if (i + 1 < argc)
			{
				m_args.outputFile = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				exit(1);
			}
		}
		else if (arg == "-i" || arg == "--ir")
		{
			m_args.irMode = true;
		}
		else if (arg == "-h" || arg == "--help")
		{
			showHelp(argv[0]);
			exit(0);
		}
		else
		{
			defaultArgLocation = i;
			m_args.inputFile = arg;
			break; // Stop parsing after finding the input file
		}
	}
	m_args.scriptArgv = argv + defaultArgLocation;
	m_args.scriptArgc = argc - defaultArgLocation;
}

void Compiler::showHelp(const std::string &programName)
{
	std::string filename = std::filesystem::path(programName).filename().string();
	std::cout << "Pulsar Compiler\n\n";
	std::cout << "Usage:\n";
	std::cout << "  " << filename << " [options] <file>\n\n";
	std::cout << "Options:\n";
	std::cout << "  -o, --output FILE   Specify output file\n";
	std::cout << "  -i, --ir            Compile to IR format (.phir) instead of bytecode\n";
	std::cout << "  -v, --verbose       Enable verbose output\n";
	std::cout << "  -h, --help          Show this help message\n";
}

} // namespace pulsar


--- .\src\Compiler\Pulsar\Compiler.hpp ---
#pragma once

#include <string>
#include <vector>
/// @brief The Pulsar Scripting Language
namespace pulsar
{

/**
 * @class Compiler
 * @brief CLI wrapper for bytecode generation from Phasor source
 *
 * Compiles Phasor source files to bytecode using the methods provided.
 */
class Compiler
{
  public:
	Compiler(int argc, char *argv[], char *envp[]);
	int run();

  private:
	struct Args
	{
		std::string inputFile;
		std::string outputFile;
		bool        showLogo = true;
		bool        verbose = false;
		bool        irMode = false;
		int         scriptArgc = 0;
		char      **scriptArgv = nullptr;
		char      **envp = nullptr;
	} m_args;

	void parseArguments(int argc, char *argv[]);
	void showHelp(const std::string &programName);

	int compileToBytecode();
	int compileToIR();
};

} // namespace pulsar


--- .\src\Compiler\Shared\Disassembler.cpp ---
﻿#include "../../Codegen/Bytecode/BytecodeDeserializer.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"

#include "Disassembler.hpp"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

namespace Phasor
{

Disassembler::Disassembler(int argc, char *argv[])
{
	parseArguments(argc, argv);
}

int Disassembler::run()
{
	if (!m_args.noLogo)
	{
		std::cout << "Phasor Decompiler\n";
		std::cout << "Copyright (c) 2026 Daniel McGuire\n";
		std::cout << "\n";
	}
	if (m_args.showHelp)
	{
		showHelp();
		return 0;
	}

	return (int)!decompileBinary();
}

bool Disassembler::parseArguments(int argc, char *argv[])
{
	m_args.program = std::filesystem::path(argv[0]);
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-h" || arg == "--help")
		{
			m_args.showHelp = true;
			return true;
		}
		else if (arg == "-o" || arg == "--output")
		{
			if (i + 1 < argc)
			{
				m_args.outputFile = argv[++i];
			}
			else
			{
				std::cerr << "Error: " << arg << " requires an argument\n";
				m_args.showHelp = true;
				return true;
			}
		}
		else if (arg == "-n" || arg == "--nologo")
		{
			m_args.noLogo = true;
		}
		else if (arg[0] == '-')
		{
			std::cerr << "Error: Unknown option: " << arg << "\n";
			m_args.showHelp = true;
			return true;
		}
		else
		{
			if (m_args.inputFile.empty())
				m_args.inputFile = arg;
			else
			{
				std::cerr << "Error: Multiple input files specified\n";
				m_args.showHelp = true;
				return true;
			}
		}
	}
	return false;
}

bool Disassembler::showHelp()
{
	std::cout << "Usage:\n";
	std::cout << "  " << m_args.program.stem().string() << " [options] <input.phsb>\n\n";
	std::cout << "Options:\n";
	std::cout << "  -o, --output <file>   Output file\n";
	std::cout << "  -h, --help            Show this help message\n";
	std::cout << "  -n, --nologo          Do not show banner\n\n";
	return true;
}

bool Disassembler::decompileBinary()
{
	BytecodeDeserializer bcDeserializer{};
	PhasorIR             phir;

	if (m_args.outputFile.empty())
	{
		m_args.outputFile = m_args.inputFile;
		std::filesystem::path path(m_args.outputFile);
		path.replace_extension(".phir");
		m_args.outputFile = path.string();
	}

	return phir.saveToFile(bcDeserializer.loadFromFile(m_args.inputFile), m_args.outputFile);
}

} // namespace Phasor


--- .\src\Compiler\Shared\Disassembler.hpp ---
#pragma once

#include <string>
#include <filesystem>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class Disassembler
 * @brief CLI wrapper for dissassembling Phasor binaries
 */
class Disassembler
{
  public:
	Disassembler(int argc, char *argv[]);
	int run();

  private:
	struct Args
	{
		std::filesystem::path inputFile;
		std::filesystem::path outputFile;
		std::filesystem::path program;
		bool                  noLogo = false;
		bool                  showHelp = false;
	} m_args;

	bool       parseArguments(int argc, char *argv[]);
	bool showHelp();
	bool decompileBinary();
};

} // namespace Phasor


--- .\src\Executable\Bindings\posix\main.c ---
#define PHASOR_FFI_BUILD_DLL
#include <PhasorFFI.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>
#include <signal.h>
#include <time.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <string.h>

// -----------------
// File I/O Wrappers
// -----------------
static PhasorValue phasor_open(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_string(argv[0]) || !phasor_is_int(argv[1]))
		return phasor_make_int(-1);
	const char *path = phasor_to_string(argv[0]);
	int         flags = (int)phasor_to_int(argv[1]);
	int         fd = open(path, flags, 0666);
	return phasor_make_int(fd);
}

static PhasorValue phasor_close(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_int(argv[0]))
		return phasor_make_int(-1);
	int fd = (int)phasor_to_int(argv[0]);
	return phasor_make_int(close(fd));
}

static PhasorValue phasor_read(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_int(argv[0]) || !phasor_is_int(argv[1]))
		return phasor_make_string("");
	int    fd = (int)phasor_to_int(argv[0]);
	size_t count = (size_t)phasor_to_int(argv[1]);
	char  *buf = (char *)malloc(count + 1);
	if (!buf)
		return phasor_make_string("");
	ssize_t r = read(fd, buf, count);
	if (r >= 0)
		buf[r] = '\0';
	else
		buf[0] = '\0';
	PhasorValue val = phasor_make_string(buf);
	free(buf);
	return val;
}

static PhasorValue phasor_write(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_int(argv[0]) || !phasor_is_string(argv[1]))
		return phasor_make_int(-1);
	int         fd = (int)phasor_to_int(argv[0]);
	const char *s = phasor_to_string(argv[1]);
	ssize_t     r = write(fd, s, strlen(s));
	return phasor_make_int(r);
}

static PhasorValue phasor_unlink(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_string(argv[0]))
		return phasor_make_int(-1);
	return phasor_make_int(unlink(phasor_to_string(argv[0])));
}

// -----------------
// Directory Wrappers
// -----------------
static PhasorValue phasor_mkdir(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_string(argv[0]))
		return phasor_make_int(-1);
	const char *path = phasor_to_string(argv[0]);
	return phasor_make_int(mkdir(path, 0777));
}

static PhasorValue phasor_rmdir(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_string(argv[0]))
		return phasor_make_int(-1);
	return phasor_make_int(rmdir(phasor_to_string(argv[0])));
}

// -----------------
// Process Wrappers
// -----------------
static PhasorValue phasor_fork(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	pid_t pid = fork();
	return phasor_make_int((int64_t)pid);
}

static PhasorValue phasor_execve(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 3 || !phasor_is_string(argv[0]) || !phasor_is_array(argv[1]) || !phasor_is_array(argv[2]))
	{
		return phasor_make_int(-1);
	}
	const char        *path = phasor_to_string(argv[0]);
	const PhasorValue *argarr = argv[1].as.a.elements;
	size_t             argcnt = argv[1].as.a.count;
	const PhasorValue *envarr = argv[2].as.a.elements;
	size_t             envcnt = argv[2].as.a.count;

	char **args = (char **)malloc((argcnt + 1) * sizeof(char *));
	char **envs = (char **)malloc((envcnt + 1) * sizeof(char *));
	for (size_t i = 0; i < argcnt; i++)
		args[i] = (char *)phasor_to_string(argarr[i]);
	args[argcnt] = NULL;
	for (size_t i = 0; i < envcnt; i++)
		envs[i] = (char *)phasor_to_string(envarr[i]);
	envs[envcnt] = NULL;

	int r = execve(path, args, envs);
	free(args);
	free(envs);
	return phasor_make_int(r); // will only return on error
}

static PhasorValue phasor_waitpid(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_int(argv[0]) || !phasor_is_int(argv[1]))
		return phasor_make_int(-1);
	pid_t pid = (pid_t)phasor_to_int(argv[0]);
	int   options = (int)phasor_to_int(argv[1]);
	int   status = 0;
	pid_t r = waitpid(pid, &status, options);
	return phasor_make_array((PhasorValue[]){phasor_make_int(r), phasor_make_int(status)}, 2);
}

// -----------------
// Signal Wrappers
// -----------------
static PhasorValue phasor_kill(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_int(argv[0]) || !phasor_is_int(argv[1]))
		return phasor_make_int(-1);
	pid_t pid = (pid_t)phasor_to_int(argv[0]);
	int   sig = (int)phasor_to_int(argv[1]);
	return phasor_make_int(kill(pid, sig));
}

// -----------------
// Time Wrappers
// -----------------
static PhasorValue phasor_sleep(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_int(argv[0]))
		return phasor_make_int(-1);
	unsigned int sec = (unsigned int)phasor_to_int(argv[0]);
	unsigned int r = sleep(sec);
	return phasor_make_int(r);
}

static PhasorValue phasor_nanosleep(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 2 || !phasor_is_int(argv[0]) || !phasor_is_int(argv[1]))
		return phasor_make_int(-1);
	struct timespec req = {(time_t)phasor_to_int(argv[0]), (long)phasor_to_int(argv[1])};
	struct timespec rem;
	int             r = nanosleep(&req, &rem);
	return phasor_make_int(r);
}

static PhasorValue phasor_clock_gettime(PhasorVM *vm, int argc, const PhasorValue *argv)
{
	if (argc < 1 || !phasor_is_int(argv[0]))
		return phasor_make_int(-1);
	struct timespec ts;
	int             r = clock_gettime((clockid_t)phasor_to_int(argv[0]), &ts);
	PhasorValue     vals[2] = {phasor_make_int(ts.tv_sec), phasor_make_int(ts.tv_nsec)};
	return phasor_make_array(vals, 2);
}

// -----------------
// Plugin Entry
// -----------------
PHASOR_FFI_EXPORT void phasor_plugin_entry(const PhasorAPI *api, PhasorVM *vm)
{
	api->register_function(vm, "posix_open", phasor_open);
	api->register_function(vm, "posix_close", phasor_close);
	api->register_function(vm, "posix_read", phasor_read);
	api->register_function(vm, "posix_write", phasor_write);
	api->register_function(vm, "posix_unlink", phasor_unlink);

	api->register_function(vm, "posix_mkdir", phasor_mkdir);
	api->register_function(vm, "posix_rmdir", phasor_rmdir);

	api->register_function(vm, "posix_fork", phasor_fork);
	api->register_function(vm, "posix_execve", phasor_execve);
	api->register_function(vm, "posix_waitpid", phasor_waitpid);

	api->register_function(vm, "posix_kill", phasor_kill);

	api->register_function(vm, "posix_sleep", phasor_sleep);
	api->register_function(vm, "posix_nanosleep", phasor_nanosleep);
	api->register_function(vm, "posix_clock_gettime", phasor_clock_gettime);
}


--- .\src\Executable\Bindings\win32\bindgen_main.cpp ---
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include <algorithm>

const std::vector<std::string> PATCHES = {"#pragma warning(disable:4996)", "#pragma warning(disable:4244)"};

struct Param
{
	std::string type;
	std::string name;
};

struct Function
{
	std::string        returnType;
	std::string        name;
	std::vector<Param> params;
	std::string        rawLine;
	int                lineNumber = 0;
};

bool isHandleType(const std::string &type)
{
	return type == "HANDLE" || type == "HMODULE" || type == "HWND" || type == "HINSTANCE" || type == "HDC";
}

bool isSupportedParam(const std::string &type)
{
	if (isHandleType(type))
		return true;

	std::string t = type;
	t.erase(std::remove(t.begin(), t.end(), ' '), t.end());
	return t == "BOOL" || t == "DWORD" || t == "int" || t == "LONG" || t == "UINT" || t == "ULONG" || t == "float" ||
	       t == "double" || t == "LPCSTR" || t == "LPSTR" || t == "constchar*" || t == "LPCWSTR" || t == "LPWSTR" ||
	       t == "constwchar_t*";
}

std::string trim(const std::string &str)
{
	size_t start = str.find_first_not_of(" \t\r\n");
	if (start == std::string::npos)
		return "";
	size_t end = str.find_last_not_of(" \t\r\n");
	return str.substr(start, end - start + 1);
}

Function parseFunction(const std::string &line, int lineNumber)
{
	Function f;
	f.rawLine = line;
	f.lineNumber = lineNumber;

	std::string clean = line;
	clean.erase(std::remove(clean.begin(), clean.end(), ';'), clean.end());

	size_t paren = clean.find('(');
	if (paren == std::string::npos)
		return f;

	std::string retAndName = clean.substr(0, paren);
	std::string paramStr = clean.substr(paren + 1, clean.find(')') - paren - 1);

	std::istringstream iss(retAndName);
	iss >> f.returnType >> f.name;

	paramStr = trim(paramStr);
	if (paramStr.empty() || paramStr == "void")
		return f;

	std::istringstream pstream(paramStr);
	std::string        param;
	while (std::getline(pstream, param, ','))
	{
		param = trim(param);
		if (param.empty())
			continue;

		std::istringstream ps(param);
		Param              p;
		ps >> p.type >> p.name;

		if (!isSupportedParam(p.type))
		{
			f.returnType.clear();
			break;
		}

		f.params.push_back(p);
	}

	return f;
}

void generateWrapper(const Function &f, std::ostream &out)
{
	if (f.returnType.empty())
		return;

	out << "// " << f.rawLine << " @ln:" << f.lineNumber << "\n";
	out << "static PhasorValue win32_" << f.name << "(PhasorVM* vm, int argc, const PhasorValue* argv) {\n";

	for (size_t i = 0; i < f.params.size(); ++i)
	{
		const auto &p = f.params[i];

		if (isHandleType(p.type))
		{
			out << "    " << p.type << " " << p.name << " = HandleSystem::resolve<" << p.type << ">(phasor_to_int(argv["
			    << i << "]));\n";
			continue;
		}

		std::string conv;
		if (p.type == "BOOL")
			conv = "phasor_to_bool(argv[" + std::to_string(i) + "])";
		else if (p.type == "DWORD" || p.type == "int" || p.type == "LONG" || p.type == "UINT" || p.type == "ULONG")
			conv = "(" + p.type + ")phasor_to_int(argv[" + std::to_string(i) + "])";
		else if (p.type == "float" || p.type == "double")
			conv = "(" + p.type + ")phasor_to_float(argv[" + std::to_string(i) + "])";
		else if (p.type == "LPCSTR" || p.type == "constchar*")
			conv = "(const char*)phasor_to_string(argv[" + std::to_string(i) + "])";
		else if (p.type == "LPSTR")
			conv = "(char*)phasor_to_string(argv[" + std::to_string(i) + "])";
		else if (p.type == "LPCWSTR" || p.type == "constwchar_t*")
			conv = "(const wchar_t*)phasor_to_string(argv[" + std::to_string(i) + "])";
		else
			conv = "(wchar_t*)phasor_to_string(argv[" + std::to_string(i) + "])";

		out << "    " << p.type << " " << p.name << " = " << conv << ";\n";
	}

	out << "    auto result = " << f.name << "(";
	for (size_t i = 0; i < f.params.size(); ++i)
	{
		if (i)
			out << ", ";
		out << f.params[i].name;
	}
	out << ");\n";

	if (isHandleType(f.returnType))
	{
		out << "    auto id = HandleSystem::store(result);\n";
		out << "    return phasor_make_int(id);\n";
	}
	else if (f.returnType == "BOOL")
		out << "    return phasor_make_bool(result);\n";
	else if (f.returnType == "float" || f.returnType == "double")
		out << "    return phasor_make_float(result);\n";
	else if (f.returnType == "DWORD" || f.returnType == "int" || f.returnType == "LONG" || f.returnType == "UINT" ||
	         f.returnType == "ULONG")
		out << "    return phasor_make_int(result);\n";
	else
		out << "    return phasor_make_null();\n";

	out << "}\n\n";
}

int main(int argc, char **argv)
{
	std::string inputFile = "winapi.h";
	std::string outputFile = "phasor_winapi.cpp";

	if (argc >= 2)
		inputFile = argv[1];
	if (argc >= 4 && std::string(argv[2]) == "-o")
		outputFile = argv[3];

	std::ifstream infile(inputFile);
	std::ofstream outfile(outputFile);

	outfile << "#define PHASOR_FFI_BUILD_DLL\n";
	outfile << "#include <PhasorFFI.h>\n";
	outfile << "#include <windows.h>\n";
	outfile << "#include \"../src/Bindings/win32/handle.hpp\"\n\n";
	outfile << "// =====BEGIN PATCHES=====\n";
	for (const auto &patch : PATCHES)
	{
		outfile << patch << "\n";
	}
	outfile << "// ======END PATCHES======\n\n";

	std::string           line;
	int                   lineNumber = 0;
	std::vector<Function> funcs;

	while (std::getline(infile, line))
	{
		lineNumber++;
		if (line.empty())
			continue;

		Function f = parseFunction(line, lineNumber);
		if (!f.returnType.empty())
			funcs.push_back(f);
	}

	for (const auto &f : funcs)
		generateWrapper(f, outfile);

	outfile << "PHASOR_FFI_EXPORT void phasor_plugin_entry(const PhasorAPI* api, PhasorVM* vm) {\n";
	for (const auto &f : funcs)
	{
		outfile << "    api->register_function(vm, \"win32_" << f.name << "\", win32_" << f.name << ");\n";
	}
	outfile << "}\n";
}


--- .\src\Executable\Bindings\win32\main.rc ---
#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor win32 Bindings"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "winapi_phs.dll"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END




--- .\src\Executable\CMakeLists.txt ---
add_library(phasor_native_runtime SHARED
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Phasor/NativeRuntimeDll.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Phasor/NativeRuntime_library.cpp
    ${CMAKE_SOURCE_DIR}/include/PhasorRT.h
)
target_link_libraries(phasor_native_runtime phasor_native_runtime_lib)
target_compile_definitions(phasor_native_runtime PRIVATE _SHARED)
set_target_properties(phasor_native_runtime PROPERTIES OUTPUT_NAME phasorrt)

add_library(phasor_native_runtime_static STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Phasor/NativeRuntime_library.cpp
    ${CMAKE_SOURCE_DIR}/include/PhasorRT.h
)
target_link_libraries(phasor_native_runtime_static phasor_native_runtime_lib)
set_target_properties(phasor_native_runtime_static PROPERTIES OUTPUT_NAME phasorstaticrt)

add_executable(phasor_main 
    ${CMAKE_CURRENT_SOURCE_DIR}/Main/Phasor/Phasor.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Main/Phasor/Phasor_main.cpp
    ${CMAKE_SOURCE_DIR}/src/Repl/Phasor/Repl.cpp
)
target_link_libraries(phasor_main phasor_scripting_runtime_lib phasor_binary_runtime_lib PhasorFrontend)
set_target_properties(phasor_main PROPERTIES OUTPUT_NAME phasor)

add_executable(pulsar_main 
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Pulsar/ScriptingRuntime.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Pulsar/ScriptingRuntime_main.cpp
)
target_link_libraries(pulsar_main pulsar_scripting_runtime_lib PulsarFrontend)
set_target_properties(pulsar_main PROPERTIES OUTPUT_NAME pulsar)

add_executable(phasor_repl
    ${CMAKE_CURRENT_SOURCE_DIR}/Repl/Phasor/Repl.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Repl/Phasor/Repl_main.cpp
)
target_link_libraries(phasor_repl phasor_repl_lib)
set_target_properties(phasor_repl PROPERTIES OUTPUT_NAME phasorrepl)

add_executable(phasor_compiler
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Phasor/Compiler.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Phasor/Compiler_main.cpp
)
target_link_libraries(phasor_compiler phasor_compiler_lib)
set_target_properties(phasor_compiler PROPERTIES OUTPUT_NAME phasorcompiler)

add_executable(pulsar_compiler
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Pulsar/Compiler.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Pulsar/Compiler_main.cpp
)
target_link_libraries(pulsar_compiler pulsar_compiler_lib)
set_target_properties(pulsar_compiler PROPERTIES OUTPUT_NAME pulsarcompiler)

add_executable(phasor_lsp
    ${CMAKE_CURRENT_SOURCE_DIR}/LSP/Phasor/LSP_main.cpp
)
target_link_libraries(phasor_lsp phasor_lsp_lib)
set_target_properties(phasor_lsp PROPERTIES OUTPUT_NAME phasor-lsp)

add_executable(phasor_disasm
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Shared/Disassembler.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Shared/Disassembler_main.cpp
)
target_link_libraries(phasor_disasm phasor_disasm_lib)
set_target_properties(phasor_disasm PROPERTIES OUTPUT_NAME phasordecomp)

add_executable(phasor_cxx_transpiler
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Phasor/CppCompiler.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Compiler/Phasor/CppCompiler_main.cpp
)
target_link_libraries(phasor_cxx_transpiler phasor_cxx_transpiler_lib)
set_target_properties(phasor_cxx_transpiler PROPERTIES OUTPUT_NAME phasornative)

add_executable(phasor_runtime_exe
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Shared/BinaryRuntime.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Shared/BinaryRuntime_main.cpp
)
target_link_libraries(phasor_runtime_exe phasor_binary_runtime_lib)
set_target_properties(phasor_runtime_exe PROPERTIES OUTPUT_NAME phasorvm)

add_executable(phasor_interpreter
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Phasor/ScriptingRuntime.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/Runtime/Phasor/ScriptingRuntime_main.cpp
)
target_link_libraries(phasor_interpreter phasor_scripting_runtime_lib PhasorFrontend)
set_target_properties(phasor_interpreter PROPERTIES OUTPUT_NAME phasorjit)

if(WIN32)
    add_executable(phasor_winapi_gen
        ${CMAKE_CURRENT_SOURCE_DIR}/Bindings/win32/bindgen_main.cpp
    )
    set_target_properties(phasor_winapi_gen PROPERTIES OUTPUT_NAME winapi-gen-phs)

    add_custom_command(
        OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/src/Executable/Bindings/win32/winapi_main.cpp
        COMMAND $<TARGET_FILE:phasor_winapi_gen> ${CMAKE_SOURCE_DIR}/scripts/winapi.h -o ${CMAKE_CURRENT_BINARY_DIR}/src/Executable/Bindings/win32/winapi_main.cpp
        DEPENDS ${CMAKE_SOURCE_DIR}/scripts/winapi.h phasor_winapi_gen
        COMMENT "Generating win32 bindings src/Executable/Bindings/win32/winapi_main.cpp"
    )

    add_library(phasor_winapi_bindings SHARED
        ${CMAKE_CURRENT_BINARY_DIR}/src/Executable/Bindings/win32/winapi_main.cpp
        ${CMAKE_SOURCE_DIR}/src/Bindings/win32/handle.hpp
        ${CMAKE_CURRENT_SOURCE_DIR}/Bindings/win32/main.rc
        ${CMAKE_SOURCE_DIR}/scripts/winapi.h
    )
    set_target_properties(phasor_winapi_bindings PROPERTIES 
        OUTPUT_NAME winapi_phs
    )
    install(TARGETS phasor_winapi_bindings RUNTIME DESTINATION ${PLUGIN_INSTALL_DIR})
else()
    add_library(phasor_posix_bindings SHARED
        ${CMAKE_CURRENT_SOURCE_DIR}/Bindings/posix/main.c
    )
    set_target_properties(phasor_posix_bindings PROPERTIES 
        OUTPUT_NAME posix_phs
    )
    install(TARGETS phasor_posix_bindings
        LIBRARY DESTINATION "${PLUGIN_INSTALL_DIR}"
        RUNTIME DESTINATION "${PLUGIN_INSTALL_DIR}"
    )
endif()

add_subdirectory(utils)

--- .\src\Executable\Compiler\Phasor\Compiler.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101


VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM Compiler"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasorcompiler.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasorcompiler.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\Compiler.ico"




--- .\src\Executable\Compiler\Phasor\Compiler_main.cpp ---
#include "../../../Compiler/Phasor/Compiler.hpp"
#include "../../../Frontend/Phasor/Frontend.hpp"
#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		Phasor::Compiler compiler(argc, argv, envp);
		return compiler.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\Compiler\Phasor\CppCompiler.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM Native Compiler"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasornative.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasornative.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\CppCompiler.ico"



--- .\src\Executable\Compiler\Phasor\CppCompiler_main.cpp ---
#include "../../../Compiler/Phasor/CppCompiler.hpp"

int main(int argc, char *argv[])
{
	Phasor::CppCompiler compiler(argc, argv);
	return compiler.run();
}


--- .\src\Executable\Compiler\Pulsar\Compiler.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101


VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Pulsar Compiler for Phasor"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "pulsarcompiler.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "pulsarcompiler.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\Compiler.ico"




--- .\src\Executable\Compiler\Pulsar\Compiler_main.cpp ---
#include "../../../Compiler/Pulsar/Compiler.hpp"
#include "../../../Frontend/Pulsar/Frontend.hpp"
#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		pulsar::Compiler compiler(argc, argv, envp);
		return compiler.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\Compiler\Shared\Disassembler.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101


VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor Bytecode Disassembler"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasordecomp.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasordecomp.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\CppCompiler.ico"




--- .\src\Executable\Compiler\Shared\Disassembler_main.cpp ---
#include "../../../Compiler/Shared/Disassembler.hpp"
#include <iostream>

int main(int argc, char *argv[])
{
	try
	{
		Phasor::Disassembler disasm(argc, argv);
		return disasm.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\LSP\Phasor\LSP_main.cpp ---
#include "../../../LSP/Phasor/LSP.hpp"
#include <json.hpp>
#include <iostream>
#include <string>
#include <stdexcept>
#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#endif

using json = nlohmann::json;

static std::string readMessage()
{
	size_t contentLength = 0;

	while (true)
	{
		std::string line;
		if (!std::getline(std::cin, line))
			return "";

		if (!line.empty() && line.back() == '\r')
			line.pop_back();

		if (line.empty())
			break;

		const std::string prefix = "Content-Length: ";
		if (line.rfind(prefix, 0) == 0)
			contentLength = std::stoull(line.substr(prefix.size()));
	}

	if (contentLength == 0)
		return "";

	std::string body(contentLength, '\0');
	std::cin.read(body.data(), static_cast<std::streamsize>(contentLength));
	return body;
}

static void writeMessage(const json &msg)
{
	const std::string body = msg.dump();
	std::cout << "Content-Length: " << body.size() << "\r\n\r\n" << body;
	std::cout.flush();
}

static json makeResponse(const json &id, json result)
{
	return {{"jsonrpc", "2.0"}, {"id", id}, {"result", std::move(result)}};
}

static json makeError(const json &id, int code, const std::string &message)
{
	return {{"jsonrpc", "2.0"}, {"id", id}, {"error", {{"code", code}, {"message", message}}}};
}

static json makeNotification(const std::string &method, json params)
{
	return {{"jsonrpc", "2.0"}, {"method", method}, {"params", std::move(params)}};
}

static void publishDiagnostics(const std::string &uri, const std::vector<Phasor::LSP::Diagnostic> &diags)
{
	json arr = json::array();
	for (const auto &d : diags)
	{
		arr.push_back({{"range",
		                {{"start", {{"line", d.startLine}, {"character", d.startColumn}}},
		                 {"end", {{"line", d.endLine}, {"character", d.endColumn}}}}},
		               {"severity", 1},
		               {"message", d.message}});
	}
	writeMessage(makeNotification("textDocument/publishDiagnostics", {{"uri", uri}, {"diagnostics", arr}}));
}

static json makePointRange(size_t line, size_t col)
{
	return {{"start", {{"line", line}, {"character", col}}}, {"end", {{"line", line}, {"character", col + 1}}}};
}

static json handleInitialize(const json &)
{
	return {{"capabilities", {
	          {"textDocumentSync", 1},
	          {"hoverProvider", true},
	          {"definitionProvider", true}}},
	        {"serverInfo", {{"name", "phasor-lsp"}, {"version", "0.1.0"}}}};
}

static json handleHover(Phasor::LSP &lsp, const json &params)
{
	const std::string uri = params["textDocument"]["uri"];
	const size_t      line = params["position"]["line"];
	const size_t      col = params["position"]["character"];

	auto text = lsp.getHover(uri, line, col);
	if (!text.has_value())
		return nullptr;

	return {{"contents",
	         {{"kind", "markdown"},
	          {"value", "```phasor\n" + *text + "\n```"}}},
	        {"range", makePointRange(line, col)}};
}

static json handleDefinition(Phasor::LSP &lsp, const json &params)
{
	const std::string uri = params["textDocument"]["uri"];
	const size_t      line = params["position"]["line"];
	const size_t      col = params["position"]["character"];

	auto loc = lsp.getDefinition(uri, line, col);
	if (!loc.has_value())
		return nullptr;

	return {{"uri", loc->uri}, {"range", makePointRange(loc->line, loc->column)}};
}

int main()
{
#ifdef _WIN32
	_setmode(_fileno(stdout), _O_BINARY);
	_setmode(_fileno(stdin), _O_BINARY);
#endif
	std::ios::sync_with_stdio(false);

	Phasor::LSP lsp;
	bool        running = true;

	while (running)
	{
		const std::string raw = readMessage();
		if (raw.empty())
			break;

		json msg;
		try
		{
			msg = json::parse(raw);
		}
		catch (const json::parse_error &e)
		{
			writeMessage(makeError(nullptr, -32700, "JSON parse error: " + std::string(e.what())));
			continue;
		}

		const bool        isRequest = msg.contains("id");
		const json        id = isRequest ? msg["id"] : json(nullptr);
		const std::string method = msg.value("method", "");
		const json       &params = msg.contains("params") ? msg["params"] : json(nullptr);

		if (method == "initialize")
		{
			writeMessage(makeResponse(id, handleInitialize(params)));
		}
		else if (method == "initialized")
		{
		}
		else if (method == "shutdown")
		{
			writeMessage(makeResponse(id, nullptr));
			running = false;
		}
		else if (method == "exit")
		{
			break;
		}

		else if (method == "textDocument/didOpen")
		{
			const std::string uri = params["textDocument"]["uri"];
			const std::string text = params["textDocument"]["text"];
			lsp.openDocument(uri, text);
			publishDiagnostics(uri, lsp.getDiagnostics(uri));
		}
		else if (method == "textDocument/didChange")
		{
			const std::string uri = params["textDocument"]["uri"];
			if (params.contains("contentChanges") && !params["contentChanges"].empty())
			{
				const std::string text = params["contentChanges"][0]["text"];
				lsp.changeDocument(uri, text);
				publishDiagnostics(uri, lsp.getDiagnostics(uri));
			}
		}
		else if (method == "textDocument/didClose")
		{
			const std::string uri = params["textDocument"]["uri"];
			lsp.closeDocument(uri);
			publishDiagnostics(uri, {});
		}

		else if (method == "textDocument/hover")
		{
			writeMessage(makeResponse(id, handleHover(lsp, params)));
		}

		else if (method == "textDocument/definition")
		{
			writeMessage(makeResponse(id, handleDefinition(lsp, params)));
		}
		else if (isRequest)
		{
			writeMessage(makeError(id, -32601, "Method not found: " + method));
		}
	}

	return 0;
}

--- .\src\Executable\Main\Phasor\Phasor.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101


VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor Language"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasor.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasor.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\phasor.ico"



--- .\src\Executable\Main\Phasor\Phasor_main.cpp ---
#include "../../../Repl/Phasor/Repl.hpp"
#include "../../../Runtime/Phasor/ScriptingRuntime.hpp"
#include "../../../Runtime/Shared/BinaryRuntime.hpp"
#include "../../../Frontend/Phasor/Frontend.hpp"
#include <iostream>
#include <string>
#include <vector>
#include <filesystem>
#include <iterator>

#ifdef _WIN32
#include <io.h>
#define IS_TERMINAL _isatty(_fileno(stdin))
#else
#include <unistd.h>
#define IS_TERMINAL isatty(fileno(stdin))
#endif

/**
 * @brief Reads all content from stdin until EOF (piped input)
 */
std::string readStdin()
{
	std::string content;
	std::string line;
	while (std::getline(std::cin, line))
	{
		content += line + "\n";
	}
	return content;
}

namespace fs = std::filesystem;

void showHelp(const fs::path &program = "phasor")
{
	const std::string programName = program.stem().string();
	std::cout << "Phasor Programming Language\n";
	std::cout << "Usage: [RAWSCRIPT] | " << programName << " [SCRIPT, BYTECODE]\n";
	std::cout << "A. PIPE:    <text> | " << programName << "\n";
	std::cout << "B. JIT/BYTECODE:     " << programName << " <file>\n";
	std::cout << "C. REPL:             " << programName << "\n\n";
	std::cout << "Example:\n";

#ifdef _WIN32
	std::cout << "A. CMD:  echo \"print(^\"Hi\\!\\n^\");\" | " << programName << "\n";
	std::cout << "A. PWSH: echo \"print(`\"Hi\\!\n`\");\" | " << programName << "\n";
	std::cout << "B.       " << programName << " hello.phs\n";
	std::cout << "B.       " << programName << " hello.phsb" << std::endl;
#else
	std::cout << "A. echo \"print(\\\"Hi\\!\\n\\\");\" | " << programName << "\n";
	std::cout << "B. " << programName << " hello.phs\n";
	std::cout << "B. " << programName << " hello.phsb" << std::endl;
#endif
}

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		if (!IS_TERMINAL)
		{
			const std::string source = readStdin();
			if (!source.empty())
			{
				Phasor::ScriptingRuntime ScriptRT(argc, argv, envp);
				Phasor::Frontend::runScript(source);
				return 0;
			}
		}
		if (argc < 2)
		{
			Phasor::Repl Repl(argc, argv, envp);
			return Repl.run();
		}

		const fs::path program = argv[0];
		const fs::path file = argv[1];

		if (!fs::exists(file))
		{
			const std::string raw = file.string();
			if (!raw.empty() && (raw.front() == '-' || raw.front() == '/'))
			{
				std::string m_path = raw;
				m_path.erase(0, m_path.find_first_not_of("-/"));
				if (m_path == "help" || m_path == "h" || m_path == "?" || m_path == "h" || m_path == "help")
				{
					showHelp(program);
					return 0;
				}
				std::cerr << "Invalid argument: " << m_path << "\n";
			}
			else
				std::cerr << "File not found: " << raw << "\n";
			return 1;
		}

		const std::string ext = file.extension().string();

		if (ext == ".phs")
		{
			Phasor::ScriptingRuntime ScriptRT(argc, argv, envp);
			return ScriptRT.run();
		}
		else if (ext == ".phsb")
		{
			Phasor::BinaryRuntime BinRT(argc, argv, envp);
			return BinRT.run();
		}
		else if (ext == ".phir")
		{
			std::cout << "Phasor IR (.phir) compilation not yet implemented.\n";
			return 0;
		}
		else
		{
			std::cerr << "Unknown extension: " << ext << "\n";
			return 1;
		}
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 1;
}


--- .\src\Executable\Repl\Phasor\Repl.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101


VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM REPL"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasorrepl.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasorrepl.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\Repl.ico"



--- .\src\Executable\Repl\Phasor\Repl_main.cpp ---
#include "../../../Repl/Phasor/Repl.hpp"
#include "../../../Frontend/Phasor/Frontend.hpp"
#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		Phasor::Repl Repl(argc, argv, envp);
		return Repl.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\Runtime\Phasor\NativeRuntimeDll.rc ---
#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM Native Runtime"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasorrt.dll"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END




--- .\src\Executable\Runtime\Phasor\NativeRuntimeExe.rc ---
#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "FileDescription", "Phasor VM Native Program"
            VALUE "InternalName", "phasorprogram.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END




--- .\src\Executable\Runtime\Phasor\NativeRuntime_dynamic_main.cpp ---
// #include "yourheader.h"
// PROVIDES:
// inline const unsigned char embeddedBytecode[]
// inline const size_t embeddedBytecodeSize
// std::string moduleName

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <vector>

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#pragma comment(lib, "User32.lib")
#else
#include <dlfcn.h>
#include <unistd.h>
#endif

// New functionality: Pass bytecode and size as raw args to exec to both windows and other

// Main entry point
int main(int argc, char *argv[])
{
	std::string tempFile;
	int         exitCode = 1;

	try
	{
#ifdef _WIN32
		// Load phasor-runtime.dll
		HMODULE hRuntime = LoadLibraryA("phasorrt.dll");
		if (!hRuntime)
		{
			MessageBoxA(nullptr, "Could not load phasorrt.dll",
			            (std::string(moduleName) + " | Phasor Application - Error").c_str(), MB_OK | MB_ICONERROR);
			std::filesystem::remove(tempFile);
			return 1;
		}

		// Get the exec function
		typedef void(CALLBACK * ExecFunc)(const unsigned char[], size_t, const char *, const void *);
		ExecFunc execFunc = (ExecFunc)GetProcAddress(hRuntime, "exec");
		if (!execFunc)
		{
			MessageBoxA(nullptr, "Could not find exec function in DLL",
			            (std::string(moduleName) + " | Phasor Application - Error").c_str(), MB_OK | MB_ICONERROR);
			FreeLibrary(hRuntime);
			std::filesystem::remove(tempFile);
			return 1;
		}

		// Execute the bytecode
		execFunc(embeddedBytecode, embeddedBytecodeSize, moduleName.c_str(), nullptr);
		exitCode = 0;

		// Cleanup
		FreeLibrary(hRuntime);
#else
		// Load phasor-runtime.so
		void *hRuntime = dlopen("libphasorrt.so", RTLD_LAZY);
		if (!hRuntime)
		{
			std::cerr << "Error: Could not load libphasorrt.so: " << dlerror() << "\n";
			std::filesystem::remove(tempFile);
			return 1;
		}

		// Get the exec function
		typedef void (*ExecFunc)(const char *, size_t, const char *, const void *);
		ExecFunc execFunc = (ExecFunc)dlsym(hRuntime, "exec");
		if (!execFunc)
		{
			std::cerr << "Error: Could not find exec function in library\n";
			dlclose(hRuntime);
			std::filesystem::remove(tempFile);
			return 1;
		}

		// Execute the bytecode
		execFunc(tempFile.c_str(), tempFile.size(), moduleName.c_str(), nullptr);
		exitCode = 0;

		// Cleanup
		dlclose(hRuntime);
#endif

		// Remove temporary file
		std::filesystem::remove(tempFile);
	}
	catch (const std::exception &e)
	{
		std::cerr << "Runtime Error: " << e.what() << "\n";
		if (!tempFile.empty())
		{
			std::filesystem::remove(tempFile);
		}
		return 1;
	}

	return exitCode;
}


--- .\src\Executable\Runtime\Phasor\NativeRuntime_library.cpp ---
#include "../../../Runtime/Phasor/NativeRuntime.hpp"

#ifdef _WIN32
#include <windows.h>
#ifdef _SHARED
#define DLLEXPORT __declspec(dllexport)
#endif
#else
#include <iostream>
#ifdef _SHARED
#define DLLEXPORT __attribute__((visibility("default")))
#endif
#endif
#ifndef _SHARED
#define DLLEXPORT
#endif

#include <vector>
#include <cstring>
#include <sstream>

std::vector<std::string> splits(const std::string &input)
{
	std::vector<std::string> parts;

	std::istringstream iss(input);
	std::string        word;
	while (iss >> word)
	{
		parts.push_back(word);
	}
	return parts;
}

extern "C"
{
#ifdef _WIN32
	DLLEXPORT void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
	                    const void *nativeFunctionsVector, const int argc, const char **argv)
#else
	DLLEXPORT void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *,
	                    const void *nativeFunctionsVector, const int argc, const char **argv)
#endif
	{
		try
		{
			std::vector<uint8_t>  bytecodeData(embeddedBytecode, embeddedBytecode + embeddedBytecodeSize);
			Phasor::NativeRuntime NativeRT(bytecodeData, argc, argv);

			if (nativeFunctionsVector != nullptr)
			{
				const void *ptr = nativeFunctionsVector;
				const auto *funcVector = static_cast<const std::vector<std::pair<std::string, void *>> *>(ptr);
				for (const auto &nativeFunction : *funcVector)
				{
					NativeRT.addNativeFunction(nativeFunction.first, nativeFunction.second);
				}
			}

			NativeRT.run();
		}
		catch (const std::exception &e)
		{
#ifdef _WIN32
			MessageBoxA(nullptr, e.what(), (std::string(moduleName) + " | Phasor Runtime - Error").c_str(),
			            MB_OK | MB_ICONERROR);
#else
			std::cerr << "Error: " << e.what() << "\n\a";
#endif
		}
	}
#ifdef _WIN32
	DLLEXPORT void jitExec(const char *script, const char *moduleName, const void *nativeFunctionsVector)
#else
	DLLEXPORT void jitExec(const char *script, const char *, const void *nativeFunctionsVector)
#endif
	{
		try
		{
			Phasor::NativeRuntime NativeRT(script, 0, nullptr);

			if (nativeFunctionsVector != nullptr)
			{
				const void *ptr = nativeFunctionsVector;
				const auto *funcVector = static_cast<const std::vector<std::pair<std::string, void *>> *>(ptr);
				for (const auto &nativeFunction : *funcVector)
				{
					NativeRT.addNativeFunction(nativeFunction.first, nativeFunction.second);
				}
			}

			NativeRT.run();
		}
		catch (const std::exception &e)
		{
#ifdef _WIN32
			MessageBoxA(nullptr, e.what(), (std::string(moduleName) + " | Phasor Runtime - Error").c_str(),
			            MB_OK | MB_ICONERROR);
#else
			std::cerr << "Error: " << e.what() << "\n\a";
#endif
		}
	}

	DLLEXPORT void executeScript(void *vm, const char *script)
	{
		if (vm == nullptr)
		{
			return;
		}

		Phasor::VM *phasorVM = (Phasor::VM *)vm;
		Phasor::NativeRuntime::eval(phasorVM, script);
	}
}

--- .\src\Executable\Runtime\Phasor\NativeRuntime_static_main.cpp ---


#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <vector>
#include <Value.hpp>

// Forward declare native runtime entry points (linked in from the runtime library)
extern "C" void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
                     const void *nativeFunctionsVector, const int argc, const char *argv[]);

// Main entry point
int main(int argc, char *argv[])
{
	int exitCode = 1;

	try
	{
		exec(embeddedBytecode, embeddedBytecodeSize, moduleName.c_str(), nullptr, argc, argv);
		exitCode = 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Runtime Error: " << e.what() << "\n";
		return 1;
	}

	return exitCode;
}


--- .\src\Executable\Runtime\Phasor\ScriptingRuntime.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM JIT Runtime"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasorjit.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasorjit.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\ScriptingRuntime.ico"



--- .\src\Executable\Runtime\Phasor\ScriptingRuntime_main.cpp ---
#include "../../../Runtime/Phasor/ScriptingRuntime.hpp"
#include "../../../Frontend/Phasor/Frontend.hpp"
#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		Phasor::ScriptingRuntime ScriptRT(argc, argv, envp);
		return ScriptRT.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\Runtime\Pulsar\ScriptingRuntime.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Pulsar Interpreter"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "pulsar.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "pulsar.exe"
            VALUE "ProductName", "Pulsar Scripting Language"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\ScriptingRuntime.ico"



--- .\src\Executable\Runtime\Pulsar\ScriptingRuntime_main.cpp ---
#include "../../../Runtime/Pulsar/ScriptingRuntime.hpp"
#include "../../../Frontend/Pulsar/Frontend.hpp"
#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		if (argc >= 2)
		{
			pulsar::Interpreter interp(argc, argv, envp);
			return interp.run();
		}
		else
		{

			pulsar::Frontend::runRepl();
		}
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\Runtime\Shared\BinaryRuntime.rc ---
#include <windows.h>
#include <winver.h>

#define IDI_APP_ICON 101

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor VM Runtime"
            VALUE "FileVersion", "3.0.0.0"
            VALUE "InternalName", "phasorvm.exe"
           VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "phasorvm.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END

IDI_APP_ICON ICON "..\\assets\\BinaryRuntime.ico"



--- .\src\Executable\Runtime\Shared\BinaryRuntime_main.cpp ---
#include "../../../Runtime/Shared/BinaryRuntime.hpp"

#include <iostream>

int main(int argc, char *argv[], char *envp[])
{
	try
	{
		Phasor::BinaryRuntime BinRT(argc, argv, envp);
		return BinRT.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Error: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

--- .\src\Executable\utils\CMakeLists.txt ---
add_subdirectory(coreutils)
add_subdirectory(Shell)

--- .\src\Executable\utils\coreutils\cat.rc ---
// Port of 'cat' - concatenate files and print on the standard output for GNU.
// 'cat' file concatenation program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "concatenate files and print on the standard output"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "cat.exe"
            VALUE "OriginalFilename", "cat.exe"
            VALUE "ProductName", "GNU Phasor 'cat'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\CMakeLists.txt ---
set(TARGETS echo cat ls cp mv rm touch)

foreach(tgt ${TARGETS})
    set(PHS "${CMAKE_SOURCE_DIR}/src/utils/coreutils/${tgt}.phs")
    set(HEADER "${CMAKE_CURRENT_BINARY_DIR}/${tgt}.hpp")
    set(GEN_CPP "${CMAKE_CURRENT_BINARY_DIR}/${tgt}.cpp")
    set(PATH_COUT "src/Executable/utils/coreutils/${tgt}.hpp")

    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

    add_custom_command(
        OUTPUT ${HEADER}
        COMMAND $<TARGET_FILE:phasor_cxx_transpiler> ${PHS} -o ${HEADER} -H --nologo
        DEPENDS ${PHS} phasor_cxx_transpiler
        COMMENT "Building PHS object ${PATH_COUT}"
    )

    configure_file(
        "${CMAKE_CURRENT_SOURCE_DIR}/coreutils_main.in.cpp"
        "${GEN_CPP}"
        @ONLY
    )

    add_executable(${tgt}
        ${GEN_CPP}
        ${CMAKE_CURRENT_SOURCE_DIR}/${tgt}.rc
        ${HEADER}
        ${PHS}
    )
    target_include_directories(${tgt} PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
    target_link_libraries(${tgt} phasor_native_runtime)
    set_target_properties(${tgt} PROPERTIES OUTPUT_NAME "${tgt}-phs")
    if(WIN32)
        install(TARGETS ${tgt}
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib
        )
    elseif(APPLE)
        install(TARGETS ${tgt}
            RUNTIME DESTINATION usr/local/bin
            LIBRARY DESTINATION usr/local/lib
            ARCHIVE DESTINATION usr/local/lib
            FRAMEWORK DESTINATION frameworks
        )
    else()
        install(TARGETS ${tgt}
            RUNTIME DESTINATION usr/bin
            LIBRARY DESTINATION usr/lib
            ARCHIVE DESTINATION usr/lib
        )
    endif()
endforeach()

--- .\src\Executable\utils\coreutils\coreutils_main.in.cpp ---
//   coreutils_main -- wrapper to compile phs coreutils as native applications.
//   Implementation of '@tgt@'
//
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <vector>

#include "@HEADER@"
#include <Value.hpp>

// Forward declare native runtime entry points (linked in from the runtime library)
extern "C" void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
                     const void *nativeFunctionsVector, const int argc, char **argv);

// Main entry point
int main(int argc, char *argv[])
{
	int exitCode = 1;

	try
	{
		exec(embeddedBytecode, embeddedBytecodeSize, moduleName.c_str(), nullptr, argc, argv);
		exitCode = 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Runtime Error: " << e.what() << "\n";
		return 1;
	}

	return exitCode;
}


--- .\src\Executable\utils\coreutils\cp.rc ---
// Port of 'cp' file copying (main routines).
// 'cp' file copying program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "copy files"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "cp.exe"
            VALUE "OriginalFilename", "cp.exe"
            VALUE "ProductName", "GNU Phasor 'cp'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\echo.rc ---
// Port of echo.c, derived from code echo.c in Bash.
// 'echo' print out program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "echo.exe"
            VALUE "OriginalFilename", "echo.exe"
            VALUE "ProductName", "GNU Phasor 'echo'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\ls.rc ---
// Port of 'ls' directory listing program for GNU.
// 'ls' directory listing program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "directory listing program"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "ls.exe"
            VALUE "OriginalFilename", "ls.exe"
            VALUE "ProductName", "GNU Phasor 'ls'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\mv.rc ---
// Port of 'mv' - move (rename) files for GNU.
// 'mv' file moving program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "move (rename) files"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "mv.exe"
            VALUE "OriginalFilename", "mv.exe"
            VALUE "ProductName", "GNU Phasor 'mv'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\rm.rc ---
// Port of 'rm' - remove files for GNU.
// 'rm' file removal program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "remove files"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "rm.exe"
            VALUE "OriginalFilename", "rm.exe"
            VALUE "ProductName", "GNU Phasor 'rm'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\coreutils\touch.rc ---
// Port of touch -- change modification and access times of files for GNU.
// 'touch' file modification program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

#include <windows.h>
#include <winver.h>

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,0
 PRODUCTVERSION 9,9,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"   // US English, Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "change modification and access times of files"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "touch.exe"
            VALUE "OriginalFilename", "touch.exe"
            VALUE "ProductName", "GNU Phasor 'touch'"
            VALUE "ProductVersion", "9.9.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END


--- .\src\Executable\utils\Shell\CMakeLists.txt ---
add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/src/utils/Shell/Shell.hpp
    COMMAND $<TARGET_FILE:phasor_cxx_transpiler> ${CMAKE_SOURCE_DIR}/src/utils/Shell/Shell.phs -o ${CMAKE_CURRENT_BINARY_DIR}/src/utils/Shell/Shell.hpp -H --nologo
    DEPENDS ${CMAKE_SOURCE_DIR}/src/utils/Shell/Shell.phs phasor_cxx_transpiler
    COMMENT "Building PHS bytecode src/Library/utils/Shell/Shell.hpp"
)
add_executable(phasor_shell
    ${CMAKE_CURRENT_SOURCE_DIR}/Shell.rc
    ${CMAKE_CURRENT_SOURCE_DIR}/shell_main.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/src/utils/Shell/Shell.hpp
    ${CMAKE_SOURCE_DIR}/src/utils/Shell/Shell.phs
)
target_include_directories(phasor_shell PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/src/utils/Shell)
target_link_libraries(phasor_shell phasor_native_runtime)
set_target_properties(phasor_shell PROPERTIES OUTPUT_NAME phash)

--- .\src\Executable\utils\Shell\Shell.rc ---
#include <windows.h>
#include <winver.h>

// Simple Shell
// (C) 2026 Daniel McGuire
// This file is licensed under the MIT License

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,3,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG 
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "Phasor Shell"
            VALUE "FileVersion", "1.2.0.0"
            VALUE "InternalName", "shell.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "shell.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END




--- .\src\Executable\utils\Shell\shell_main.cpp ---
#include <Shell.hpp>

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <vector>
#include <Value.hpp>

// Forward declare native runtime entry points (linked in from the runtime library)
extern "C" void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
                     const void *nativeFunctionsVector, const int argc, const char **argv);

// Main entry point
int main(int argc, char *argv[])
{
	int exitCode = 1;

	try
	{
		exec(embeddedBytecode, embeddedBytecodeSize, moduleName.c_str(), nullptr, argc, (const char **)argv);
		exitCode = 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Runtime Error: " << e.what() << "\n";
		return 1;
	}

	return exitCode;
}


--- .\src\Extensions\phasor-ir.tmLanguage ---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>name</key>
	<string>Phasor IR</string>
	<key>scopeName</key>
	<string>source.phasor-ir</string>
	<key>fileTypes</key>
	<array>
		<string>phir</string>
	</array>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#comments</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#sections</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#opcodes</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#registers</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#constants</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#numbers</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#strings</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>comments</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>comment.line.semicolon.phasor-ir</string>
					<key>match</key>
					<string>;.*$</string>
				</dict>
			</array>
		</dict>
		<key>sections</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.control.section.phasor-ir</string>
					<key>match</key>
					<string>^\.(PHIR|CONSTANTS|VARIABLES|FUNCTIONS|STRUCTS|INSTRUCTIONS)\b</string>
				</dict>
			</array>
		</dict>
		<key>opcodes</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.operator.opcode.phasor-ir</string>
					<key>match</key>
					<string>\b(PUSH_CONST|POP|ADD|SUBTRACT|MULTIPLY|DIVIDE|MODULO|SQRT|POW|LOG|EXP|SIN|COS|TAN|NEGATE|NOT|AND|OR|EQUAL|NOT_EQUAL|LESS_THAN|GREATER_THAN|LESS_EQUAL|GREATER_EQUAL|JUMP|JUMP_IF_FALSE|JUMP_IF_TRUE|JUMP_BACK|STORE_VAR|LOAD_VAR|PRINT|PRINTERROR|READLINE|IMPORT|HALT|CALL_NATIVE|CALL|SYSTEM|RETURN|TRUE|FALSE|NULL_VAL|LEN|CHAR_AT|SUBSTR|MOV|LOAD_CONST_R|LOAD_VAR_R|STORE_VAR_R|ADD_R|SUB_R|MUL_R|DIV_R|MOD_R|SQRT_R|POW_R|LOG_R|EXP_R|SIN_R|COS_R|TAN_R|AND_R|OR_R|EQ_R|NE_R|LT_R|GT_R|LE_R|GE_R|PUSH_R|PUSH2_R|POP_R|POP2_R|NEG_R|NOT_R|PRINT_R|PRINTERROR_R|READLINE_R|SYSTEM_R)\b</string>
				</dict>
			</array>
		</dict>
		<key>registers</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>variable.parameter.register.phasor-ir</string>
					<key>match</key>
					<string>\br\d+\b</string>
				</dict>
			</array>
		</dict>
		<key>constants</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>storage.type.constant.phasor-ir</string>
					<key>match</key>
					<string>\b(NULL|BOOL|INT|FLOAT|STRING)\b</string>
				</dict>
			</array>
		</dict>
		<key>numbers</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>constant.numeric.phasor-ir</string>
					<key>match</key>
					<string>\b\d+(\.\d+)?\b</string>
				</dict>
			</array>
		</dict>
		<key>strings</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>string.quoted.double.phasor-ir</string>
					<key>begin</key>
					<string>"</string>
					<key>end</key>
					<string>"</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>name</key>
							<string>constant.character.escape.phasor-ir</string>
							<key>match</key>
							<string>\\.</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>


--- .\src\Extensions\phasor-ir.tmLanguage.json ---
{
  "name": "Phasor IR",
  "scopeName": "source.phasor-ir",
  "fileTypes": ["phir"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#sections"
    },
    {
      "include": "#opcodes"
    },
    {
      "include": "#registers"
    },
    {
      "include": "#constants"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#strings"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.semicolon.phasor-ir",
          "match": ";.*$"
        }
      ]
    },
    "sections": {
      "patterns": [
        {
          "name": "keyword.control.section.phasor-ir",
          "match": "^\\.(PHIR|CONSTANTS|VARIABLES|FUNCTIONS|STRUCTS|INSTRUCTIONS)\\b"
        }
      ]
    },
    "opcodes": {
      "patterns": [
        {
          "name": "keyword.operator.opcode.phasor-ir",
          "match": "\\b(PUSH_CONST|POP|ADD|SUBTRACT|MULTIPLY|DIVIDE|MODULO|SQRT|POW|LOG|EXP|SIN|COS|TAN|NEGATE|NOT|AND|OR|EQUAL|NOT_EQUAL|LESS_THAN|GREATER_THAN|LESS_EQUAL|GREATER_EQUAL|JUMP|JUMP_IF_FALSE|JUMP_IF_TRUE|JUMP_BACK|STORE_VAR|LOAD_VAR|PRINT|PRINTERROR|READLINE|IMPORT|HALT|CALL_NATIVE|CALL|SYSTEM|RETURN|TRUE|FALSE|NULL_VAL|LEN|CHAR_AT|SUBSTR|MOV|LOAD_CONST_R|LOAD_VAR_R|STORE_VAR_R|ADD_R|SUB_R|MUL_R|DIV_R|MOD_R|SQRT_R|POW_R|LOG_R|EXP_R|SIN_R|COS_R|TAN_R|AND_R|OR_R|EQ_R|NE_R|LT_R|GT_R|LE_R|GE_R|PUSH_R|PUSH2_R|POP_R|POP2_R|NEG_R|NOT_R|PRINT_R|PRINTERROR_R|READLINE_R|SYSTEM_R)\\b"
        }
      ]
    },
    "registers": {
      "patterns": [
        {
          "name": "variable.parameter.register.phasor-ir",
          "match": "\\br\\d+\\b"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "storage.type.constant.phasor-ir",
          "match": "\\b(NULL|BOOL|INT|FLOAT|STRING)\\b"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.phasor-ir",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.phasor-ir",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.phasor-ir",
              "match": "\\\\."
            }
          ]
        }
      ]
    }
  }
}

--- .\src\Extensions\phasor.cloc ---
Phasor
    filter remove_inline //.*$
    extension phs
    3rd_gen_scale 2.50
Pulsar
    filter remove_inline //.*$
    extension pul
    3rd_gen_scale 2.50
Phasor_IR
    filter remove_inline ;.*$
    extension phir
    3rd_gen_scale 1.00

--- .\src\Extensions\Phasor.tmLanguage ---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>name</key>
	<string>Phasor</string>
	<key>scopeName</key>
	<string>source.phasor</string>
	<key>fileTypes</key>
	<array>
		<string>phs</string>
	</array>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#comments</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#keywords</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#strings</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#numbers</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#operators</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#functions</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#types</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>comments</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>comment.line.double-slash.phasor</string>
					<key>match</key>
					<string>//.*$</string>
				</dict>
			</array>
		</dict>
		<key>keywords</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.control.phasor</string>
					<key>match</key>
					<string>\b(if|else|while|for|switch|case|default|break|continue|return)\b</string>
				</dict>
				<dict>
					<key>name</key>
					<string>keyword.declaration.phasor</string>
					<key>match</key>
					<string>\b(var|const|fn|struct|import|export|unsafe)\b</string>
				</dict>
				<dict>
					<key>name</key>
					<string>constant.language.phasor</string>
					<key>match</key>
					<string>\b(true|false|null)\b</string>
				</dict>
			</array>
		</dict>
		<key>strings</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>string.quoted.double.phasor</string>
					<key>begin</key>
					<string>"</string>
					<key>end</key>
					<string>"</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>name</key>
							<string>constant.character.escape.phasor</string>
							<key>match</key>
							<string>\\.</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>numbers</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>constant.numeric.phasor</string>
					<key>match</key>
					<string>\b\d+(\.\d+)?\b</string>
				</dict>
			</array>
		</dict>
		<key>operators</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.operator.phasor</string>
					<key>match</key>
					<string>(\+\+|--|==|!=|&lt;=|&gt;=|&amp;&amp;|\|\||-&gt;|[+\-*/%&lt;&gt;=!&amp;|.])</string>
				</dict>
			</array>
		</dict>
		<key>functions</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>entity.name.function.phasor</string>
					<key>match</key>
					<string>\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()</string>
				</dict>
			</array>
		</dict>
		<key>types</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>storage.type.phasor</string>
					<key>match</key>
					<string>\b(int|float|string|bool)\b</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>


--- .\src\Extensions\phasor.tmLanguage.json ---
{
  "name": "Phasor",
  "scopeName": "source.phasor",
  "fileTypes": ["phs"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#types"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.phasor",
          "match": "//.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.phasor",
          "match": "\\b(if|else|while|for|switch|case|default|break|continue|return)\\b"
        },
        {
          "name": "keyword.declaration.phasor",
          "match": "\\b(var|const|fn|struct|import|export|unsafe)\\b"
        },
        {
          "name": "constant.language.phasor",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.phasor",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.phasor",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.phasor",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.phasor",
          "match": "(\\+\\+|--|==|!=|<=|>=|&&|\\|\\||->|[+\\-*/%<>=!&|.])"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "entity.name.function.phasor",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.phasor",
          "match": "\\b(int|float|string|bool)\\b"
        }
      ]
    }
  }
}

--- .\src\Extensions\pulsar.tmLanguage ---
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>name</key>
	<string>pulsar</string>
	<key>scopeName</key>
	<string>source.pulsar</string>
	<key>fileTypes</key>
	<array>
		<string>phs</string>
	</array>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#comments</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#keywords</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#strings</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#numbers</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#operators</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#functions</string>
		</dict>
		<dict>
			<key>include</key>
			<string>#types</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>comments</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>comment.line.double-slash.pulsar</string>
					<key>match</key>
					<string>//.*$</string>
				</dict>
			</array>
		</dict>
		<key>keywords</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.control.pulsar</string>
					<key>match</key>
					<string>\b(if|else|while|for|switch|case|default|break|continue|return)\b</string>
				</dict>
				<dict>
					<key>name</key>
					<string>keyword.declaration.pulsar</string>
					<key>match</key>
					<string>\b(var|const|fn|struct|import|export|unsafe)\b</string>
				</dict>
				<dict>
					<key>name</key>
					<string>constant.language.pulsar</string>
					<key>match</key>
					<string>\b(true|false|null)\b</string>
				</dict>
			</array>
		</dict>
		<key>strings</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>string.quoted.double.pulsar</string>
					<key>begin</key>
					<string>"</string>
					<key>end</key>
					<string>"</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>name</key>
							<string>constant.character.escape.pulsar</string>
							<key>match</key>
							<string>\\.</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>numbers</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>constant.numeric.pulsar</string>
					<key>match</key>
					<string>\b\d+(\.\d+)?\b</string>
				</dict>
			</array>
		</dict>
		<key>operators</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>keyword.operator.pulsar</string>
					<key>match</key>
					<string>(\+\+|--|==|!=|&lt;=|&gt;=|&amp;&amp;|\|\||-&gt;|[+\-*/%&lt;&gt;=!&amp;|.])</string>
				</dict>
			</array>
		</dict>
		<key>functions</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>entity.name.function.pulsar</string>
					<key>match</key>
					<string>\b([a-zA-Z_][a-zA-Z0-9_]*)\s*(?=\()</string>
				</dict>
			</array>
		</dict>
		<key>types</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>name</key>
					<string>storage.type.pulsar</string>
					<key>match</key>
					<string>\b(int|float|string|bool)\b</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>


--- .\src\Extensions\pulsar.tmLanguage.json ---
{
  "name": "pulsar",
  "scopeName": "source.pulsar",
  "fileTypes": ["phs"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#types"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.pulsar",
          "match": "//.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.pulsar",
          "match": "\\b(if|else|while|for|switch|case|default|break|continue|return)\\b"
        },
        {
          "name": "keyword.declaration.pulsar",
          "match": "\\b(var|const|fn|struct|import|export|unsafe)\\b"
        },
        {
          "name": "constant.language.pulsar",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.pulsar",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.pulsar",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.pulsar",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.pulsar",
          "match": "(\\+\\+|--|==|!=|<=|>=|&&|\\|\\||->|[+\\-*/%<>=!&|.])"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "entity.name.function.pulsar",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.pulsar",
          "match": "\\b(int|float|string|bool)\\b"
        }
      ]
    }
  }
}

--- .\src\Extensions\unix\phasor.magic ---
#------------------------------------------------------------------------------
# phasor:  file(1) magic for Phasor language files
#

# Phasor Binary file
0   string      PHSB                    Phasor Binary file
>7  byte        x                       \b, version %d
>6  byte        x                       \b.%d
>5  byte        x                       \b.%d
>4  byte        x                       \b.%d

# Phasor IR file
0   string/bt   .PHIR                   Phasor IR file
>6  string      x                       \b, version %s

--- .\src\Extensions\vscode\CHANGELOG.md ---
# Change Log

All notable changes to the "phasor-programming-language" extension will be documented in this file.

Check [Keep a Changelog](http://keepachangelog.com/) for recommendations on how to structure this file.

## [Unreleased]

- Initial release

--- .\src\Extensions\vscode\extension.ts ---
import * as vscode from "vscode";
import { exec } from "child_process";
import * as path from "path";
import * as fs from "fs";
import { promisify } from "util";
import {
    LanguageClient,
    LanguageClientOptions,
    ServerOptions,
    TransportKind,
    Trace,
} from "vscode-languageclient/node";

let outputChannel: vscode.OutputChannel | undefined;
let client: LanguageClient | undefined;

const execAsync = promisify(exec);

async function fileError(info: string, settingPath: string) {
    const chosen = await vscode.window.showErrorMessage(
        `${info} not found. Please check your configuration.`,
        "Open Settings",
        "Ignore"
    );

    if (chosen === "Open Settings") {
        vscode.commands.executeCommand("workbench.action.openSettings", settingPath);
    }
}

async function executableExists(nameOrPath: string): Promise<boolean> {
    const isPath = nameOrPath.includes("/") || nameOrPath.includes("\\");

    if (isPath) {
        try {
            fs.accessSync(nameOrPath, fs.constants.F_OK);
            return true;
        } catch {
            return false; // Fix: Ensure we return false if the path is invalid
        }
    }

    const cmd = process.platform === "win32"
        ? `where ${nameOrPath}`
        : `which ${nameOrPath}`;

    try {
        await execAsync(cmd);
        return true;
    } catch {
        return false;
    }
}

export async function activate(context: vscode.ExtensionContext): Promise<void> {
    outputChannel = vscode.window.createOutputChannel("Phasor");

    const config = vscode.workspace.getConfiguration("phasor");
    const lspPath = config.get<string>("lspPath", "phasor-lsp");

    if (await executableExists(lspPath) === false) {
        await fileError("Phasor LSP", "phasor.lspPath");
        return;
    }

    const serverOptions: ServerOptions = {
        command: lspPath,
        transport: TransportKind.stdio,
    };

    const clientOptions: LanguageClientOptions = {
        documentSelector: [{ scheme: "file", language: "phasor" }],
        synchronize: {
            fileEvents: vscode.workspace.createFileSystemWatcher("**/*.phs")
        },
        outputChannel,
        traceOutputChannel: outputChannel
    };

    client = new LanguageClient("phasorLsp", "Phasor LSP", serverOptions, clientOptions);

    // ENABLE TRACEING
    client.setTrace(Trace.Verbose);

    context.subscriptions.push(client);

    try {
        await client.start();
        outputChannel?.show(true);
        outputChannel?.appendLine("Language server started");
    } catch (err) {
        outputChannel?.show(true);
        outputChannel?.appendLine("Language server failed to start");
        outputChannel?.appendLine(String(err));
        vscode.window.showErrorMessage(`Phasor LSP failed: ${String(err)}`);
    }

    const disposable = vscode.commands.registerCommand("phasor.run", async () => {
        const editor = vscode.window.activeTextEditor;

        if (!editor) {
            vscode.window.showErrorMessage("No active editor found");
            return;
        }

        const document = editor.document;
        if (document.languageId !== "phasor") {
            vscode.window.showErrorMessage("Current file is not a Phasor file");
            return;
        }

        if (document.isDirty) {
            await document.save();
        }

        await runPhasorFile(document.uri.fsPath);
    });

    context.subscriptions.push(disposable);
    context.subscriptions.push(outputChannel);
}

async function runPhasorFile(filePath: string): Promise<void> {
    const config = vscode.workspace.getConfiguration("phasor");
    const jitPath = config.get<string>("jitPath", "phasor");
    const jitArgs = config.get<string[]>("jitArgs", []);
    const clearOutput = config.get<boolean>("clearOutputBeforeRun", true);

    if (clearOutput && outputChannel) {
        outputChannel.clear();
    }

    outputChannel?.show(true);
    outputChannel?.appendLine(`Running: ${path.basename(filePath)}`);
    outputChannel?.appendLine(`Command: ${jitPath} ${jitArgs.join(" ")} "${filePath}"`);
    outputChannel?.appendLine("---");

    if (await executableExists(jitPath) === false) {
        await fileError("Phasor JIT", "phasor.jitPath");
        return;
    }

    const args = [...jitArgs, filePath].map(arg => `"${arg}"`).join(" ");
    const command = `"${jitPath}" ${args}`;
    const cwd = path.dirname(filePath);

    exec(command, { cwd }, (error, stdout, stderr) => {
        if (stdout && outputChannel) {
            outputChannel.appendLine(stdout);
        }

        if (stderr && outputChannel) {
            outputChannel.appendLine("Error output:");
            outputChannel.appendLine(stderr);
        }

        if (error && outputChannel) {
            outputChannel.appendLine("---");
            outputChannel.appendLine(`Program exited with code: ${error.code}`);
            vscode.window.showErrorMessage(`Phasor execution failed: ${error.message}`);
        } else if (outputChannel) {
            outputChannel.appendLine("---");
            outputChannel.appendLine("Execution completed successfully");
        }
    });
}

export async function deactivate(): Promise<void> {
    if (client) {
        await client.stop();
    }
    outputChannel?.dispose();
}

--- .\src\Extensions\vscode\language-configuration-ir.json ---
{
    "comments": {
        "lineComment": ";"
    }
}

--- .\src\Extensions\vscode\language-configuration-phasor.json ---
{
    "comments": {
        "lineComment": "//",
        "blockComment": [ "/*", "*/" ]
    },
    "brackets": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"]
    ],
    "autoClosingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["\"", "\""],
        ["'", "'"]
    ],
    "surroundingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["\"", "\""],
        ["'", "'"]
    ]
}

--- .\src\Extensions\vscode\language-configuration-pulsar.json ---
{
    "comments": {
        "lineComment": "//",
        "blockComment": [ "/*", "*/" ]
    },
    "brackets": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"]
    ],
    "autoClosingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["\"", "\""],
        ["'", "'"],
        ["`", "`"]
    ],
    "surroundingPairs": [
        ["{", "}"],
        ["[", "]"],
        ["(", ")"],
        ["\"", "\""],
        ["'", "'"],
        ["`", "`"]
    ]
}

--- .\src\Extensions\vscode\license.txt ---
Phasor End User License Agreement (EULA) 1.1

IMPORTANT – READ CAREFULLY: This is a legal agreement between you (the user) and Daniel McGuire.

This agreement applies only to precompiled binary distributions of the Phasor Programming Language.

This agreement does not apply to builds compiled from source, including, but not limited to, nightly or CI releases generated via GitHub Actions, Azure DevOps, or similar first- or third-party services.

1. License Grant
Subject to your compliance with this agreement, you may install and use Phasor Toolchain on your devices for personal/commercial use. This license does not grant rights to modify, reverse engineer, redistribute, or create derivative works of the binary release of Phasor.

2. Restrictions
You may not:
a) Redistribute Phasor or any part of it,
b) Modify Phasor except for personal experimentation,
c) Use Phasor to create competing programming languages, virtual machines, or standard libraries,
d) Use modifications provided or generated by users using the Phasor Programming Language source code.

3. Termination
This license remains effective until terminated. Any violation of these terms automatically terminates your rights under this agreement.

4. Disclaimer
Phasor is provided “as is,” without any warranty of any kind. The author is not responsible for any damage or loss arising from its use.

By installing or using Phasor, you agree to be bound by the terms of this agreement.


--- .\src\Extensions\vscode\package.json ---
{
  "name": "phasor-programming-language",
  "publisher": "phasor",
  "displayName": "Phasor Programming Language",
  "description": "Function VM Based Programming Language",
  "version": "3.0.0",
  "icon": "logo.png",
  "repository": {
    "type": "git",
    "url": "https://github.com/DanielLMcGuire/phasor"
  },
  "engines": {
    "vscode": "^1.108.0"
  },
  "categories": [
    "Programming Languages"
  ],
  "main": "./extension.js",
  "scripts": {
    "build": "tsc && vsce package"
  },
  "contributes": {
    "languages": [
      {
        "id": "phasor",
        "aliases": ["Phasor", "phasor"],
        "extensions": ["phs"],
        "configuration": "./language-configuration-phasor.json"
      },
      {
        "id": "pulsar",
        "aliases": ["Pulsar", "pulsar"],
        "extensions": ["pul"],
        "configuration": "./language-configuration-pulsar.json"
      },
      {
        "id": "phasor-ir",
        "aliases": ["PhasorIR", "phasor-ir"],
        "extensions": ["phir"],
        "configuration": "./language-configuration-ir.json"
      }
    ],
    "grammars": [
      {
        "language": "phasor",
        "scopeName": "source.phasor",
        "path": "./syntaxes/phasor.tmLanguage.json"
      },
      {
        "language": "pulsar",
        "scopeName": "source.pulsar",
        "path": "./syntaxes/pulsar.tmLanguage.json"
      },
      {
        "language": "phasor-ir",
        "scopeName": "source.phasor-ir",
        "path": "./syntaxes/phasor-ir.tmLanguage.json"
      }
    ],
    "commands": [
      {
        "command": "phasor.run",
        "title": "Run Phasor File",
        "icon": "$(play)"
      }
    ],
    "menus": {
      "editor/title": [
        {
          "command": "phasor.run",
          "when": "resourceLangId == phasor",
          "group": "navigation"
        }
      ]
    },
    "configuration": {
      "title": "Phasor",
      "properties": {
        "phasor.jitPath": {
          "type": "string",
          "default": "phasorjit",
          "description": "Path to the Phasor JIT executable."
        },
        "phasor.jitArgs": {
          "type": "array",
          "default": [],
          "description": "Additional arguments to pass to the Phasor JIT executable.",
          "items": {
            "type": "string"
          }
        },
        "phasor.clearOutputBeforeRun": {
          "type": "boolean",
          "default": true,
          "description": "Clear the output panel before running a file."
        },
        "phasor.lspPath": {
          "type": "string",
          "default": "phasor-lsp",
          "description": "Path to the Phasor Language Server executable."
        },
        "phasor.trace.server": {
          "type": "string",
          "enum": ["off", "messages", "verbose"],
          "default": "verbose",
          "description": "Traces the communication between VS Code and the Phasor language server."
        }
      }
    }
  },
  "activationEvents": [
    "onLanguage:phasor",
    "onLanguage:pulsar",
    "onLanguage:phasor-ir"
  ],
  "dependencies": {
    "vscode-languageclient": "^9.0.1"
  },
  "devDependencies": {
    "@types/node": "^25.0.9",
    "@types/vscode": "^1.108.1",
    "eslint": "^10.0.1",
    "typescript": "^5.9.3"
  }
}

--- .\src\Extensions\vscode\README.md ---
# Phasor ![Phasor Logo (Hand-drawn sinewave)](https://phasor.pages.dev/assets/logo-small.webp) Language

A dynamically typed, compiled programming language with a hybrid stack/register-based bytecode virtual machine, *designed* for performance and flexibility.

## Language Features

- **Dynamic typing** with integers, floats, strings, booleans, and of the least for last: null.
- **Functions** with optional type annotations
- **Control flow**: if/else, while, for, switch/case, break/continue
- **Comprehensive standard library**: without anything smart to put here for appeal
- **Hybrid VM** supporting both stack-based and primarily register-based execution

## Standard Library Modules

| Module      | Include Statement    | Functions                                                             |
| ----------- | -------------------- | --------------------------------------------------------------------- |
| **I/O**     | `include_stdio()`    | `puts`, `puts_error` `printf`, `gets`, `putf`, `msgbox`, `msgbox_err` |
| **Math**    | `include_stdmath()`  | `math_sqrt`, `math_pow`, `math_sin`, `math_cos`, etc.                 |
| **Strings** | `include_stdstr()`   | `len`, `substr`, `concat`, `to_upper`, `to_lower`                     |
| **Files**   | `include_stdfile()`  | `fread`, `fwrite`, `fexists`, `fcopy`, `fmove`                        |
| **System**  | `include_stdsys()`   | `time`, `sleep`, `sys_os`, `sys_exec`, `clear`                        |
| **Types**   | `include_stdtype()`  | `to_int`, `to_float`, `to_string`, `to_bool`                          |
| **Regex**   | `include_stdregex()` | `regex_match`, `regex_search`, `regex_replace`                        |

---

**Phasor** - Fast, flexible programming/scripting with *near* native VM performance.

Mentions of 'coreutils', the Free Software Foundation, Inc., 'Java™', Oracle® Corporation, '.NET™', Microsoft® Corporation, Google® LLC, or other third-party companies, products, or trademarks do not imply any affiliation, endorsement, or sponsorship by those third parties, or thier affiliates, unless explicitly stated otherwise.


--- .\src\Extensions\vscode\syntaxes\phasor-ir.tmLanguage.json ---
{
  "name": "Phasor IR",
  "scopeName": "source.phasor-ir",
  "fileTypes": ["phir"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#sections"
    },
    {
      "include": "#opcodes"
    },
    {
      "include": "#registers"
    },
    {
      "include": "#constants"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#strings"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.semicolon.phasor-ir",
          "match": ";.*$"
        }
      ]
    },
    "sections": {
      "patterns": [
        {
          "name": "keyword.control.section.phasor-ir",
          "match": "^\\.(PHIR|CONSTANTS|VARIABLES|FUNCTIONS|STRUCTS|INSTRUCTIONS)\\b"
        }
      ]
    },
    "opcodes": {
      "patterns": [
        {
          "name": "keyword.operator.opcode.phasor-ir",
          "match": "\\b(PUSH_CONST|POP|ADD|SUBTRACT|MULTIPLY|DIVIDE|MODULO|SQRT|POW|LOG|EXP|SIN|COS|TAN|NEGATE|NOT|AND|OR|EQUAL|NOT_EQUAL|LESS_THAN|GREATER_THAN|LESS_EQUAL|GREATER_EQUAL|JUMP|JUMP_IF_FALSE|JUMP_IF_TRUE|JUMP_BACK|STORE_VAR|LOAD_VAR|PRINT|PRINTERROR|READLINE|IMPORT|HALT|CALL_NATIVE|CALL|SYSTEM|RETURN|TRUE|FALSE|NULL_VAL|LEN|CHAR_AT|SUBSTR|MOV|LOAD_CONST_R|LOAD_VAR_R|STORE_VAR_R|ADD_R|SUB_R|MUL_R|DIV_R|MOD_R|SQRT_R|POW_R|LOG_R|EXP_R|SIN_R|COS_R|TAN_R|AND_R|OR_R|EQ_R|NE_R|LT_R|GT_R|LE_R|GE_R|PUSH_R|PUSH2_R|POP_R|POP2_R|NEG_R|NOT_R|PRINT_R|PRINTERROR_R|READLINE_R|SYSTEM_R)\\b"
        }
      ]
    },
    "registers": {
      "patterns": [
        {
          "name": "variable.parameter.register.phasor-ir",
          "match": "\\br\\d+\\b"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "storage.type.constant.phasor-ir",
          "match": "\\b(NULL|BOOL|INT|FLOAT|STRING)\\b"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.phasor-ir",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.phasor-ir",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.phasor-ir",
              "match": "\\\\."
            }
          ]
        }
      ]
    }
  }
}

--- .\src\Extensions\vscode\syntaxes\phasor.tmLanguage.json ---
{
  "name": "Phasor",
  "scopeName": "source.phasor",
  "fileTypes": ["phs"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#types"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.phasor",
          "match": "//.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.phasor",
          "match": "\\b(if|else|while|for|switch|case|default|break|continue|return)\\b"
        },
        {
          "name": "keyword.declaration.phasor",
          "match": "\\b(var|const|fn|struct|import|export|unsafe)\\b"
        },
        {
          "name": "constant.language.phasor",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.phasor",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.phasor",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.phasor",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.phasor",
          "match": "(\\+\\+|--|==|!=|<=|>=|&&|\\|\\||->|[+\\-*/%<>=!&|.])"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "entity.name.function.phasor",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.phasor",
          "match": "\\b(int|float|string|bool)\\b"
        }
      ]
    }
  }
}

--- .\src\Extensions\vscode\syntaxes\pulsar.tmLanguage.json ---
{
  "name": "pulsar",
  "scopeName": "source.pulsar",
  "fileTypes": ["phs"],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#types"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.pulsar",
          "match": "//.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.pulsar",
          "match": "\\b(if|else|while|for|switch|case|default|break|continue|return)\\b"
        },
        {
          "name": "keyword.declaration.pulsar",
          "match": "\\b(var|const|fn|struct|import|export|unsafe)\\b"
        },
        {
          "name": "constant.language.pulsar",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.pulsar",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.pulsar",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.pulsar",
          "match": "\\b\\d+(\\.\\d+)?\\b"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "keyword.operator.pulsar",
          "match": "(\\+\\+|--|==|!=|<=|>=|&&|\\|\\||->|[+\\-*/%<>=!&|.])"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "entity.name.function.pulsar",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?=\\()"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.pulsar",
          "match": "\\b(int|float|string|bool)\\b"
        }
      ]
    }
  }
}

--- .\src\Extensions\vscode\tsconfig.json ---
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "CommonJS",
        "lib": ["ES2020"],
        "strict": true,
        "esModuleInterop": true,
        "outDir": "./",
        "rootDir": "./",
        "sourceMap": true,
        "skipLibCheck": true
    },
    "include": ["./*.ts"],
    "exclude": [
        "node_modules"
    ]
}

--- .\src\Frontend\CMakeLists.txt ---
add_library(PhasorFrontend STATIC 
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Frontend.cpp 
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Frontend.hpp
)
target_link_libraries(PhasorFrontend PUBLIC PhasorCodegen PhasorRuntime)

add_library(PulsarFrontend STATIC 
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Frontend.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Frontend.hpp
)
target_link_libraries(PulsarFrontend PUBLIC PhasorCodegen PhasorRuntime)

--- .\src\Frontend\Phasor\Frontend.cpp ---
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "Frontend.hpp"

#include <version.h>

#include "../../Runtime/FFI/ffi.hpp"
#include <sscanf.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

bool startsWith(const std::string &input, const std::string &prefix)
{
	if (input.size() >= prefix.size() && input.compare(0, prefix.size(), prefix) == 0)
	{
		return true;
	}
	return false;
}

int Phasor::Frontend::runScript(const std::string &source, VM *vm)
{
	int status = 0;
	Lexer lexer(source);
	auto  tokens = lexer.tokenize();

	Parser parser(tokens);
	auto   program = parser.parse();

	CodeGenerator codegen;
	auto          bytecode = codegen.generate(*program);

	bool ownVM = false;

	if (vm == nullptr)
	{
		ownVM = true;
		vm = new VM();
		StdLib::registerFunctions(*vm);
	}

#if defined(_WIN32)
	FFI ffi("plugins", vm);
#elif defined(__APPLE__)
	FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm);
#elif defined(__linux__)
	FFI ffi("/opt/Phasor/plugins", vm);
#endif

	vm->setImportHandler([](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
		{
			throw std::runtime_error("Could not open imported file: " + path.string());
		}
		std::stringstream buffer;
		buffer << file.rdbuf();
		runScript(buffer.str());
	});

	if (status != 0) {
		if (ownVM) delete vm;
		return status;
	}

	status = vm->run(bytecode);

	if (ownVM)
	{
		delete vm;
	}

	return status;
}

int Phasor::Frontend::runRepl(VM *vm)
{
	std::cout << "Phasor REPL (using Phasor VM v" << PHASOR_VERSION_STRING << ")\n(C) 2026 Daniel McGuire\n\n";
	std::cout << "Type 'exit();' to quit. Function declarations will not work.\n";
	int status = 0;
	bool ownVM = false;
	if (vm == nullptr)
	{
		ownVM = true;
		vm = new VM();
		StdLib::registerFunctions(*vm);
	}

#if defined(_WIN32)
	FFI ffi("plugins", vm);
#elif defined(__APPLE__)
	FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm);
#elif defined(__linux__)
	FFI ffi("/opt/Phasor/plugins", vm);
#endif

	vm->setImportHandler([](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
		{
			throw std::runtime_error("Could not open imported file: " + path.string());
		}
		std::stringstream buffer;
		buffer << file.rdbuf();
		runScript(buffer.str());
	});

	if (status != 0) {
		if (ownVM) delete vm;
		return status;
	}

	std::map<std::string, int> globalVars;
	int                        nextVarIdx = 0;
	CodeGenerator              codegen;

	std::string line;
	bool cleanExit = false;
	while (true)
	{
		try
		{
			std::cout << "\n> ";
			if (!std::getline(std::cin, line))
				break;
			if (startsWith(line, "vm_pop"))
			{
				line = "let popx = " + vm->pop().toString();
				continue;
			}
			if (startsWith(line, "vm_push"))
			{
				vm->push(line.substr(4));
				continue;
			}
			if (startsWith(line, "vm_peek"))
			{
				line = "let peekx = " + vm->peek().toString();
			}
			if (startsWith(line, "vm_op"))
			{
				char         instruction[64];
				unsigned int operand;
				sscanf(line.c_str(), "vm_op %63s %u", instruction, &operand);
				vm->operation(PhasorIR::stringToOpCode(std::string(instruction)), operand);
				continue;
			}
			if (startsWith(line, "vm_getvar"))
			{
				int index;
				sscanf(line.c_str(), "vm_getvar %d", &index);
				line = "let getvarx = " + vm->getVariable(index).toString();
			}
			if (startsWith(line, "vm_setvar"))
			{
				char value[64];
				sscanf(line.c_str(), "vm_setvar %63s", value);
				line = "var setvarx = " + std::to_string(vm->addVariable(value));
			}
			if (startsWith(line, "vm_reset"))
			{
				vm->reset(true, true, true);
				continue;
			}
			if (startsWith(line, "exit"))
			{
				cleanExit = true;
				break;
			}
			if (line.empty())
			{
				std::cerr << "Empty line\n";
				continue;
			}

			Lexer lexer(line);
			auto  tokens = lexer.tokenize();

			Parser parser(tokens);
			auto   program = parser.parse();

			auto bytecode = codegen.generate(*program, globalVars, nextVarIdx, true);

			// Update persistent state
			globalVars = bytecode.variables;
			nextVarIdx = bytecode.nextVarIndex;

			status = vm->run(bytecode);
		}
		catch (const std::exception &e)
		{
			std::string errorMsg = std::string(e.what()) + " | " + vm->getInformation() + "\n";
			error(errorMsg);
		}
	}

	if (ownVM)
		delete vm;

	if (cleanExit)
		return 0;

	return status;
}


--- .\src\Frontend\Phasor\Frontend.hpp ---
#include "../../Runtime/VM/VM.hpp"
#include <string>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/// @brief Frontend namespace
namespace Frontend
{
/**
 * @brief Run a script
 * @param source The source code to run
 * @param vm The virtual machine to run the script on
 * @return The result of the script
 */
int runScript(const std::string &source, VM *vm = nullptr);

/**
 * @brief Run an REPL
 * @param vm The virtual machine to run the REPL on
 */
int runRepl(VM *vm = nullptr);
} // namespace Frontend

} // namespace Phasor

--- .\src\Frontend\Pulsar\Frontend.cpp ---
#include "../../Language/Pulsar/Lexer/Lexer.hpp"
#include "../../Language/Pulsar/Parser/Parser.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "../../Runtime/FFI/ffi.hpp"

#include <version.h>
#include <sscanf.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

#include "Frontend.hpp"

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

bool startsWith(const std::string &input, const std::string &prefix)
{
	if (input.size() >= prefix.size() && input.compare(0, prefix.size(), prefix) == 0)
	{
		return true;
	}
	return false;
}

int pulsar::Frontend::runScript(const std::string &source, Phasor::VM *vm)
{
	Lexer                 lexer(source);
	Parser                parser(lexer.tokenize());
	Phasor::CodeGenerator codegen;
	auto                  program = parser.parse();
	auto                  bytecode = codegen.generate(*program);

	int status = 0;
	bool ownVM = false;

	if (vm == nullptr)
	{
		ownVM = true;
		vm = new Phasor::VM();
		Phasor::StdLib::registerFunctions(*vm);
	}

#if defined(_WIN32)
	Phasor::FFI ffi("plugins", vm);
#elif defined(__APPLE__)
	Phasor::FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm);
#elif defined(__linux__)
	Phasor::FFI("/opt/Phasor/plugins", vm);
#endif

	vm->setImportHandler([](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
		{
			throw std::runtime_error("Could not open imported file: " + path.string());
		}
		std::stringstream buffer;
		buffer << file.rdbuf();
		runScript(buffer.str());
	});

	if (status != 0) {
		if (ownVM) delete vm;
		return status;
	}

	return vm->run(bytecode);

	if (ownVM)
	{
		delete vm;
	}
}

int pulsar::Frontend::runRepl(Phasor::VM *vm)
{
	std::cout << "Pulsar REPL (using Phasor VM v" << PHASOR_VERSION_STRING << ")\n(C) 2026 Daniel McGuire\n\n";
	std::cout << "Type 'exit()' to quit. Function declarations will not work.\n";

	int status = 0;
	bool ownVM = false;
	if (vm == nullptr)
	{
		ownVM = true;
		vm = new Phasor::VM();
		Phasor::StdLib::registerFunctions(*vm);
	}

#if defined(_WIN32)
	Phasor::FFI ffi("plugins", vm);
#elif defined(__APPLE__)
	Phasor::FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm);
#elif defined(__linux__)
	Phasor::FFI ffi("/opt/Phasor/plugins", vm);
#endif

	vm->setImportHandler([](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
		{
			throw std::runtime_error("Could not open imported file: " + path.string());
		}
		std::stringstream buffer;
		buffer << file.rdbuf();
		runScript(buffer.str());
	});

	if (status != 0) {
		if (ownVM) delete vm;
		return status;
	}

	std::map<std::string, int> globalVars;
	int                        nextVarIdx = 0;
	Phasor::CodeGenerator      codegen;

	std::string line;
	while (true)
	{
		try
		{
			std::cout << "\n> ";
			if (!std::getline(std::cin, line))
				break;
			if (startsWith(line, "vm_pop"))
			{
				line = "let popx = " + vm->pop().toString();
				continue;
			}
			if (startsWith(line, "vm_push"))
			{
				vm->push(line.substr(4));
				continue;
			}
			if (startsWith(line, "vm_peek"))
			{
				line = "let peekx = " + vm->peek().toString();
			}
			if (startsWith(line, "vm_op"))
			{
				char         instruction[64];
				unsigned int operand;
				sscanf(line.c_str(), "vm_op %63s %u", instruction, &operand);
				vm->operation(Phasor::PhasorIR::stringToOpCode(std::string(instruction)), operand);
				continue;
			}
			if (startsWith(line, "vm_getvar"))
			{
				int index;
				sscanf(line.c_str(), "vm_getvar %d", &index);
				line = "let getvarx = " + vm->getVariable(index).toString();
			}
			if (startsWith(line, "vm_setvar"))
			{
				char value[64];
				sscanf(line.c_str(), "vm_setvar %63s", value);
				line = "var setvarx = " + std::to_string(vm->addVariable(value));
			}
			if (startsWith(line, "vm_reset"))
			{
				vm->reset(true, true, true);
				continue;
			}
			if (startsWith(line, "exit"))
				break;
			if (line.empty())
			{
				std::cerr << "Empty line\n";
				continue;
			}

			Lexer  lexer(line);
			Parser parser(lexer.tokenize());
			auto   program = parser.parse();
			auto   bytecode = codegen.generate(*program, globalVars, nextVarIdx, true);

			globalVars = bytecode.variables;
			nextVarIdx = bytecode.nextVarIndex;

			return vm->run(bytecode);
		}
		catch (const std::exception &e)
		{
			std::string errorMsg = std::string(e.what()) + " | " + vm->getInformation() + "\n";
			error(errorMsg);
		}
	}
	if (ownVM)
	{
		delete vm;
	}
	return 0;
}


--- .\src\Frontend\Pulsar\Frontend.hpp ---
#include "../../Runtime/VM/VM.hpp"
#include <string>
/// @brief The Pulsar Scripting Language
namespace pulsar
{

/// @brief Frontend namespace
namespace Frontend
{
/**
 * @brief Run a script
 * @param source The source code to run
 * @param vm The virtual machine to run the script on
 * @return The result of the script
 */
int runScript(const std::string &source, Phasor::VM *vm = nullptr);

/**
 * @brief Run an REPL
 * @param vm The virtual machine to run the REPL on
 */
int runRepl(Phasor::VM *vm = nullptr);
} // namespace Frontend

} // namespace pulsar

--- .\src\include\sscanf.h ---
#include <cstdio>
#ifdef _WIN32
inline int sscanf_wrapper(const char *buffer, const char *format, char *str, unsigned int *num)
{
	return sscanf_s(buffer, format, str, 64, num);
}
inline int sscanf_wrapper(const char *buffer, const char *format, char *str)
{
	return sscanf_s(buffer, format, str, 64);
}
inline int sscanf_wrapper(const char *buffer, const char *format, int *num)
{
	return sscanf_s(buffer, format, num);
}
#define sscanf sscanf_wrapper
#endif

--- .\src\include\version.h.in ---
#pragma once

#define PHASOR_VERSION_STRING "@PROJECT_VERSION@"

--- .\src\ISA\ISA.hpp ---
#pragma once
namespace Phasor
{
/**
 * @class OpCode
 * @brief Expanded opcode set for Phasor VM
 */
enum class OpCode : uint8_t
{
	// Stack operations
	PUSH_CONST, ///< Push constant from constant pool
	POP,        ///< Pop top of stack

	// Arithmetic operations
	IADD,       ///< Pop b, pop a, push a + b
	ISUBTRACT,  ///< Pop b, pop a, push a - b
	IMULTIPLY,  ///< Pop b, pop a, push a * b
	IDIVIDE,    ///< Pop b, pop a, push a / b
	IMODULO,    ///< Pop b, pop a, push a % b
	FLADD,      ///< Pop b, pop a, push a + b
	FLSUBTRACT, ///< Pop b, pop a, push a - b
	FLMULTIPLY, ///< Pop b, pop a, push a * b
	FLDIVIDE,   ///< Pop b, pop a, push a / b
	FLMODULO,   ///< Pop b, pop a, push a % b
	SQRT,       ///< sqrt()
	POW,        ///< pow()
	LOG,        ///< log()
	EXP,        ///< exp()
	SIN,        ///< sin()
	COS,        ///< cos()
	TAN,        ///< tan()

	// Unary operations
	NEGATE, ///< Pop a, push -a
	NOT,    ///< Pop a, push !a

	// Logical operations
	IAND,  ///< Pop b, pop a, push a && b
	IOR,   ///< Pop b, pop a, push a || b
	FLAND, ///< Pop b, pop a, push a && b
	FLOR,  ///< Pop b, pop a, push a || b

	// Comparison operations
	IEQUAL,          ///< Pop b, pop a, push a == b
	INOT_EQUAL,      ///< Pop b, pop a, push a != b
	ILESS_THAN,      ///< Pop b, pop a, push a < b
	IGREATER_THAN,   ///< Pop b, pop a, push a > b
	ILESS_EQUAL,     ///< Pop b, pop a, push a <= b
	IGREATER_EQUAL,  ///< Pop b, pop a, push a >= b
	FLEQUAL,         ///< Pop b, pop a, push a == b
	FLNOT_EQUAL,     ///< Pop b, pop a, push a != b
	FLLESS_THAN,     ///< Pop b, pop a, push a < b
	FLGREATER_THAN,  ///< Pop b, pop a, push a > b
	FLLESS_EQUAL,    ///< Pop b, pop a, push a <= b
	FLGREATER_EQUAL, ///< Pop b, pop a, push a >= b

	// Control flow
	JUMP,          ///< Unconditional jump to offset
	JUMP_IF_FALSE, ///< Jump if top of stack is false (pops value)
	JUMP_IF_TRUE,  ///< Jump if top of stack is true (pops value)
	JUMP_BACK,     ///< Jump backwards (for loops)

	// Variable operations
	STORE_VAR, ///< Pop top of stack, store in variable slot
	LOAD_VAR,  ///< Push variable value onto stack

	// I/O and control
	PRINT,       ///< Pop top of stack and print
	PRINTERROR,  ///< Pop top of stack and print to stderr
	READLINE,    ///< Read line from input and push onto stack
	IMPORT,      ///< Import a module: operand is index of module path in constants
	HALT,        ///< Stop execution
	CALL_NATIVE, ///< Call a native function: operand is index of function name in constants
	CALL,        ///< Call a user function: operand is index of function name in constants
	SYSTEM,      ///< Call a system function: operand is index of function name in constants
	SYSTEM_OUT,  ///< Call system function and push stdout
	SYSTEM_ERR,  ///< Call system function and push stderr
	RETURN,      ///< Return from function

	// Literal values
	TRUE_P,   ///< Push true
	FALSE_P,  ///< Push false
	NULL_VAL, ///< Push null

	// String operatoins
	LEN,     ///< Pop s, push len(s)
	CHAR_AT, ///< Pop index, pop s, push s[index]
	SUBSTR,  ///< Pop len, pop start, pop s, push s.substr(start, len)

	NEW_STRUCT, ///< Create new struct: operand is index of struct name in constants
	GET_FIELD,  ///< Pop struct, pop field name, push field value
	SET_FIELD,  ///< Pop struct, pop field name, pop value, set field value

	NEW_STRUCT_INSTANCE_STATIC, ///< Create new struct instance using struct section metadata (structIndex)
	GET_FIELD_STATIC,           ///< Pop struct instance, push field by static offset (structIndex, fieldOffset)
	SET_FIELD_STATIC,           ///< Pop value and struct instance, set field by static offset

	// Register-based operations (v2.0)
	// Data movement
	MOV,          ///< Copy register to register: R[rA] = R[rB]
	LOAD_CONST_R, ///< Load constant to register: R[rA] = constants[immediate]
	LOAD_VAR_R,   ///< Load variable to register: R[rA] = variables[immediate]
	STORE_VAR_R,  ///< Store register to variable: variables[immediate] = R[rA]
	PUSH_R,       ///< Push register to stack: push(R[rA])
	PUSH2_R,      ///< Push 2 registers to stack: push2(R[rA], R[rB])
	POP_R,        ///< Pop stack to register: R[rA] = pop()
	POP2_R,       ///< Pop 2 values from stack to registers: pop2(R[rA], R[rB])

	// Register arithmetic (3-address code)
	IADD_R,  ///< R[rA] = R[rB] + R[rC]
	ISUB_R,  ///< R[rA] = R[rB] - R[rC]
	IMUL_R,  ///< R[rA] = R[rB] * R[rC]
	IDIV_R,  ///< R[rA] = R[rB] / R[rC]
	IMOD_R,  ///< R[rA] = R[rB] % R[rC]
	FLADD_R, ///< R[rA] = R[rB] + R[rC]
	FLSUB_R, ///< R[rA] = R[rB] - R[rC]
	FLMUL_R, ///< R[rA] = R[rB] * R[rC]
	FLDIV_R, ///< R[rA] = R[rB] / R[rC]
	FLMOD_R, ///< R[rA] = R[rB] % R[rC]
	SQRT_R,  ///< R[rA] = sqrt(R[rB])
	POW_R,   ///< R[rA] = pow(R[rB], R[rC])
	LOG_R,   ///< R[rA] = log(R[rB])
	EXP_R,   ///< R[rA] = exp(R[rB])
	SIN_R,   ///< R[rA] = sin(R[rB])
	COS_R,   ///< R[rA] = cos(R[rB])
	TAN_R,   ///< R[rA] = tan(R[rB])

	// Register comparisons
	IAND_R,  ///< R[rA] = R[rB] && R[rC]
	IOR_R,   ///< R[rA] = R[rB] || R[rC]
	IEQ_R,   ///< R[rA] = R[rB] == R[rC]
	INE_R,   ///< R[rA] = R[rB] != R[rC]
	ILT_R,   ///< R[rA] = R[rB] < R[rC]
	IGT_R,   ///< R[rA] = R[rB] > R[rC]
	ILE_R,   ///< R[rA] = R[rB] <= R[rC]
	IGE_R,   ///< R[rA] = R[rB] >= R[rC]
	FLAND_R, ///< R[rA] = R[rB] && R[rC]
	FLOR_R,  ///< R[rA] = R[rB] || R[rC]
	FLEQ_R,  ///< R[rA] = R[rB] == R[rC]
	FLNE_R,  ///< R[rA] = R[rB] != R[rC]
	FLLT_R,  ///< R[rA] = R[rB] < R[rC]
	FLGT_R,  ///< R[rA] = R[rB] > R[rC]
	FLLE_R,  ///< R[rA] = R[rB] <= R[rC]
	FLGE_R,  ///< R[rA] = R[rB] >= R[rC]

	// Register unary operations
	NEG_R, ///< R[rA] = -R[rB]
	NOT_R, ///< R[rA] = !R[rB]

	// Register I/O
	PRINT_R,      ///< Print register: print(R[rA])
	PRINTERROR_R, ///< Print register to stderr: printerror(R[rA])
	READLINE_R,   ///< Read line into register: readline(R[rA])
	SYSTEM_R,     ///< Run an operating system shell command: system(R[rA])
	SYSTEM_OUT_R, /// Run shell command and get output: system_out(R[rA], R[rB])
	SYSTEM_ERR_R  /// Run shell command and get error output: system_err(R[rA], R[rB])
};
} // namespace Phasor

--- .\src\Language\CMakeLists.txt ---
set(PHASOR_LANGUAGE_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Lexer/Lexer.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Parser/Parser.cpp
)

set(PHASOR_LANGUAGE_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Lexer/Lexer.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Parser/Parser.hpp
)

set(PULSAR_LANGUAGE_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Lexer/Lexer.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Parser/Parser.cpp
)

set(PULSAR_LANGUAGE_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Lexer/Lexer.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/Parser/Parser.cpp
)

add_library(phasor_language STATIC ${PHASOR_LANGUAGE_SOURCES} ${PHASOR_LANGUAGE_HEADERS})

add_library(pulsar_language STATIC ${PULSAR_LANGUAGE_SOURCES} ${PULSAR_LANGUAGE_HEADERS})

--- .\src\Language\Phasor\Lexer\Lexer.cpp ---
#include "Lexer.hpp"
#include <cctype>
#include <sstream>
#include <stdexcept>

namespace Phasor
{

Lexer::Lexer(const std::string &source) : source(source)
{
}

void Lexer::skipShebang()
{
	if (position == 0 && peek() == '#' && position + 1 < source.length() && source[position + 1] == '!')
	{
		while (!isAtEnd() && peek() != '\n')
		{
			advance();
		}
	}
}

std::vector<Token> Lexer::tokenize()
{
	std::vector<Token> tokens;
	skipShebang();
	while (!isAtEnd())
	{
		skipWhitespace();
		if (isAtEnd())
			break;
		tokens.push_back(scanToken());
	}
	tokens.push_back({TokenType::EndOfFile, "", line, column});
	return tokens;
}

char Lexer::peek()
{
	if (isAtEnd())
		return '\0';
	return source[position];
}

char Lexer::advance()
{
	char c = source[position++];
	column++;
	if (c == '\n')
	{
		line++;
		column = 1;
	}
	return c;
}

bool Lexer::isAtEnd()
{
	return position >= source.length();
}

void Lexer::skipWhitespace()
{
	while (!isAtEnd())
	{
		char c = peek();
		if (std::isspace(static_cast<unsigned char>(c)))
		{
			advance();
		}
		else if (c == '/' && position + 1 < source.length() && source[position + 1] == '/')
		{
			// Skip single-line comment
			while (!isAtEnd() && peek() != '\n')
			{
				advance();
			}
		}
		else
		{
			break;
		}
	}
}

Token Lexer::scanToken()
{
	char c = peek();
	if (std::isalpha(static_cast<unsigned char>(c)))
		return identifier();
	if (std::isdigit(static_cast<unsigned char>(c)))
		return number();
	if (c == '"')
		return string();
	if (c == '`')
		return complexString();

	// Multi-character operators
	if (c == '+' && position + 1 < source.length() && source[position + 1] == '+')
	{
		advance();
		advance();
		return {TokenType::Symbol, "++", line, column};
	}
	if (c == '-' && position + 1 < source.length() && source[position + 1] == '-')
	{
		advance();
		advance();
		return {TokenType::Symbol, "--", line, column};
	}
	if (c == '=' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {TokenType::Symbol, "==", line, column};
	}
	if (c == '!' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {TokenType::Symbol, "!=", line, column};
	}
	if (c == '-' && position + 1 < source.length() && source[position + 1] == '>')
	{
		advance();
		advance();
		return {TokenType::Symbol, "->", line, column};
	}
	if (c == '<' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {TokenType::Symbol, "<=", line, column};
	}
	if (c == '>' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {TokenType::Symbol, ">=", line, column};
	}
	if (c == '&' && position + 1 < source.length() && source[position + 1] == '&')
	{
		advance();
		advance();
		return {TokenType::Symbol, "&&", line, column};
	}
	if (c == '|' && position + 1 < source.length() && source[position + 1] == '|')
	{
		advance();
		advance();
		return {TokenType::Symbol, "||", line, column};
	}

	// Single-character symbols (parentheses, operators, punctuation, etc.)
	if (std::string("()+-*/%<>=!&|.{}:;,[]").find(c) != std::string::npos)
	{
		advance();
		return {TokenType::Symbol, std::string(1, c), line, column};
	}

	advance();
	return {TokenType::Unknown, std::string(1, c), line, column};
}

Token Lexer::identifier()
{
	size_t start = position;
	while (std::isalnum(static_cast<unsigned char>(peek())) || peek() == '_')
		advance();
	std::string text = source.substr(start, position - start);

	static const std::vector<std::string> keywords = {"var",    "fn",       "if",     "else", "while",  "for",
	                                                  "return", "true",     "false",  "null", "throw",  "print",
	                                                  "break",  "continue", "switch", "case", "default"};

	for (const auto &kw : keywords)
	{
		if (text == kw)
		{
			return {TokenType::Keyword, text, line, column};
		}
	}

	return {TokenType::Identifier, text, line, column};
}

Token Lexer::number()
{
	size_t start = position;
	while (std::isdigit(static_cast<unsigned char>(peek())))
		advance();
	if (peek() == '.' && position + 1 < source.length() &&
	    std::isdigit(static_cast<unsigned char>(source[position + 1])))
	{
		advance();
		while (std::isdigit(static_cast<unsigned char>(peek())))
			advance();
	}
	return {TokenType::Number, source.substr(start, position - start), line, column};
}

static int hexValue(char c)
{
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return 10 + (c - 'a');
	if (c >= 'A' && c <= 'F')
		return 10 + (c - 'A');
	return -1;
}

Token Lexer::string()
{
	size_t             tokenLine = line;
	size_t             tokenColumn = column;
	std::ostringstream out;
	advance(); // Skip opening quote

	while (!isAtEnd())
	{
		char c = advance();

		// Raw newline inside a string is treated as unterminated/error.
		if (c == '\n')
		{
			// Unterminated string literal
			return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
		}

		if (c == '\\')
		{
			if (isAtEnd())
			{
				// Unterminated escape at end of file
				return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
			}
			char esc = advance();
			switch (esc)
			{
			case 'n':
				out << '\n';
				break;
			case 't':
				out << '\t';
				break;
			case 'r':
				out << '\r';
				break;
			case '\\':
				out << '\\';
				break;
			case '"':
				out << '"';
				break;
			case '\'':
				out << '\'';
				break;
			case '0':
				out << '\0';
				break;
			case 'b':
				out << '\b';
				break;
			case 'f':
				out << '\f';
				break;
			case 'v':
				out << '\v';
				break;
			case 'x': {
				// Hex escape sequence: \xHH
				if (isAtEnd())
					return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char h1 = advance();
				if (isAtEnd())
					return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char h2 = advance();
				int  v1 = hexValue(h1), v2 = hexValue(h2);
				if (v1 < 0 || v2 < 0)
					return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char value = static_cast<char>((v1 << 4) | v2);
				out << value;
				break;
			}
			default:
				// Unknown escape: be permissive and append the escaped character as-is.
				out << esc;
				break;
			}
		}
		else if (c == '"')
		{
			// Closing quote
			return {TokenType::String, out.str(), tokenLine, tokenColumn};
		}
		else
		{
			out << c;
		}
	}

	// If we get here, string was unterminated
	return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
}

Token Lexer::complexString()
{
	size_t             tokenLine = line;
	size_t             tokenColumn = column;
	std::ostringstream out;
	advance(); // Skip opening backtick

	// Not even attempting ${} syntax for now. Just read as a raw string.

	while (!isAtEnd())
	{
		char c = advance();

		if (c == '`')
		{
			// Closing backtick
			return {TokenType::String, out.str(), tokenLine, tokenColumn};
		}
		else
		{
			out << c;
		}
	}

	// If we get here, string was unterminated
	return {TokenType::Unknown, std::string(), tokenLine, tokenColumn};
}
} // namespace Phasor

--- .\src\Language\Phasor\Lexer\Lexer.hpp ---
#pragma once
#include "../../../AST/AST.hpp"
#include <string>
#include <vector>
#include <memory>
#include <optional>
#include <iostream>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{
/// @brief Lexer
class Lexer
{
  public:
	
	Lexer(const std::string &source);
	std::vector<Token> tokenize();

	struct Error
	{
		std::string message;
		size_t      line;
		size_t      column;
	};
	std::optional<Error> getError() const
	{
		return lastError;
	}
  private:
	std::string source;
	size_t      position = 0;
	size_t      line = 1;
	size_t      column = 1;

	std::optional<Error> lastError;

	char  peek();
	char  advance();
	bool  isAtEnd();
	void  skipWhitespace();
	void  skipShebang();
	Token scanToken();
	Token identifier();
	Token number();
	Token string();
	Token complexString();
};
} // namespace Phasor


--- .\src\Language\Phasor\Parser\Parser.cpp ---
#include "Parser.hpp"
#include <iostream>

namespace Phasor
{

using namespace AST;

Parser::Parser(const std::vector<Token> &tokens) : tokens(tokens)
{
}

std::unique_ptr<Program> Parser::parse()
{
	auto program = std::make_unique<Program>();
	while (!isAtEnd())
	{
		program->statements.push_back(declaration());
	}
	return program;
}

std::unique_ptr<Statement> Parser::declaration()
{
	if (check(TokenType::Keyword) && peek().lexeme == "fn")
	{
		Token start = peek();
		advance();
		auto node = functionDeclaration();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "var")
	{
		Token start = peek();
		advance();
		auto node = varDeclaration();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "import")
	{
		Token start = peek();
		advance();
		auto node = importStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "export")
	{
		Token start = peek();
		advance();
		auto node = exportStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "struct")
	{
		return structDecl();
	}
	return statement();
}

std::unique_ptr<Statement> Parser::functionDeclaration()
{
	Token name = consume(TokenType::Identifier, "Expect function name.");
	consume(TokenType::Symbol, "(", "Expect '(' after function name.");
	std::vector<FunctionDecl::Param> params;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		do
		{
			Token paramName = consume(TokenType::Identifier, "Expect parameter name.");
			consume(TokenType::Symbol, ":", "Expect ':' after parameter name.");
			auto type = parseType();
			params.push_back({paramName.lexeme, std::move(type)});
		} while (match(TokenType::Symbol, ","));
	}
	consume(TokenType::Symbol, ")", "Expect ')' after parameters.");

	std::unique_ptr<TypeNode> returnType = nullptr;
	if (match(TokenType::Symbol, "->"))
	{
		returnType = parseType();
	}

	consume(TokenType::Symbol, "{", "Expect '{' before function body.");

	// Track function context for better error messages
	std::string previousFunction = currentFunction;
	currentFunction = name.lexeme;

	auto body = block();

	// Restore previous function context
	currentFunction = previousFunction;

	auto node = std::make_unique<FunctionDecl>(name.lexeme, std::move(params), std::move(returnType), std::move(body));
	node->line = name.line;
	node->column = name.column;
	return node;
}

std::unique_ptr<TypeNode> Parser::parseType()
{
	Token start = peek();
	bool  isPointer = false;
	if (match(TokenType::Symbol, "*"))
	{
		isPointer = true;
	}
	Token typeName = consume(TokenType::Identifier, "Expect type name.");

	std::vector<int> dims;
	while (match(TokenType::Symbol, "["))
	{
		Token size = consume(TokenType::Number, "Expect array size in type declaration.");
		dims.push_back(std::stoi(size.lexeme));
		consume(TokenType::Symbol, "]", "Expect ']' after array size.");
	}
	auto node = std::make_unique<TypeNode>(typeName.lexeme, isPointer, dims);
	node->line = start.line;
	node->column = start.column;
	return node;
}

std::unique_ptr<Statement> Parser::varDeclaration()
{
	Token                       name = consume(TokenType::Identifier, "Expect variable name.");
	std::unique_ptr<Expression> initializer = nullptr;
	if (match(TokenType::Symbol, "="))
	{
		initializer = expression();
	}
	consume(TokenType::Symbol, ";", "Expect ';' after variable declaration.");
	auto node = std::make_unique<VarDecl>(name.lexeme, std::move(initializer));
	node->line = name.line;
	node->column = name.column;
	return node;
}

std::unique_ptr<Statement> Parser::statement()
{
	if (check(TokenType::Keyword) && peek().lexeme == "print")
	{
		Token start = peek();
		advance();
		auto node = printStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "if")
	{
		Token start = peek();
		advance();
		auto node = ifStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "while")
	{
		Token start = peek();
		advance();
		auto node = whileStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "for")
	{
		Token start = peek();
		advance();
		auto node = forStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "switch")
	{
		Token start = peek();
		advance();
		auto node = switchStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "return")
	{
		Token start = peek();
		advance();
		auto node = returnStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "break")
	{
		Token start = peek();
		advance();
		consume(TokenType::Symbol, ";", "Expect ';' after 'break'.");
		auto node = std::make_unique<BreakStmt>();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "continue")
	{
		Token start = peek();
		advance();
		consume(TokenType::Symbol, ";", "Expect ';' after 'continue'.");
		auto node = std::make_unique<ContinueStmt>();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Keyword) && peek().lexeme == "unsafe")
	{
		Token start = peek();
		advance();
		auto node = unsafeStatement();
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (check(TokenType::Symbol) && peek().lexeme == "{")
	{
		Token start = peek();
		advance();
		auto blk = block();
		blk->line = start.line;
		blk->column = start.column;
		return blk;
	}
	return expressionStatement();
}

std::unique_ptr<Statement> Parser::ifStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'if'.");
	auto condition = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after if condition.");
	auto                       thenBranch = statement();
	std::unique_ptr<Statement> elseBranch = nullptr;
	if (match(TokenType::Keyword, "else"))
	{
		elseBranch = statement();
	}
	return std::make_unique<IfStmt>(std::move(condition), std::move(thenBranch), std::move(elseBranch));
	// Note: line/column is set by the caller (statement()) from the 'if' keyword token.
}

std::unique_ptr<Statement> Parser::whileStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'while'.");
	auto condition = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after while condition.");
	auto body = statement();
	return std::make_unique<WhileStmt>(std::move(condition), std::move(body));
}

std::unique_ptr<Statement> Parser::forStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'for'.");

	std::unique_ptr<Statement> initializer = nullptr;
	if (!check(TokenType::Symbol) || peek().lexeme != ";")
	{
		if (check(TokenType::Keyword) && peek().lexeme == "var")
		{
			advance();
			initializer = varDeclaration();
		}
		else
		{
			initializer = expressionStatement();
		}
	}
	else
	{
		consume(TokenType::Symbol, ";", "Expect ';'.");
	}

	std::unique_ptr<Expression> condition = nullptr;
	if (!check(TokenType::Symbol) || peek().lexeme != ";")
	{
		condition = expression();
	}
	consume(TokenType::Symbol, ";", "Expect ';' after loop condition.");

	std::unique_ptr<Expression> increment = nullptr;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		increment = expression();
	}
	consume(TokenType::Symbol, ")", "Expect ')' after for clauses.");

	auto body = statement();
	return std::make_unique<ForStmt>(std::move(initializer), std::move(condition), std::move(increment),
	                                 std::move(body));
}

std::unique_ptr<Statement> Parser::switchStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'switch'.");
	auto expr = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after switch expression.");
	consume(TokenType::Symbol, "{", "Expect '{' after switch.");

	std::vector<CaseClause>                 cases;
	std::vector<std::unique_ptr<Statement>> defaultStmts;

	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
		{
			lastError = {"Unterminated switch statement.", peek().line, peek().column};
			throw std::runtime_error("Unterminated switch statement.");
		}

		if (check(TokenType::Keyword) && peek().lexeme == "case")
		{
			advance();
			auto caseValue = expression();
			consume(TokenType::Symbol, ":", "Expect ':' after case value.");

			std::vector<std::unique_ptr<Statement>> stmts;
			while ((!check(TokenType::Keyword) || (peek().lexeme != "case" && peek().lexeme != "default")) &&
			       (!check(TokenType::Symbol) || peek().lexeme != "}"))
			{
				if (isAtEnd())
				{
					lastError = {"Unterminated case clause.", peek().line, peek().column};
					throw std::runtime_error("Unterminated case clause.");
				}
				stmts.push_back(declaration());
			}
			cases.emplace_back(std::move(caseValue), std::move(stmts));
		}
		else if (check(TokenType::Keyword) && peek().lexeme == "default")
		{
			advance();
			consume(TokenType::Symbol, ":", "Expect ':' after default.");

			while ((!check(TokenType::Keyword) || (peek().lexeme != "case" && peek().lexeme != "default")) &&
			       (!check(TokenType::Symbol) || peek().lexeme != "}"))
			{
				if (isAtEnd())
				{
					lastError = {"Unterminated default clause.", peek().line, peek().column};
					throw std::runtime_error("Unterminated default clause.");
				}
				defaultStmts.push_back(declaration());
			}
		}
		else
		{
			lastError = {"Expected 'case' or 'default' in switch statement.", peek().line, peek().column};
			throw std::runtime_error("Expected 'case' or 'default' in switch statement.");
		}
	}

	consume(TokenType::Symbol, "}", "Expect '}' after switch body.");
	return std::make_unique<SwitchStmt>(std::move(expr), std::move(cases), std::move(defaultStmts));
}

std::unique_ptr<Statement> Parser::returnStatement()
{
	std::unique_ptr<Expression> value = nullptr;
	if (!check(TokenType::Symbol) || peek().lexeme != ";")
	{
		value = expression();
	}
	consume(TokenType::Symbol, ";", "Expect ';' after return value.");
	return std::make_unique<ReturnStmt>(std::move(value));
	// Note: line/column is set by the caller (statement()) from the 'return' keyword token.
}

std::unique_ptr<Statement> Parser::unsafeStatement()
{
	consume(TokenType::Symbol, "{", "Expect '{' after 'unsafe'.");
	return std::make_unique<UnsafeBlockStmt>(block());
}

std::unique_ptr<BlockStmt> Parser::block()
{
	std::vector<std::unique_ptr<Statement>> statements;
	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
		{
			lastError = {"Unterminated block.", peek().line, peek().column};
			throw std::runtime_error("Unterminated block.");
		}
		statements.push_back(declaration());
	}
	consume(TokenType::Symbol, "}", "Expect '}' after block.");
	return std::make_unique<BlockStmt>(std::move(statements));
}

std::unique_ptr<Statement> Parser::printStatement()
{
	auto expr = expression();
	consume(TokenType::Symbol, ";", "Expect ';' after print statement.");
	return std::make_unique<PrintStmt>(std::move(expr));
	// Note: line/column set by caller (statement()) from the 'print' keyword token.
}

std::unique_ptr<Statement> Parser::importStatement()
{
	Token path = consume(TokenType::String, "Expect string after 'import'.");
	consume(TokenType::Symbol, ";", "Expect ';' after import statement.");
	auto node = std::make_unique<ImportStmt>(path.lexeme);
	node->line = path.line;
	node->column = path.column;
	return node;
}

std::unique_ptr<Statement> Parser::exportStatement()
{
	auto node = std::make_unique<ExportStmt>(declaration());
	// line/column set by caller (declaration()) from the 'export' keyword token.
	return node;
}

std::unique_ptr<Statement> Parser::expressionStatement()
{
	Token start = peek();
	auto  expr = expression();
	consume(TokenType::Symbol, ";", "Expect ';' after expression.");
	auto node = std::make_unique<ExpressionStmt>(std::move(expr));
	node->line = start.line;
	node->column = start.column;
	return node;
}

std::unique_ptr<Expression> Parser::expression()
{
	return assignment();
}

std::unique_ptr<Expression> Parser::assignment()
{
	auto expr = logicalOr();

	if (match(TokenType::Symbol, "="))
	{
		Token op = previous();
		auto  value = assignment(); // Right-associative
		auto  node = std::make_unique<AssignmentExpr>(std::move(expr), std::move(value));
		node->line = op.line;
		node->column = op.column;
		return node;
	}

	return expr;
}

std::unique_ptr<Expression> Parser::logicalOr()
{
	auto expr = logicalAnd();

	while (check(TokenType::Symbol) && peek().lexeme == "||")
	{
		Token op = advance();
		auto  right = logicalAnd();
		auto  node = std::make_unique<BinaryExpr>(std::move(expr), BinaryOp::Or, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::logicalAnd()
{
	auto expr = equality();

	while (check(TokenType::Symbol) && peek().lexeme == "&&")
	{
		Token op = advance();
		auto  right = equality();
		auto  node = std::make_unique<BinaryExpr>(std::move(expr), BinaryOp::And, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::equality()
{
	auto expr = comparison();

	while (check(TokenType::Symbol) && (peek().lexeme == "==" || peek().lexeme == "!="))
	{
		Token    op = advance();
		auto     right = comparison();
		BinaryOp binOp = (op.lexeme == "==") ? BinaryOp::Equal : BinaryOp::NotEqual;
		auto     node = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::comparison()
{
	auto expr = term();

	while (check(TokenType::Symbol) &&
	       (peek().lexeme == "<" || peek().lexeme == ">" || peek().lexeme == "<=" || peek().lexeme == ">="))
	{
		Token    op = advance();
		auto     right = term();
		BinaryOp binOp;
		if (op.lexeme == "<")
			binOp = BinaryOp::LessThan;
		else if (op.lexeme == ">")
			binOp = BinaryOp::GreaterThan;
		else if (op.lexeme == "<=")
			binOp = BinaryOp::LessEqual;
		else
			binOp = BinaryOp::GreaterEqual;

		auto node = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::term()
{
	auto expr = factor();

	while (check(TokenType::Symbol) && (peek().lexeme == "+" || peek().lexeme == "-"))
	{
		Token    op = advance();
		auto     right = factor();
		BinaryOp binOp = (op.lexeme == "+") ? BinaryOp::Add : BinaryOp::Subtract;
		auto     node = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::factor()
{
	auto expr = unary();

	while (check(TokenType::Symbol) && (peek().lexeme == "*" || peek().lexeme == "/" || peek().lexeme == "%"))
	{
		Token    op = advance();
		auto     right = unary();
		BinaryOp binOp;
		if (op.lexeme == "*")
			binOp = BinaryOp::Multiply;
		else if (op.lexeme == "/")
			binOp = BinaryOp::Divide;
		else
			binOp = BinaryOp::Modulo;

		auto node = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
		node->line = op.line;
		node->column = op.column;
		expr = std::move(node);
	}

	return expr;
}

std::unique_ptr<Expression> Parser::unary()
{
	if (check(TokenType::Symbol) && (peek().lexeme == "!" || peek().lexeme == "-"))
	{
		Token   op = advance();
		auto    right = unary();
		UnaryOp uOp = (op.lexeme == "!") ? UnaryOp::Not : UnaryOp::Negate;
		auto    node = std::make_unique<UnaryExpr>(uOp, std::move(right));
		node->line = op.line;
		node->column = op.column;
		return node;
	}
	if (check(TokenType::Symbol) && peek().lexeme == "&")
	{
		Token op = advance();
		auto  right = unary();
		auto  node = std::make_unique<UnaryExpr>(UnaryOp::AddressOf, std::move(right));
		node->line = op.line;
		node->column = op.column;
		return node;
	}
	if (check(TokenType::Symbol) && peek().lexeme == "*")
	{
		Token op = advance();
		auto  right = unary();
		auto  node = std::make_unique<UnaryExpr>(UnaryOp::Dereference, std::move(right));
		node->line = op.line;
		node->column = op.column;
		return node;
	}
	return call();
}

std::unique_ptr<Expression> Parser::call()
{
	auto expr = primary();

	while (true)
	{
		if (match(TokenType::Symbol, "("))
		{
			Token op = previous();
			expr = finishCall(std::move(expr));
			expr->line = op.line;
			expr->column = op.column;
		}
		else if (match(TokenType::Symbol, "."))
		{
			Token op = previous();
			expr = fieldAccess(std::move(expr));
			expr->line = op.line;
			expr->column = op.column;
		}
		else if (match(TokenType::Symbol, "++"))
		{
			Token op = previous();
			auto  node = std::make_unique<PostfixExpr>(PostfixOp::Increment, std::move(expr));
			node->line = op.line;
			node->column = op.column;
			expr = std::move(node);
		}
		else if (match(TokenType::Symbol, "--"))
		{
			Token op = previous();
			auto  node = std::make_unique<PostfixExpr>(PostfixOp::Decrement, std::move(expr));
			node->line = op.line;
			node->column = op.column;
			expr = std::move(node);
		}
		else if (match(TokenType::Symbol, "["))
		{
			Token op = previous();
			auto  index = expression();
			consume(TokenType::Symbol, "]", "Expect ']' after index.");
			auto node = std::make_unique<ArrayAccessExpr>(std::move(expr), std::move(index));
			node->line = op.line;
			node->column = op.column;
			expr = std::move(node);
		}
		else
		{
			break;
		}
	}

	return expr;
}

std::unique_ptr<Expression> Parser::finishCall(std::unique_ptr<Expression> callee)
{
	std::vector<std::unique_ptr<Expression>> arguments;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		do
		{
			arguments.push_back(expression());
		} while (match(TokenType::Symbol, ","));
	}
	consume(TokenType::Symbol, ")", "Expect ')' after arguments.");

	// For now, we only support direct function calls by name, or calls on field access which are
	// rewritten to pass the object as the first argument.
	if (auto ident = dynamic_cast<IdentifierExpr *>(callee.get()))
	{
		auto node = std::make_unique<CallExpr>(ident->name, std::move(arguments));
		node->line = ident->line;
		node->column = ident->column;
		return node;
	}
	else if (auto field = dynamic_cast<FieldAccessExpr *>(callee.get()))
	{
		// Transform obj.method(args) -> method(obj, args)
		std::string methodName = field->fieldName;
		size_t      fline = field->line, fcol = field->column;
		arguments.insert(arguments.begin(), std::move(field->object));
		auto node = std::make_unique<CallExpr>(methodName, std::move(arguments));
		node->line = fline;
		node->column = fcol;
		return node;
	}
	lastError = {"Can only call named functions.", peek().line, peek().column};
	throw std::runtime_error("Can only call named functions.");
}

std::unique_ptr<Expression> Parser::primary()
{
	if (match(TokenType::Number))
	{
		Token t = previous();
		auto  node = std::make_unique<NumberExpr>(t.lexeme);
		node->line = t.line;
		node->column = t.column;
		return node;
	}
	if (match(TokenType::String))
	{
		Token t = previous();
		auto  node = std::make_unique<StringExpr>(t.lexeme);
		node->line = t.line;
		node->column = t.column;
		return node;
	}
	if (check(TokenType::Identifier))
	{
		// Look ahead for struct instance syntax: Name{ ... }
		Token identTok = peek();
		if (!isAtEnd() && peekNext().type == TokenType::Symbol && peekNext().lexeme == "{")
		{
			return structInstance();
		}
		advance();
		auto node = std::make_unique<IdentifierExpr>(identTok.lexeme);
		node->line = identTok.line;
		node->column = identTok.column;
		return node;
	}
	if (match(TokenType::Symbol, "["))
	{
		Token                                    start = previous();
		std::vector<std::unique_ptr<Expression>> elements;
		if (!check(TokenType::Symbol) || peek().lexeme != "]")
		{
			do
			{
				elements.push_back(expression());
			} while (match(TokenType::Symbol, ","));
		}
		consume(TokenType::Symbol, "]", "Expect ']' after array elements.");
		auto node = std::make_unique<ArrayLiteralExpr>(std::move(elements));
		node->line = start.line;
		node->column = start.column;
		return node;
	}
	if (match(TokenType::Keyword, "true"))
	{
		Token t = previous();
		auto  node = std::make_unique<BooleanExpr>(true);
		node->line = t.line;
		node->column = t.column;
		return node;
	}
	if (match(TokenType::Keyword, "false"))
	{
		Token t = previous();
		auto  node = std::make_unique<BooleanExpr>(false);
		node->line = t.line;
		node->column = t.column;
		return node;
	}
	if (match(TokenType::Keyword, "null"))
	{
		Token t = previous();
		auto  node = std::make_unique<NullExpr>();
		node->line = t.line;
		node->column = t.column;
		return node;
	}
	if (match(TokenType::Symbol, "("))
	{
		auto expr = expression();
		consume(TokenType::Symbol, ")", "Expect ')' after expression.");
		return expr;
	}
	std::cerr << "Error: Expect expression at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")\n";
	lastError = {"Expect expression", peek().line, peek().column};
	throw std::runtime_error("Expect expression.");
}

// Struct declaration
// struct Point { x: int, y: int }
std::unique_ptr<StructDecl> Parser::structDecl()
{
	// 'struct' keyword
	Token start = peek();
	consume(TokenType::Keyword, "struct", "Expected 'struct'");
	Token nameTok = consume(TokenType::Identifier, "Expected struct name");
	consume(TokenType::Symbol, "{", "Expected '{' in struct declaration");

	std::vector<StructField> fields;
	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
		{
			lastError = {"Unterminated struct declaration", peek().line, peek().column};
			throw std::runtime_error("Unterminated struct declaration.");
		}

		Token fieldNameTok = consume(TokenType::Identifier, "Expected field name");
		consume(TokenType::Symbol, ":", "Expected ':' after field name");
		auto type = parseType();
		fields.emplace_back(fieldNameTok.lexeme, std::move(type));

		if (!match(TokenType::Symbol, ","))
		{
			break;
		}
	}

	consume(TokenType::Symbol, "}", "Expected '}' after struct fields");
	auto node = std::make_unique<StructDecl>(nameTok.lexeme, std::move(fields));
	node->line = start.line;
	node->column = start.column;
	return node;
}

// Struct instantiation
// Point{ x: 10, y: 20 }
std::unique_ptr<StructInstanceExpr> Parser::structInstance()
{
	Token nameTok = consume(TokenType::Identifier, "Expected struct name");
	consume(TokenType::Symbol, "{", "Expected '{' in struct instance");

	std::vector<std::pair<std::string, std::unique_ptr<Expression>>> fields;
	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
		{
			lastError = {"Unterminated struct instance.", peek().line, peek().column};
			throw std::runtime_error("Unterminated struct instance.");
		}
		Token fieldNameTok = consume(TokenType::Identifier, "Expected field name");
		consume(TokenType::Symbol, ":", "Expected ':' after field name");
		auto value = expression();
		fields.emplace_back(fieldNameTok.lexeme, std::move(value));

		if (!match(TokenType::Symbol, ","))
		{
			break;
		}
	}

	consume(TokenType::Symbol, "}", "Expected '}' after struct fields");
	auto node = std::make_unique<StructInstanceExpr>(nameTok.lexeme, std::move(fields));
	node->line = nameTok.line;
	node->column = nameTok.column;
	return node;
}

// Field access
// point.x
std::unique_ptr<Expression> Parser::fieldAccess(std::unique_ptr<Expression> object)
{
	Token nameTok = consume(TokenType::Identifier, "Expected field name after '.'");
	auto  node = std::make_unique<FieldAccessExpr>(std::move(object), nameTok.lexeme);
	node->line = nameTok.line;
	node->column = nameTok.column;
	return node;
}

Token Parser::peek()
{
	return tokens[current];
}

Token Parser::peekNext()
{
	if (current + 1 >= static_cast<int>(tokens.size()))
	{
		return tokens[current];
	}
	return tokens[current + 1];
}

Token Parser::previous()
{
	return tokens[current - 1];
}

Token Parser::advance()
{
	if (!isAtEnd())
		current++;
	return previous();
}

bool Parser::isAtEnd()
{
	return peek().type == TokenType::EndOfFile;
}

bool Parser::check(TokenType type)
{
	if (isAtEnd())
		return false;
	return peek().type == type;
}

bool Parser::match(TokenType type)
{
	if (check(type))
	{
		advance();
		return true;
	}
	return false;
}

Token Parser::consume(TokenType type, std::string message)
{
	if (check(type))
		return advance();

	std::cerr << "Error: " << message << " at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")";
	if (!currentFunction.empty())
		std::cerr << " [in function '" << currentFunction << "']";
	std::cerr << "\n";
	lastError = {message, peek().line, peek().column};
	throw std::runtime_error(message);
}

bool Parser::match(TokenType type, std::string lexeme)
{
	if (check(type) && peek().lexeme == lexeme)
	{
		advance();
		return true;
	}
	return false;
}

Token Parser::consume(TokenType type, std::string lexeme, std::string message)
{
	if (check(type) && peek().lexeme == lexeme)
	{
		return advance();
	}

	std::cerr << "Error: " << message << " at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")";
	if (!currentFunction.empty())
		std::cerr << " [in function '" << currentFunction << "']";
	std::cerr << "\n";

	lastError = {message, peek().line, peek().column};
	throw std::runtime_error(message);
}

Token Parser::expect(TokenType type, const std::string &message)
{
	if (check(type))
	{
		return advance();
	}
	lastError = {message, peek().line, peek().column};
	throw std::runtime_error(message);
}
} // namespace Phasor

--- .\src\Language\Phasor\Parser\Parser.hpp ---
#pragma once
#include "../../../AST/AST.hpp"
#include <memory>
#include <optional>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/// @brief Parser
class Parser
{
  public:
	Parser(const std::vector<Token> &tokens);
	std::unique_ptr<AST::Program> parse();
	
	struct Error
	{
		std::string message;
		size_t      line;
		size_t      column;
	};
	std::optional<Error> getError() const
	{
		return lastError;
	}
  private:
	std::vector<Token> tokens;
	int                current = 0;
	std::string        currentFunction = "";
	std::optional<Error> lastError;

	Token peek();
	Token previous();
	Token advance();
	bool  isAtEnd();
	bool  check(TokenType type);
	Token peekNext();
	bool  match(TokenType type);
	bool  match(TokenType type, std::string lexeme);
	Token consume(TokenType type, std::string message);
	Token consume(TokenType type, std::string lexeme, std::string message);
	Token expect(TokenType type, const std::string &message);

	std::unique_ptr<AST::Statement>          declaration();
	std::unique_ptr<AST::Statement>          varDeclaration();
	std::unique_ptr<AST::Statement>          functionDeclaration();
	std::unique_ptr<AST::Statement>          statement();
	std::unique_ptr<AST::Statement>          printStatement();
	std::unique_ptr<AST::Statement>          ifStatement();
	std::unique_ptr<AST::Statement>          whileStatement();
	std::unique_ptr<AST::Statement>          forStatement();
	std::unique_ptr<AST::Statement>          switchStatement();
	std::unique_ptr<AST::Statement>          returnStatement();
	std::unique_ptr<AST::Statement>          unsafeStatement();
	std::unique_ptr<AST::BlockStmt>          block();
	std::unique_ptr<AST::Statement>          importStatement();
	std::unique_ptr<AST::Statement>          exportStatement();
	std::unique_ptr<AST::Statement>          expressionStatement();
	std::unique_ptr<AST::TypeNode>           parseType();
	std::unique_ptr<AST::Expression>         expression();
	std::unique_ptr<AST::Expression>         assignment();
	std::unique_ptr<AST::Expression>         logicalOr();
	std::unique_ptr<AST::Expression>         logicalAnd();
	std::unique_ptr<AST::Expression>         equality();
	std::unique_ptr<AST::Expression>         comparison();
	std::unique_ptr<AST::Expression>         term();
	std::unique_ptr<AST::Expression>         factor();
	std::unique_ptr<AST::Expression>         unary();
	std::unique_ptr<AST::Expression>         call();
	std::unique_ptr<AST::Expression>         finishCall(std::unique_ptr<AST::Expression> callee);
	std::unique_ptr<AST::Expression>         primary();
	std::unique_ptr<AST::StructDecl>         structDecl();
	std::unique_ptr<AST::StructInstanceExpr> structInstance();
	std::unique_ptr<AST::Expression>         fieldAccess(std::unique_ptr<AST::Expression> object);
};
} // namespace Phasor

--- .\src\Language\Pulsar\Lexer\Lexer.cpp ---
﻿#include "Lexer.hpp"
#include <cctype>
#include <sstream>
#include <stdexcept>

namespace pulsar
{

Lexer::Lexer(const std::string &source) : source(source)
{
}

void Lexer::skipShebang()
{
	if (position == 0 && peek() == '#' && position + 1 < source.length() && source[position + 1] == '!')
	{
		while (!isAtEnd() && peek() != '\n')
		{
			advance();
		}
	}
}

std::vector<Phasor::Token> Lexer::tokenize()
{
	std::vector<Phasor::Token> tokens;
	skipShebang();
	while (!isAtEnd())
	{
		skipWhitespace();
		if (isAtEnd())
			break;
		tokens.push_back(scanToken());
	}
	tokens.push_back({Phasor::TokenType::EndOfFile, "", line, column});
	return tokens;
}

char Lexer::peek()
{
	if (isAtEnd())
		return '\0';
	return source[position];
}

char Lexer::advance()
{
	char c = source[position++];
	column++;
	if (c == '\n')
	{
		line++;
		column = 1;
	}
	return c;
}

bool Lexer::isAtEnd()
{
	return position >= source.length();
}

void Lexer::skipWhitespace()
{
	while (!isAtEnd())
	{
		char c = peek();
		if (std::isspace(static_cast<unsigned char>(c)))
		{
			advance();
		}
		else if (c == '/' && position + 1 < source.length() && source[position + 1] == '/')
		{
			// Skip single-line comment
			while (!isAtEnd() && peek() != '\n')
			{
				advance();
			}
		}
		else
		{
			break;
		}
	}
}

Phasor::Token Lexer::scanToken()
{
	char c = peek();
	if (std::isalpha(static_cast<unsigned char>(c)))
		return identifier();
	if (std::isdigit(static_cast<unsigned char>(c)))
		return number();
	if (c == '"')
		return string();
	if (c == '`')
		return complexString();

	// Multi-character operators
	if (c == '+' && position + 1 < source.length() && source[position + 1] == '+')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "++", line, column};
	}
	if (c == '-' && position + 1 < source.length() && source[position + 1] == '-')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "--", line, column};
	}
	if (c == '=' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "==", line, column};
	}
	if (c == '!' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "!=", line, column};
	}
	if (c == '-' && position + 1 < source.length() && source[position + 1] == '>')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "->", line, column};
	}
	if (c == '<' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "<=", line, column};
	}
	if (c == '>' && position + 1 < source.length() && source[position + 1] == '=')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, ">=", line, column};
	}
	if (c == '&' && position + 1 < source.length() && source[position + 1] == '&')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "&&", line, column};
	}
	if (c == '|' && position + 1 < source.length() && source[position + 1] == '|')
	{
		advance();
		advance();
		return {Phasor::TokenType::Symbol, "||", line, column};
	}

	// Single-character symbols (parentheses, operators, punctuation, etc.)
	if (std::string("()+-*/%<>=!&|.{}:;,[]").find(c) != std::string::npos)
	{
		advance();
		return {Phasor::TokenType::Symbol, std::string(1, c), line, column};
	}

	advance();
	return {Phasor::TokenType::Unknown, std::string(1, c), line, column};
}

Phasor::Token Lexer::identifier()
{
	size_t start = position;
	while (std::isalnum(static_cast<unsigned char>(peek())) || peek() == '_')
		advance();
	std::string text = source.substr(start, position - start);

	static const std::vector<std::string> keywords = {"let", "func", "print", "if", "else", "while"};

	for (const auto &kw : keywords)
	{
		if (text == kw)
		{
			return {Phasor::TokenType::Keyword, text, line, column};
		}
	}

	return {Phasor::TokenType::Identifier, text, line, column};
}

Phasor::Token Lexer::number()
{
	size_t start = position;
	while (std::isdigit(static_cast<unsigned char>(peek())))
		advance();
	if (peek() == '.' && position + 1 < source.length() &&
	    std::isdigit(static_cast<unsigned char>(source[position + 1])))
	{
		advance();
		while (std::isdigit(static_cast<unsigned char>(peek())))
			advance();
	}
	return {Phasor::TokenType::Number, source.substr(start, position - start), line, column};
}

static int hexValue(char c)
{
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return 10 + (c - 'a');
	if (c >= 'A' && c <= 'F')
		return 10 + (c - 'A');
	return -1;
}

Phasor::Token Lexer::string()
{
	size_t             tokenLine = line;
	size_t             tokenColumn = column;
	std::ostringstream out;
	advance(); // Skip opening quote

	while (!isAtEnd())
	{
		char c = advance();

		// Raw newline inside a string is treated as unterminated/error.
		if (c == '\n')
		{
			// Unterminated string literal
			return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
		}

		if (c == '\\')
		{
			if (isAtEnd())
			{
				// Unterminated escape at end of file
				return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
			}
			char esc = advance();
			switch (esc)
			{
			case 'n':
				out << '\n';
				break;
			case 't':
				out << '\t';
				break;
			case 'r':
				out << '\r';
				break;
			case '\\':
				out << '\\';
				break;
			case '"':
				out << '"';
				break;
			case '\'':
				out << '\'';
				break;
			case '0':
				out << '\0';
				break;
			case 'b':
				out << '\b';
				break;
			case 'f':
				out << '\f';
				break;
			case 'v':
				out << '\v';
				break;
			case 'x': {
				// Hex escape sequence: \xHH
				if (isAtEnd())
					return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char h1 = advance();
				if (isAtEnd())
					return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char h2 = advance();
				int  v1 = hexValue(h1), v2 = hexValue(h2);
				if (v1 < 0 || v2 < 0)
					return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
				char value = static_cast<char>((v1 << 4) | v2);
				out << value;
				break;
			}
			default:
				// Unknown escape: be permissive and append the escaped character as-is.
				out << esc;
				break;
			}
		}
		else if (c == '"')
		{
			// Closing quote
			return {Phasor::TokenType::String, out.str(), tokenLine, tokenColumn};
		}
		else
		{
			out << c;
		}
	}

	// If we get here, string was unterminated
	return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
}

Phasor::Token Lexer::complexString()
{
	size_t             tokenLine = line;
	size_t             tokenColumn = column;
	std::ostringstream out;
	advance(); // Skip opening backtick

	// Not even attempting ${} syntax for now. Just read as a raw string.

	while (!isAtEnd())
	{
		char c = advance();

		if (c == '`')
		{
			// Closing backtick
			return {Phasor::TokenType::String, out.str(), tokenLine, tokenColumn};
		}
		else
		{
			out << c;
		}
	}

	// If we get here, string was unterminated
	return {Phasor::TokenType::Unknown, std::string(), tokenLine, tokenColumn};
}
} // namespace pulsar

--- .\src\Language\Pulsar\Lexer\Lexer.hpp ---
#pragma once
#include "../../../AST/AST.hpp"
#include <string>
#include <vector>
#include <iostream>
/// @brief The Pulsar Scripting Language
namespace pulsar
{
/// @brief Pulsar Lexer
class Lexer
{
  public:
	Lexer(const std::string &source);
	std::vector<Phasor::Token> tokenize();

  private:
	std::string source;
	size_t      position = 0;
	size_t      line = 1;
	size_t      column = 1;

	char          peek();
	char          advance();
	bool          isAtEnd();
	void          skipWhitespace();
	void          skipShebang();
	Phasor::Token scanToken();
	Phasor::Token identifier();
	Phasor::Token number();
	Phasor::Token string();
	Phasor::Token complexString();
};
} // namespace pulsar

--- .\src\Language\Pulsar\Parser\Parser.cpp ---
#include "Parser.hpp"
#include <iostream>

namespace pulsar
{

Parser::Parser(const std::vector<Token> &tokens) : tokens(tokens)
{
}

std::unique_ptr<Program> Parser::parse()
{
	auto program = std::make_unique<Program>();
	while (!isAtEnd())
	{
		program->statements.push_back(declaration());
	}
	return program;
}

std::unique_ptr<Statement> Parser::declaration()
{
	if (check(TokenType::Keyword) && peek().lexeme == "func")
	{
		advance();
		return functionDeclaration();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "let")
	{
		advance();
		return varDeclaration();
	}
	return statement();
}

std::unique_ptr<Statement> Parser::functionDeclaration()
{
	Token name = consume(TokenType::Identifier, "Expect function name.");
	consume(TokenType::Symbol, "(", "Expect '(' after function name.");
	std::vector<FunctionDecl::Param> params;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		do
		{
			Token paramName = consume(TokenType::Identifier, "Expect parameter name.");
			consume(TokenType::Symbol, ":", "Expect ':' after parameter name.");
			auto type = parseType();
			params.push_back({paramName.lexeme, std::move(type)});
		} while (match(TokenType::Symbol, ","));
	}
	consume(TokenType::Symbol, ")", "Expect ')' after parameters.");

	std::unique_ptr<TypeNode> returnType = nullptr;
	if (match(TokenType::Symbol, "->"))
	{
		returnType = parseType();
	}

	consume(TokenType::Symbol, "{", "Expect '{' before function body.");

	// Track function context for better error messages
	std::string previousFunction = currentFunction;
	currentFunction = name.lexeme;

	auto body = block();

	// Restore previous function context
	currentFunction = previousFunction;

	return std::make_unique<FunctionDecl>(name.lexeme, std::move(params), std::move(returnType), std::move(body));
}

std::unique_ptr<TypeNode> Parser::parseType()
{
	bool isPointer = false;
	if (match(TokenType::Symbol, "*"))
	{
		isPointer = true;
	}
	Token typeName = consume(TokenType::Identifier, "Expect type name.");

	std::vector<int> dims;
	while (match(TokenType::Symbol, "["))
	{
		Token size = consume(TokenType::Number, "Expect array size in type declaration.");
		dims.push_back(std::stoi(size.lexeme));
		consume(TokenType::Symbol, "]", "Expect ']' after array size.");
	}
	return std::make_unique<TypeNode>(typeName.lexeme, isPointer, dims);
}

std::unique_ptr<Statement> Parser::varDeclaration()
{
	Token name = consume(TokenType::Identifier, "Expect variable name.");
	consume(TokenType::Symbol, "=", "Expect '=' after variable name.");
	std::unique_ptr<Expression> initializer = nullptr;
	initializer = expression();
	return std::make_unique<VarDecl>(name.lexeme, std::move(initializer));
}

std::unique_ptr<Statement> Parser::statement()
{
	if (check(TokenType::Keyword) && peek().lexeme == "print")
	{
		advance();
		return printStatement();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "if")
	{
		advance();
		return ifStatement();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "while")
	{
		advance();
		return whileStatement();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "return")
	{
		advance();
		return returnStatement();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "break")
	{
		advance();
		return std::make_unique<BreakStmt>();
	}
	if (check(TokenType::Keyword) && peek().lexeme == "continue")
	{
		advance();
		return std::make_unique<ContinueStmt>();
	}
	if (check(TokenType::Symbol) && peek().lexeme == "{")
	{
		advance();
		auto blk = block();
		return blk;
	}
	return expressionStatement();
}

std::unique_ptr<Statement> Parser::ifStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'if'.");
	auto condition = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after if condition.");
	auto                       thenBranch = statement();
	std::unique_ptr<Statement> elseBranch = nullptr;
	if (match(TokenType::Keyword, "else"))
	{
		elseBranch = statement();
	}
	return std::make_unique<IfStmt>(std::move(condition), std::move(thenBranch), std::move(elseBranch));
}

std::unique_ptr<Statement> Parser::whileStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'while'.");
	auto condition = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after while condition.");
	auto body = statement();
	return std::make_unique<WhileStmt>(std::move(condition), std::move(body));
}

std::unique_ptr<Statement> Parser::forStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'for'.");

	std::unique_ptr<Statement> initializer = nullptr;
	if (check(TokenType::Keyword) && peek().lexeme == "let")
	{
		advance();
		initializer = varDeclaration();
	}
	else
	{
		initializer = expressionStatement();
	}

	std::unique_ptr<Expression> condition = nullptr;
	condition = expression();

	std::unique_ptr<Expression> increment = nullptr;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		increment = expression();
	}
	consume(TokenType::Symbol, ")", "Expect ')' after for clauses.");

	auto body = statement();
	return std::make_unique<ForStmt>(std::move(initializer), std::move(condition), std::move(increment),
	                                 std::move(body));
}

std::unique_ptr<Statement> Parser::switchStatement()
{
	consume(TokenType::Symbol, "(", "Expect '(' after 'switch'.");
	auto expr = expression();
	consume(TokenType::Symbol, ")", "Expect ')' after switch expression.");
	consume(TokenType::Symbol, "{", "Expect '{' after switch.");

	std::vector<CaseClause>                 cases;
	std::vector<std::unique_ptr<Statement>> defaultStmts;

	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
			throw std::runtime_error("Unterminated switch statement.");

		if (check(TokenType::Keyword) && peek().lexeme == "case")
		{
			advance();
			auto caseValue = expression();
			consume(TokenType::Symbol, ":", "Expect ':' after case value.");

			std::vector<std::unique_ptr<Statement>> stmts;
			while ((!check(TokenType::Keyword) || (peek().lexeme != "case" && peek().lexeme != "default")) &&
			       (!check(TokenType::Symbol) || peek().lexeme != "}"))
			{
				if (isAtEnd())
					throw std::runtime_error("Unterminated case clause.");
				stmts.push_back(declaration());
			}
			cases.emplace_back(std::move(caseValue), std::move(stmts));
		}
		else if (check(TokenType::Keyword) && peek().lexeme == "default")
		{
			advance();
			consume(TokenType::Symbol, ":", "Expect ':' after default.");

			while ((!check(TokenType::Keyword) || (peek().lexeme != "case" && peek().lexeme != "default")) &&
			       (!check(TokenType::Symbol) || peek().lexeme != "}"))
			{
				if (isAtEnd())
					throw std::runtime_error("Unterminated default clause.");
				defaultStmts.push_back(declaration());
			}
		}
		else
		{
			throw std::runtime_error("Expected 'case' or 'default' in switch statement.");
		}
	}

	consume(TokenType::Symbol, "}", "Expect '}' after switch body.");
	return std::make_unique<SwitchStmt>(std::move(expr), std::move(cases), std::move(defaultStmts));
}

std::unique_ptr<Statement> Parser::returnStatement()
{
	std::unique_ptr<Expression> value = nullptr;
	value = expression();
	return std::make_unique<ReturnStmt>(std::move(value));
}

std::unique_ptr<BlockStmt> Parser::block()
{
	std::vector<std::unique_ptr<Statement>> statements;
	while (!check(TokenType::Symbol) || peek().lexeme != "}")
	{
		if (isAtEnd())
			throw std::runtime_error("Unterminated block.");
		statements.push_back(declaration());
	}
	consume(TokenType::Symbol, "}", "Expect '}' after block.");
	return std::make_unique<BlockStmt>(std::move(statements));
}

std::unique_ptr<Statement> Parser::printStatement()
{
	auto expr = expression();
	return std::make_unique<PrintStmt>(std::move(expr));
}

std::unique_ptr<Statement> Parser::expressionStatement()
{
	auto expr = expression();
	return std::make_unique<ExpressionStmt>(std::move(expr));
}

std::unique_ptr<Expression> Parser::expression()
{
	return assignment();
}

std::unique_ptr<Expression> Parser::assignment()
{
	auto expr = logicalOr();

	if (match(TokenType::Symbol, "="))
	{
		auto value = assignment();
		return std::make_unique<AssignmentExpr>(std::move(expr), std::move(value));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::logicalOr()
{
	auto expr = logicalAnd();

	while (check(TokenType::Symbol) && peek().lexeme == "||")
	{
		advance();
		auto right = logicalAnd();
		expr = std::make_unique<BinaryExpr>(std::move(expr), BinaryOp::Or, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::logicalAnd()
{
	auto expr = equality();

	while (check(TokenType::Symbol) && peek().lexeme == "&&")
	{
		advance();
		auto right = equality();
		expr = std::make_unique<BinaryExpr>(std::move(expr), BinaryOp::And, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::equality()
{
	auto expr = comparison();

	while (check(TokenType::Symbol) && (peek().lexeme == "==" || peek().lexeme == "!="))
	{
		Token    op = advance();
		auto     right = comparison();
		BinaryOp binOp = (op.lexeme == "==") ? BinaryOp::Equal : BinaryOp::NotEqual;
		expr = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::comparison()
{
	auto expr = term();

	while (check(TokenType::Symbol) &&
	       (peek().lexeme == "<" || peek().lexeme == ">" || peek().lexeme == "<=" || peek().lexeme == ">="))
	{
		Token    op = advance();
		auto     right = term();
		BinaryOp binOp;
		if (op.lexeme == "<")
			binOp = BinaryOp::LessThan;
		else if (op.lexeme == ">")
			binOp = BinaryOp::GreaterThan;
		else if (op.lexeme == "<=")
			binOp = BinaryOp::LessEqual;
		else
			binOp = BinaryOp::GreaterEqual;

		expr = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::term()
{
	auto expr = factor();

	while (check(TokenType::Symbol) && (peek().lexeme == "+" || peek().lexeme == "-"))
	{
		Token    op = advance();
		auto     right = factor();
		BinaryOp binOp = (op.lexeme == "+") ? BinaryOp::Add : BinaryOp::Subtract;
		expr = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::factor()
{
	auto expr = unary();

	while (check(TokenType::Symbol) && (peek().lexeme == "*" || peek().lexeme == "/" || peek().lexeme == "%"))
	{
		Token    op = advance();
		auto     right = unary();
		BinaryOp binOp;
		if (op.lexeme == "*")
			binOp = BinaryOp::Multiply;
		else if (op.lexeme == "/")
			binOp = BinaryOp::Divide;
		else
			binOp = BinaryOp::Modulo;

		expr = std::make_unique<BinaryExpr>(std::move(expr), binOp, std::move(right));
	}

	return expr;
}

std::unique_ptr<Expression> Parser::unary()
{
	if (check(TokenType::Symbol) && (peek().lexeme == "!" || peek().lexeme == "-"))
	{
		Token   op = advance();
		auto    right = unary();
		UnaryOp uOp = (op.lexeme == "!") ? UnaryOp::Not : UnaryOp::Negate;
		return std::make_unique<UnaryExpr>(uOp, std::move(right));
	}
	if (check(TokenType::Symbol) && peek().lexeme == "&")
	{
		advance();
		auto right = unary();
		return std::make_unique<UnaryExpr>(UnaryOp::AddressOf, std::move(right));
	}
	if (check(TokenType::Symbol) && peek().lexeme == "*")
	{
		advance();
		auto right = unary();
		return std::make_unique<UnaryExpr>(UnaryOp::Dereference, std::move(right));
	}
	return call();
}

std::unique_ptr<Expression> Parser::call()
{
	auto expr = primary();

	while (true)
	{
		if (match(TokenType::Symbol, "("))
		{
			expr = finishCall(std::move(expr));
		}
		else if (match(TokenType::Symbol, "++"))
		{
			expr = std::make_unique<PostfixExpr>(PostfixOp::Increment, std::move(expr));
		}
		else if (match(TokenType::Symbol, "--"))
		{
			expr = std::make_unique<PostfixExpr>(PostfixOp::Decrement, std::move(expr));
		}
		else
		{
			break;
		}
	}

	return expr;
}

std::unique_ptr<Expression> Parser::finishCall(std::unique_ptr<Expression> callee)
{
	std::vector<std::unique_ptr<Expression>> arguments;
	if (!check(TokenType::Symbol) || peek().lexeme != ")")
	{
		do
		{
			arguments.push_back(expression());
		} while (match(TokenType::Symbol, ","));
	}
	consume(TokenType::Symbol, ")", "Expect ')' after arguments.");

	// For now, we only support direct function calls by name, or calls on field access which are
	// rewritten to pass the object as the first argument.
	if (auto ident = dynamic_cast<IdentifierExpr *>(callee.get()))
	{
		return std::make_unique<CallExpr>(ident->name, std::move(arguments));
	}
	else if (auto field = dynamic_cast<FieldAccessExpr *>(callee.get()))
	{
		// Transform obj.method(args) -> method(obj, args)
		std::string methodName = field->fieldName;
		arguments.insert(arguments.begin(), std::move(field->object));
		return std::make_unique<CallExpr>(methodName, std::move(arguments));
	}

	throw std::runtime_error("Can only call named functions.");
}

std::unique_ptr<Expression> Parser::primary()
{
	if (match(TokenType::Number))
	{
		return std::make_unique<NumberExpr>(previous().lexeme);
	}
	if (match(TokenType::String))
	{
		return std::make_unique<StringExpr>(previous().lexeme);
	}
	if (check(TokenType::Identifier))
	{
		Token identTok = peek();
		advance();
		return std::make_unique<IdentifierExpr>(identTok.lexeme);
	}
	if (match(TokenType::Keyword, "true"))
	{
		return std::make_unique<BooleanExpr>(true);
	}
	if (match(TokenType::Keyword, "false"))
	{
		return std::make_unique<BooleanExpr>(false);
	}
	if (match(TokenType::Keyword, "null"))
	{
		return std::make_unique<NullExpr>();
	}
	if (match(TokenType::Symbol, "("))
	{
		auto expr = expression();
		consume(TokenType::Symbol, ")", "Expect ')' after expression.");
		return expr;
	}
	std::cerr << "Error: Expect expression at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")\n";
	throw std::runtime_error("Expect expression.");
}

Token Parser::peek()
{
	return tokens[current];
}

Token Parser::peekNext()
{
	if (current + 1 >= static_cast<int>(tokens.size()))
	{
		return tokens[current];
	}
	return tokens[current + 1];
}

Token Parser::previous()
{
	return tokens[current - 1];
}

Token Parser::advance()
{
	if (!isAtEnd())
		current++;
	return previous();
}

bool Parser::isAtEnd()
{
	return peek().type == TokenType::EndOfFile;
}

bool Parser::check(TokenType type)
{
	if (isAtEnd())
		return false;
	return peek().type == type;
}

bool Parser::match(TokenType type)
{
	if (check(type))
	{
		advance();
		return true;
	}
	return false;
}

Token Parser::consume(TokenType type, std::string message)
{
	if (check(type))
		return advance();

	std::cerr << "Error: " << message << " at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")";
	if (!currentFunction.empty())
		std::cerr << " [in function '" << currentFunction << "']";
	std::cerr << "\n";

	throw std::runtime_error(message);
}

bool Parser::match(TokenType type, std::string lexeme)
{
	if (check(type) && peek().lexeme == lexeme)
	{
		advance();
		return true;
	}
	return false;
}

Token Parser::consume(TokenType type, std::string lexeme, std::string message)
{
	if (check(type) && peek().lexeme == lexeme)
	{
		return advance();
	}

	std::cerr << "Error: " << message << " at '" << peek().lexeme << "'";
	std::cerr << " (line " << peek().line << ", column " << peek().column << ")";
	if (!currentFunction.empty())
		std::cerr << " [in function '" << currentFunction << "']";
	std::cerr << "\n";

	throw std::runtime_error(message);
}

Token Parser::expect(TokenType type, const std::string &message)
{
	if (check(type))
	{
		return advance();
	}
	throw std::runtime_error(message);
}
} // namespace pulsar

--- .\src\Language\Pulsar\Parser\Parser.hpp ---
#pragma once
#include "../../../AST/AST.hpp"
#include <memory>
#include <vector>
/// @brief The Pulsar Scripting Language
namespace pulsar
{

using namespace Phasor::AST;
using namespace Phasor;

/// @brief Parser
class Parser
{
  public:
	Parser(const std::vector<Token> &tokens);
	std::unique_ptr<Program> parse();

  private:
	std::vector<Token> tokens;
	int                current = 0;
	std::string        currentFunction = "";

	Token peek();
	Token previous();
	Token advance();
	bool  isAtEnd();
	bool  check(TokenType type);
	Token peekNext();
	bool  match(TokenType type);
	bool  match(TokenType type, std::string lexeme);
	Token consume(TokenType type, std::string message);
	Token consume(TokenType type, std::string lexeme, std::string message);
	Token expect(TokenType type, const std::string &message);

	std::unique_ptr<Statement>  declaration();
	std::unique_ptr<Statement>  varDeclaration();
	std::unique_ptr<Statement>  functionDeclaration();
	std::unique_ptr<Statement>  statement();
	std::unique_ptr<Statement>  printStatement();
	std::unique_ptr<Statement>  ifStatement();
	std::unique_ptr<Statement>  whileStatement();
	std::unique_ptr<Statement>  forStatement();
	std::unique_ptr<Statement>  switchStatement();
	std::unique_ptr<Statement>  returnStatement();
	std::unique_ptr<BlockStmt>  block();
	std::unique_ptr<Statement>  expressionStatement();
	std::unique_ptr<TypeNode>   parseType();
	std::unique_ptr<Expression> expression();
	std::unique_ptr<Expression> assignment();
	std::unique_ptr<Expression> logicalOr();
	std::unique_ptr<Expression> logicalAnd();
	std::unique_ptr<Expression> equality();
	std::unique_ptr<Expression> comparison();
	std::unique_ptr<Expression> term();
	std::unique_ptr<Expression> factor();
	std::unique_ptr<Expression> unary();
	std::unique_ptr<Expression> call();
	std::unique_ptr<Expression> finishCall(std::unique_ptr<Expression> callee);
	std::unique_ptr<Expression> primary();
};
} // namespace pulsar

--- .\src\LSP\CMakeLists.txt ---
add_library(phasor_lsp_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/LSP.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/LSP.hpp
)

target_link_libraries(phasor_lsp_lib phasor_language PhasorCodegen)

--- .\src\LSP\Phasor\LSP.cpp ---
#include "LSP.hpp"
#include <sstream>
#include <stdexcept>

namespace Phasor
{

static inline size_t toLexerLine(size_t lspLine)
{
	return lspLine + 1;
}
static inline size_t toLexerCol(size_t lspCol)
{
	return lspCol + 1;
}

static std::string buildSignature(AST::Node *node)
{
	if (auto *fn = dynamic_cast<AST::FunctionDecl *>(node))
	{
		std::ostringstream ss;
		ss << "fn " << fn->name << "(";
		for (size_t i = 0; i < fn->params.size(); ++i)
		{
			if (i)
				ss << ", ";
			ss << fn->params[i].name << ": ";
			if (fn->params[i].type)
			{
				ss << fn->params[i].type->name;
				if (fn->params[i].type->isPointer)
					ss << "*";
				for (int dim : fn->params[i].type->arrayDimensions)
					ss << "[" << dim << "]";
			}
		}
		ss << ")";
		if (fn->returnType)
		{
			ss << " -> " << fn->returnType->name;
			if (fn->returnType->isPointer)
				ss << "*";
		}
		return ss.str();
	}
	if (auto *st = dynamic_cast<AST::StructDecl *>(node))
	{
		std::ostringstream ss;
		ss << "struct " << st->name << " {";
		for (size_t i = 0; i < st->fields.size(); ++i)
		{
			if (i)
				ss << ", ";
			ss << " " << st->fields[i].name << ": ";
			if (st->fields[i].type)
			{
				ss << st->fields[i].type->name;
				if (st->fields[i].type->isPointer)
					ss << "*";
			}
		}
		ss << " }";
		return ss.str();
	}
	if (auto *vd = dynamic_cast<AST::VarDecl *>(node))
		return "var " + vd->name;

	return "";
}

void LSP::openDocument(const std::string &uri, const std::string &text)
{
	DocumentState doc;
	doc.uri = uri;
	doc.source = text;
	compile(doc);
	documents[uri] = std::move(doc);
}

void LSP::changeDocument(const std::string &uri, const std::string &newText)
{
	auto it = documents.find(uri);
	if (it == documents.end())
	{
		openDocument(uri, newText);
		return;
	}
	DocumentState &doc = it->second;
	doc.source = newText;
	doc.diagnostics.clear();
	doc.globalSymbols.clear();
	doc.program.reset();
	compile(doc);
}

void LSP::closeDocument(const std::string &uri)
{
	documents.erase(uri);
}

std::vector<LSP::Diagnostic> LSP::getDiagnostics(const std::string &uri) const
{
	auto it = documents.find(uri);
	if (it == documents.end())
		return {};
	return it->second.diagnostics;
}

AST::Node *LSP::findNodeAtPosition(const std::string &uri, size_t line, size_t column)
{
	auto it = documents.find(uri);
	if (it == documents.end() || !it->second.program)
		return nullptr;
	return walkForNode(it->second, toLexerLine(line), toLexerCol(column));
}

std::optional<std::string> LSP::getHover(const std::string &uri, size_t line, size_t column)
{
	auto it = documents.find(uri);
	if (it == documents.end() || !it->second.program)
		return std::nullopt;

	const DocumentState &doc = it->second;
	AST::Node           *node = walkForNode(doc, toLexerLine(line), toLexerCol(column));
	if (!node)
		return std::nullopt;

	std::string sig = buildSignature(node);
	if (!sig.empty())
		return sig;

	std::string name = symbolNameAt(node);
	if (name.empty())
		return std::nullopt;

	auto sit = doc.globalSymbols.find(name);
	if (sit == doc.globalSymbols.end())
		return std::nullopt;

	return sit->second.signature.empty() ? name : sit->second.signature;
}

std::optional<LSP::Location> LSP::getDefinition(const std::string &uri, size_t line, size_t column)
{
	auto it = documents.find(uri);
	if (it == documents.end() || !it->second.program)
		return std::nullopt;

	const DocumentState &doc = it->second;
	AST::Node           *node = walkForNode(doc, toLexerLine(line), toLexerCol(column));
	if (!node)
		return std::nullopt;

	std::string name = symbolNameAt(node);
	if (name.empty())
	{
		std::string sig = buildSignature(node);
		if (!sig.empty() && node->line > 0)
		{
			return Location{uri, node->line - 1, node->column > 0 ? node->column - 1 : 0};
		}
		return std::nullopt;
	}

	auto sit = doc.globalSymbols.find(name);
	if (sit == doc.globalSymbols.end())
		return std::nullopt;

	AST::Node *decl = sit->second.declaration;
	if (!decl || decl->line == 0)
		return std::nullopt;

	return Location{uri, decl->line - 1, decl->column > 0 ? decl->column - 1 : 0};
}

namespace
{
AST::Node *walkStmt(AST::Statement *stmt, size_t line, size_t col);
AST::Node *walkExpr(AST::Expression *expr, size_t line, size_t col);
AST::Node *candidate(AST::Node *node, size_t line, size_t col)
{
	if (!node || node->line == 0)
		return nullptr;
	if (node->line == line && node->column <= col)
		return node;
	return nullptr;
}

AST::Node *walkExpr(AST::Expression *expr, size_t line, size_t col)
{
	if (!expr)
		return nullptr;

	if (auto *e = dynamic_cast<AST::BinaryExpr *>(expr))
	{
		if (auto *n = walkExpr(e->left.get(), line, col))
			return n;
		if (auto *n = walkExpr(e->right.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::UnaryExpr *>(expr))
	{
		if (auto *n = walkExpr(e->operand.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::PostfixExpr *>(expr))
	{
		if (auto *n = walkExpr(e->operand.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::AssignmentExpr *>(expr))
	{
		if (auto *n = walkExpr(e->target.get(), line, col))
			return n;
		if (auto *n = walkExpr(e->value.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::CallExpr *>(expr))
	{
		for (const auto &arg : e->arguments)
			if (auto *n = walkExpr(arg.get(), line, col))
				return n;
	}
	else if (auto *e = dynamic_cast<AST::ArrayAccessExpr *>(expr))
	{
		if (auto *n = walkExpr(e->array.get(), line, col))
			return n;
		if (auto *n = walkExpr(e->index.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::ArrayLiteralExpr *>(expr))
	{
		for (const auto &elem : e->elements)
			if (auto *n = walkExpr(elem.get(), line, col))
				return n;
	}
	else if (auto *e = dynamic_cast<AST::MemberAccessExpr *>(expr))
	{
		if (auto *n = walkExpr(e->object.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::FieldAccessExpr *>(expr))
	{
		if (auto *n = walkExpr(e->object.get(), line, col))
			return n;
	}
	else if (auto *e = dynamic_cast<AST::StructInstanceExpr *>(expr))
	{
		for (const auto &fv : e->fieldValues)
			if (auto *n = walkExpr(fv.second.get(), line, col))
				return n;
	}

	return candidate(expr, line, col);
}

AST::Node *walkStmt(AST::Statement *stmt, size_t line, size_t col)
{
	if (!stmt)
		return nullptr;

	if (auto *s = dynamic_cast<AST::BlockStmt *>(stmt))
	{
		for (const auto &child : s->statements)
			if (auto *n = walkStmt(child.get(), line, col))
				return n;
	}
	else if (auto *s = dynamic_cast<AST::ExpressionStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->expression.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::PrintStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->expression.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::VarDecl *>(stmt))
	{
		if (auto *n = walkExpr(s->initializer.get(), line, col))
			return n;
		return candidate(s, line, col);
	}
	else if (auto *s = dynamic_cast<AST::ReturnStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->value.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::IfStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->condition.get(), line, col))
			return n;
		if (auto *n = walkStmt(s->thenBranch.get(), line, col))
			return n;
		if (auto *n = walkStmt(s->elseBranch.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::WhileStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->condition.get(), line, col))
			return n;
		if (auto *n = walkStmt(s->body.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::ForStmt *>(stmt))
	{
		if (auto *n = walkStmt(s->initializer.get(), line, col))
			return n;
		if (auto *n = walkExpr(s->condition.get(), line, col))
			return n;
		if (auto *n = walkExpr(s->increment.get(), line, col))
			return n;
		if (auto *n = walkStmt(s->body.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::SwitchStmt *>(stmt))
	{
		if (auto *n = walkExpr(s->expr.get(), line, col))
			return n;
		for (const auto &c : s->cases)
		{
			if (auto *n = walkExpr(c.value.get(), line, col))
				return n;
			for (const auto &cs : c.statements)
				if (auto *n = walkStmt(cs.get(), line, col))
					return n;
		}
		for (const auto &ds : s->defaultStmts)
			if (auto *n = walkStmt(ds.get(), line, col))
				return n;
	}
	else if (auto *s = dynamic_cast<AST::FunctionDecl *>(stmt))
	{
		if (s->body)
			if (auto *n = walkStmt(s->body.get(), line, col))
				return n;
		return candidate(s, line, col);
	}
	else if (auto *s = dynamic_cast<AST::StructDecl *>(stmt))
	{
		return candidate(s, line, col);
	}
	else if (auto *s = dynamic_cast<AST::ExportStmt *>(stmt))
	{
		if (auto *n = walkStmt(s->declaration.get(), line, col))
			return n;
	}
	else if (auto *s = dynamic_cast<AST::UnsafeBlockStmt *>(stmt))
	{
		if (auto *n = walkStmt(s->block.get(), line, col))
			return n;
	}

	return candidate(stmt, line, col);
}
}

AST::Node *LSP::walkForNode(const DocumentState &doc, size_t line, size_t col)
{
	if (!doc.program)
		return nullptr;
	for (const auto &stmt : doc.program->statements)
		if (auto *n = walkStmt(stmt.get(), line, col))
			return n;
	return nullptr;
}

std::string LSP::symbolNameAt(AST::Node *node) const
{
	if (!node)
		return "";
	if (auto *e = dynamic_cast<AST::IdentifierExpr *>(node))
		return e->name;
	if (auto *e = dynamic_cast<AST::CallExpr *>(node))
		return e->callee;
	if (auto *e = dynamic_cast<AST::StructInstanceExpr *>(node))
		return e->structName;
	if (auto *e = dynamic_cast<AST::FieldAccessExpr *>(node))
		return e->fieldName;
	if (auto *e = dynamic_cast<AST::MemberAccessExpr *>(node))
		return e->member;
	return "";
}

void LSP::computeLineOffsets(DocumentState &doc)
{
	doc.lineStartOffsets.clear();
	doc.lineStartOffsets.push_back(0);
	for (size_t i = 0; i < doc.source.size(); ++i)
		if (doc.source[i] == '\n')
			doc.lineStartOffsets.push_back(i + 1);
}

void LSP::buildGlobalSymbols(DocumentState &doc)
{
	if (!doc.program)
		return;

	auto tryRegister = [&](const std::string &name, AST::Node *node) {
		SymbolInfo info;
		info.name = name;
		info.declaration = node;
		info.signature = buildSignature(node);
		doc.globalSymbols[name] = std::move(info);
	};

	for (const auto &stmt : doc.program->statements)
	{
		if (auto *fn = dynamic_cast<AST::FunctionDecl *>(stmt.get()))
			tryRegister(fn->name, fn);
		else if (auto *st = dynamic_cast<AST::StructDecl *>(stmt.get()))
			tryRegister(st->name, st);
		else if (auto *vd = dynamic_cast<AST::VarDecl *>(stmt.get()))
			tryRegister(vd->name, vd);
		else if (auto *ex = dynamic_cast<AST::ExportStmt *>(stmt.get()))
		{
			if (auto *fn = dynamic_cast<AST::FunctionDecl *>(ex->declaration.get()))
				tryRegister(fn->name, fn);
			else if (auto *st = dynamic_cast<AST::StructDecl *>(ex->declaration.get()))
				tryRegister(st->name, st);
			else if (auto *vd = dynamic_cast<AST::VarDecl *>(ex->declaration.get()))
				tryRegister(vd->name, vd);
		}
	}
}

void LSP::compile(DocumentState &doc)
{
	computeLineOffsets(doc);
	try
	{
		Lexer  lexer(doc.source);
		auto   tokens = lexer.tokenize();
		Parser parser(tokens);
		doc.program = parser.parse();

		if (auto err = lexer.getError())
		{
			doc.diagnostics.push_back({err->message, err->line, err->column, err->line, err->column + 1});
			return;
		}

		if (auto err = parser.getError())
		{
			doc.diagnostics.push_back({err->message, err->line, err->column, err->line, err->column + 1});
			doc.program.reset();
			return;
		}
	}
	catch (const std::runtime_error &e)
	{
		std::cerr << e.what();
	}
	catch (...)
	{
		std::cerr << "Caught unknown exception";
	}
	buildGlobalSymbols(doc);
}

} // namespace Phasor

--- .\src\LSP\Phasor\LSP.hpp ---
#pragma once
#include "../../AST/AST.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include <string>
#include <vector>
#include <unordered_map>
#include <memory>
#include <optional>

namespace Phasor
{
class LSP
{
  public:

	struct Diagnostic
	{
		std::string message;
		size_t      startLine;
		size_t      startColumn;
		size_t      endLine;
		size_t      endColumn;
	};

	struct SymbolInfo
	{
		std::string name;
		AST::Node  *declaration = nullptr;
		std::string signature;
	};

	struct Location
	{
		std::string uri;
		size_t      line;
		size_t      column;
	};

	struct DocumentState
	{
		std::string                   uri;
		std::string                   source;
		std::vector<size_t>           lineStartOffsets;
		std::unique_ptr<AST::Program> program;
		std::vector<Diagnostic>       diagnostics;
		std::unordered_map<std::string, SymbolInfo> globalSymbols;
	};

	LSP() = default;
	~LSP() = default;

	void openDocument(const std::string &uri, const std::string &text);
	void changeDocument(const std::string &uri, const std::string &newText);
	void closeDocument(const std::string &uri);

	std::vector<Diagnostic> getDiagnostics(const std::string &uri) const;

	AST::Node *findNodeAtPosition(const std::string &uri, size_t line, size_t column);

	std::optional<std::string> getHover(const std::string &uri, size_t line, size_t column);

	std::optional<Location> getDefinition(const std::string &uri, size_t line, size_t column);

  private:
	std::unordered_map<std::string, DocumentState> documents;

	void compile(DocumentState &doc);
	void computeLineOffsets(DocumentState &doc);
	void buildGlobalSymbols(DocumentState &doc);
	AST::Node *walkForNode(const DocumentState &doc, size_t line, size_t col);
	std::string symbolNameAt(AST::Node *node) const;
};
} // namespace Phasor

--- .\src\readme.md ---
| Folder     | Description                                      |
| ---------- | ------------------------------------------------ |
| AST        | Abstract Syntax Tree node and Token definitions. |
| Bindings   | Phasor FFI Bindings for OS APIs.                 |
| Codegen    | Phasor VM Code Generation.                       |
| Compiler   | Phasor / Pulsar Compilers.                       |
| Executable | Frontfacing code.                                |
| Extensions | Support for third-party apps/tools.              |
| Frontend   | Wrappers around the core VM for the languages.   |
| ISA        | The OpCode set.                                  |
| Language   | Lexer / Parser Implementations.                  |
| Repl       | REPL Code for Phasor / Pulsar.                   |
| Runtime    | Contains code for the VM, STDLIB, FFI, etc.      |
| utils      | Other misc utils used for Phasor Toolchain.      |


--- .\src\Repl\CMakeLists.txt ---
add_library(phasor_repl_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Repl.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/Repl.hpp
)

target_link_libraries(phasor_repl_lib PUBLIC PhasorCodegen PhasorRuntime phasor_language PhasorFrontend)

--- .\src\Repl\Phasor\Repl.cpp ---
#include "Repl.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include "../../Codegen/Bytecode/BytecodeDeserializer.hpp"
#include "../../Codegen/Bytecode/BytecodeSerializer.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Frontend/Phasor/Frontend.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "../../Codegen/IR/PhasorIR.hpp"

namespace Phasor
{

Repl::Repl(int argc, char *argv[], char *envp[])
{
	m_args.scriptArgc = argc - 1;
	m_args.scriptArgv = argv + 1;
	m_args.envp = envp;
}

int Repl::run()
{
	return runRepl();
}

int Repl::runRepl()
{
	auto vm = createVm();
	return Frontend::runRepl(vm.get());
}

int Repl::runSourceString(const std::string &source, VM &vm)
{
	Lexer  lexer(source);
	auto   tokens = lexer.tokenize();
	Parser parser(tokens);
	auto   program = parser.parse();

	CodeGenerator codegen;
	auto          bytecode = codegen.generate(*program);

	return vm.run(bytecode);
}

std::unique_ptr<VM> Repl::createVm()
{
	auto vm = std::make_unique<VM>();
	StdLib::registerFunctions(*vm);
	StdLib::argv = m_args.scriptArgv;
	StdLib::argc = m_args.scriptArgc;
	StdLib::envp = m_args.envp;

	vm->setImportHandler([vm_ptr = vm.get()](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
			throw std::runtime_error("Could not open imported file: " + path.string());
		std::stringstream buffer;
		buffer << file.rdbuf();
		runSourceString(buffer.str(), *vm_ptr);
	});

	return vm;
}

} // namespace Phasor

--- .\src\Repl\Phasor\Repl.hpp ---
#pragma once

#include <Value.hpp>
#include <filesystem>
#include <memory>
#include <string>
#include <vector>

namespace Phasor
{
class VM;
}

/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

struct AppArgs
{
	int    scriptArgc = 0;
	char **scriptArgv = nullptr;
	char **envp = nullptr;
};

/**
 * @class Repl
 * @brief Read-Eval-Print Loop for Phasor Programming Language
 */
class Repl
{
  public:
	Repl(int argc, char *argv[], char *envp[]);
	int run();

  private:
	int         runRepl();
	static int runSourceString(const std::string &source, VM &vm);

	std::unique_ptr<VM> createVm();

	AppArgs m_args;
};

} // namespace Phasor


--- .\src\Runtime\CMakeLists.txt ---
set(RUNTIME_HEADERS
    ${CMAKE_SOURCE_DIR}/include/Value.hpp
    ${CMAKE_SOURCE_DIR}/src/include/sscanf.h
    ${CMAKE_CURRENT_SOURCE_DIR}/FFI/ffi.hpp
    ${CMAKE_SOURCE_DIR}/include/PhasorFFI.h
    ${CMAKE_SOURCE_DIR}/src/ISA/ISA.hpp
    ${CMAKE_BINARY_DIR}/include/version.h
)

add_subdirectory(FFI)
add_subdirectory(VM)
add_subdirectory(Stdlib)

add_library(PhasorRuntime STATIC ${VM_SOURCES} ${VM_HEADERS} ${FFI_SOURCES} ${FFI_HEADERS} ${RUNTIME_HEADERS} ${STDLIB_SOURCES} ${STDLIB_HEADERS})

add_library(phasor_native_runtime_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/NativeRuntime.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/NativeRuntime.hpp
)

target_link_libraries(phasor_native_runtime_lib PUBLIC PhasorRuntime PhasorCodegen phasor_language)

add_library(phasor_scripting_runtime_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/ScriptingRuntime.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Phasor/ScriptingRuntime.hpp
)

target_link_libraries(phasor_scripting_runtime_lib PUBLIC PhasorRuntime PhasorCodegen phasor_language)

add_library(phasor_binary_runtime_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Shared/BinaryRuntime.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Shared/BinaryRuntime.hpp
)

target_link_libraries(phasor_binary_runtime_lib PUBLIC PhasorRuntime PhasorCodegen)
    
add_library(pulsar_scripting_runtime_lib STATIC
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/ScriptingRuntime.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Pulsar/ScriptingRuntime.hpp
)

target_link_libraries(pulsar_scripting_runtime_lib PUBLIC PhasorRuntime PhasorCodegen pulsar_language)

--- .\src\Runtime\FFI\api.cpp ---
#include "ffi.hpp"

namespace Phasor
{

/**
 * @brief Converts a C-style FFI value to a C++ VM value.
 * @param c_value The C-style value from the plugin.
 * @return The equivalent C++ value for the VM.
 * @note This function is safe for strings, as it copies the C string into a
 *       new C++ std::string, taking ownership of the memory.
 */
Phasor::Value from_c_value(const PhasorValue &c_value)
{
	switch (c_value.type)
	{
	case PHASOR_TYPE_NULL:
		return Phasor::Value();
	case PHASOR_TYPE_BOOL:
		return Phasor::Value(c_value.as.b);
	case PHASOR_TYPE_INT:
		return Phasor::Value(c_value.as.i);
	case PHASOR_TYPE_FLOAT:
		return Phasor::Value(c_value.as.f);
	case PHASOR_TYPE_STRING:
		if (c_value.as.s)
		{
			return Phasor::Value(c_value.as.s);
		}
		return Phasor::Value("");
	case PHASOR_TYPE_ARRAY: {
		std::vector<Phasor::Value> cpp_elements;
		if (c_value.as.a.elements && c_value.as.a.count > 0)
		{
			cpp_elements.reserve(c_value.as.a.count);
			for (size_t i = 0; i < c_value.as.a.count; ++i)
			{
				cpp_elements.push_back(from_c_value(c_value.as.a.elements[i]));
			}
		}
		return Phasor::Value::createArray(std::move(cpp_elements));
	}
	default:
		return Phasor::Value();
	}
}

/**
 * @brief Converts a C++ VM value to a C-style FFI value.
 * @param cpp_value The C++ value from the VM.
 * @param string_arena A vector of unique_ptrs to manage the lifetime of C strings.
 *                     Any strings converted will be allocated and their memory will be
 *                     managed by this arena.
 * @return The equivalent C-style value for the plugin.
 */
PhasorValue to_c_value(const Phasor::Value &cpp_value, std::vector<std::unique_ptr<char[]>> &string_arena,
                       std::vector<std::unique_ptr<PhasorValue[]>> &array_arena)
{
	switch (cpp_value.getType())
	{
	case ValueType::Null:
		return phasor_make_null();
	case ValueType::Bool:
		return phasor_make_bool(cpp_value.asBool());
	case ValueType::Int:
		return phasor_make_int(cpp_value.asInt());
	case ValueType::Float:
		return phasor_make_float(cpp_value.asFloat());
	case ValueType::String: {
		const auto &str = cpp_value.asString();
		auto        c_str = std::make_unique<char[]>(str.length() + 1);
		std::copy(str.begin(), str.end(), c_str.get());
		c_str[str.length()] = '\0';
		PhasorValue val = phasor_make_string(c_str.get());
		string_arena.push_back(std::move(c_str));
		return val;
	}
	case ValueType::Array: {
		const auto &cpp_array = *cpp_value.asArray();
		size_t      count = cpp_array.size();
		if (count == 0)
		{
			return phasor_make_array(nullptr, 0);
		}

		auto c_array = std::make_unique<PhasorValue[]>(count);
		for (size_t i = 0; i < count; ++i)
		{
			c_array[i] = to_c_value(cpp_array[i], string_arena, array_arena);
		}

		PhasorValue val = phasor_make_array(c_array.get(), count);
		array_arena.push_back(std::move(c_array));
		return val;
	}
	default:
		return phasor_make_null();
	}
}

Phasor::Value c_native_func_wrapper(PhasorNativeFunction c_func, Phasor::VM *vm, const std::vector<Phasor::Value> &args)
{
	std::vector<std::unique_ptr<char[]>>        string_arena;
	std::vector<std::unique_ptr<PhasorValue[]>> array_arena;

	std::vector<PhasorValue> c_args;
	c_args.reserve(args.size());
	for (const auto &arg : args)
	{
		c_args.push_back(to_c_value(arg, string_arena, array_arena));
	}

	PhasorValue c_result = c_func(reinterpret_cast<PhasorVM *>(vm), (int)c_args.size(), c_args.data());

	return from_c_value(c_result);
}

void register_native_c_func(PhasorVM *vm, const char *name, PhasorNativeFunction func)
{
	Phasor::VM *cpp_vm = reinterpret_cast<Phasor::VM *>(vm);

	auto wrapper = [func](const std::vector<Phasor::Value> &args, Phasor::VM *vm_param) -> Phasor::Value {
		return c_native_func_wrapper(func, vm_param, args);
	};

	cpp_vm->registerNativeFunction(name, wrapper);
}

} // namespace Phasor


--- .\src\Runtime\FFI\CMakeLists.txt ---
set(FFI_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/ffi.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/api.cpp
)

set(FFI_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/ffi.hpp
)

set(FFI_SOURCES ${FFI_SOURCES} PARENT_SCOPE)
set(FFI_HEADERS ${FFI_HEADERS} PARENT_SCOPE)


--- .\src\Runtime\FFI\ffi.cpp ---
#include "ffi.hpp"
#include <vector>
#include <iostream>
#include <memory>
#include <string>
#include <stdexcept>
#include <sstream>
#include <filesystem>
#if defined(__APPLE__)
#include <mach-o/dyld.h>
#elif defined(__linux__)
#include <unistd.h>
#endif

#define INSTANCED_FFI(fn) [this](const std::vector<Value> &args, VM *vm) { return this->fn(args, vm); }

#define VM_PRINT(str)                                                                                                  \
	vm->setRegister(VM::r0, str);                                                                                      \
	vm->operation(OpCode::PRINT_R, VM::r0);

namespace Phasor
{

/**
 * @brief Loads a plugin, finds its entry point, and initializes it.
 */
bool FFI::loadPlugin(const std::filesystem::path &library, VM *vm)
{
	using PluginEntryFunc = void (*)(const PhasorAPI *, PhasorVM *);

#if defined(_WIN32)
	HMODULE lib = LoadLibraryA(library.string().c_str());
	if (!lib)
	{
		std::stringstream ss;
		ss << "FFI Error: Failed to load library " << library.string() << ". Code: " << GetLastError();
		throw std::runtime_error(ss.str());
		return false;
	}
	auto entry_point = (PluginEntryFunc)GetProcAddress(lib, "phasor_plugin_entry");
#else
	void *lib = dlopen(library.string().c_str(), RTLD_NOW);
	if (!lib)
	{
		std::stringstream ss;
		ss << "FFI Error: Failed to load library " << library.string() << ". Error: " << dlerror();
		throw std::runtime_error(ss.str());
		return false;
	}
	auto entry_point = (PluginEntryFunc)dlsym(lib, "phasor_plugin_entry");
#endif

	if (!entry_point)
	{
		throw std::runtime_error(
		    std::string("FFI Error: Could not find entry point 'phasor_plugin_entry' in " + library.string()));
#if defined(_WIN32)
		FreeLibrary(lib);
#else
		dlclose(lib);
#endif
		return false;
	}

	PhasorAPI api;
	api.register_function = &register_native_c_func;

	entry_point(&api, reinterpret_cast<PhasorVM *>(vm));

	plugins_.push_back(Plugin{lib, library.string(), nullptr});
	return true;
}

bool FFI::addPlugin(const std::filesystem::path &pluginPath)
{
	return loadPlugin(pluginPath, vm_);
}

/**
 * @brief Scans configured plugin directories for shared libraries.
 */
std::vector<std::string> FFI::scanPlugins(const std::filesystem::path &folder)
{
	if (folder.empty())
		return {};

	std::vector<std::string>           plugins;
	std::filesystem::path              exeDir;
	std::vector<std::filesystem::path> foldersToScan;

#if defined(_WIN32)
	char path[MAX_PATH];
	GetModuleFileNameA(nullptr, path, MAX_PATH);
	exeDir = std::filesystem::path(path).parent_path();
#elif defined(__APPLE__)
	char     path[1024];
	uint32_t size = sizeof(path);
	if (_NSGetExecutablePath(path, &size) == 0)
		exeDir = std::filesystem::path(path).parent_path();
	else
		exeDir = std::filesystem::current_path();
#elif defined(__linux__)
	char    path[1024];
	ssize_t count = readlink("/proc/self/exe", path, sizeof(path));
	if (count != -1)
		exeDir = std::filesystem::path(std::string(path, count)).parent_path();
	else
		exeDir = std::filesystem::current_path();
#else
	exeDir = std::filesystem::current_path();
#endif

	foldersToScan.push_back(exeDir / folder);
	if (!std::filesystem::equivalent(exeDir, std::filesystem::current_path()))
	{
		foldersToScan.push_back(std::filesystem::current_path() / folder);
	}

	for (auto &folderPath : foldersToScan)
	{
		if (!std::filesystem::exists(folderPath) || !std::filesystem::is_directory(folderPath))
			continue;

		for (auto &p : std::filesystem::directory_iterator(folderPath))
		{
			if (!p.is_regular_file())
				continue;
			auto ext = p.path().extension().string();
#if defined(_WIN32)
			if (ext == ".dll" || ext == ".phsp")
#elif defined(__APPLE__)
			if (ext == ".dylib" || ext == ".phsp")
#else
			if (ext == ".so" || ext == ".phsp")
#endif
				plugins.push_back(p.path().string());
		}
	}
	return plugins;
}

/**
 * @brief Unloads all currently loaded plugins.
 */
void FFI::unloadAll()
{
	for (auto &plugin : plugins_)
	{
#if defined(_WIN32)
		FreeLibrary(plugin.handle);
#else
		dlclose(plugin.handle);
#endif
	}
	plugins_.clear();
}

FFI::FFI(const std::filesystem::path &pluginFolder, VM *vm) : pluginFolder_(pluginFolder), vm_(vm)
{
	vm->registerNativeFunction("load_plugin", INSTANCED_FFI(FFI::native_add_plugin));
	auto plugins = scanPlugins(pluginFolder_);
	for (const auto &pluginPath : plugins)
	{
		try
		{
			loadPlugin(pluginPath, vm);
		}
		catch (const std::runtime_error &e)
		{
			std::cerr << e.what() << std::endl;
		}
	}
}

FFI::~FFI()
{
	unloadAll();
}

Value FFI::native_add_plugin(const std::vector<Value> &args, VM *)
{
	if (args.size() != 1)
	{
		throw std::runtime_error("load_plugin expects exactly 1 argument: the plugin path.");
	}
	std::filesystem::path pluginPath = args[0].asString();
	if (!std::filesystem::exists(pluginPath))
	{
		throw std::runtime_error("Plugin file does not exist: " + pluginPath.string());
	}
	return addPlugin(pluginPath);
}
} // namespace Phasor


--- .\src\Runtime\FFI\ffi.hpp ---
#pragma once

#include <functional>
#include <Value.hpp>
#include "../VM/VM.hpp"

#include <vector>
#include <string>

#if defined(_WIN32)
#include <windows.h>
#else
#include <dlfcn.h>
#endif

#include <PhasorFFI.h>

typedef void (*FFIFunction)(const PhasorAPI *api, PhasorVM *vm);
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @brief Represents a loaded plugin.
 *
 * Stores the platform-specific library handle, the plugin's file path,
 * the initialization function, and an optional shutdown function.
 */
struct Plugin
{
#if defined(_WIN32)
	HMODULE handle; ///< Windows handle for the loaded library
#else
	void *handle; ///< POSIX handle for the loaded library
#endif
	std::string           path;     ///< Path to the plugin file
	FFIFunction           init;     ///< Plugin initialization function
	std::function<void()> shutdown; ///< Optional shutdown callback
};

/**
 * @brief The "trampoline" that wraps a C function from a plugin.
 *
 * This function is the bridge between the C++ VM and the C plugin. It is called
 * by the VM and is responsible for:
 * 1. Converting C++ arguments to C arguments, with production-ready memory management for strings.
 * 2. Calling the plugin's C function.
 * 3. Converting the C return value back to a C++ value.
 */
Phasor::Value c_native_func_wrapper(PhasorNativeFunction c_func, Phasor::VM *vm,
                                    const std::vector<Phasor::Value> &args);

/**
 * @brief The concrete implementation of the `PhasorRegisterFunction` API call.
 *
 * This function is passed to the plugin. When the plugin calls it, this function
 * creates a C++ lambda that wraps the plugin's C function pointer and registers
 * that lambda with the Phasor VM.
 */
void register_native_c_func(PhasorVM *vm, const char *name, PhasorNativeFunction func);

/**
 * @brief Manages loading, registering, and unloading native FFI plugins.
 *
 * This class scans a folder for plugins, loads them, registers their
 * functions with the VM, and handles cleanup when destroyed.
 */
class FFI
{
  public:
	/**
	 * @brief Constructs the FFI manager and loads plugins.
	 * @param pluginFolder Path to the folder containing plugins.
	 * @param vm Pointer to the Phasor VM instance to register plugin functions with.
	 */
	explicit FFI(const std::filesystem::path &pluginFolder, VM *vm);

	/**
	 * @brief Destructor. Unloads all loaded plugins.
	 */
	~FFI();

	/**
	 * @brief Adds a single plugin from the specified path.
	 * @param pluginPath Path to the plugin file.
	 * @return True if the plugin was added successfully, false otherwise.
	 */
	bool addPlugin(const std::filesystem::path &pluginPath);

	/**
	 * @brief Native function to load a plugin at runtime.
	 */
	Value native_add_plugin(const std::vector<Value> &args, VM *vm);

  private:
	/**
	 * @brief Loads a single plugin from a library file.
	 * @param library Path to the shared library file.
	 * @param vm Pointer to the VM to register plugin functions with.
	 * @return True if the plugin loaded successfully, false otherwise.
	 */
	bool loadPlugin(const std::filesystem::path &library, VM *vm);

	/**
	 * @brief Scans a folder for plugin libraries.
	 * @param folder Path to the folder to scan.
	 * @return A vector of plugin file paths.
	 */
	std::vector<std::string> scanPlugins(const std::filesystem::path &folder);

	/**
	 * @brief Unloads all currently loaded plugins and clears internal state.
	 */
	void unloadAll();

	std::vector<Plugin>   plugins_;      ///< Loaded plugins
	std::filesystem::path pluginFolder_; ///< Plugin search folder
	VM                   *vm_;           ///< Pointer to the Phasor VM
};

} // namespace Phasor


--- .\src\Runtime\Phasor\NativeRuntime.cpp ---
#include "NativeRuntime.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../AST/AST.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Codegen/Bytecode/BytecodeDeserializer.hpp"
#include "../../Codegen/Bytecode/BytecodeSerializer.hpp"
#include "../../Codegen/Cpp/CppCodeGenerator.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/FFI/ffi.hpp"
#include <filesystem>
#include <iostream>

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

namespace Phasor
{

NativeRuntime::NativeRuntime(const std::vector<uint8_t> &bytecodeData, const int argc, const char **argv)
    : m_bytecodeData(bytecodeData), m_argc(argc), m_argv(const_cast<char **>(argv))
{
	BytecodeDeserializer deserializer;
	m_bytecode = deserializer.deserialize(m_bytecodeData);
	m_vm = std::make_unique<VM>();
}

NativeRuntime::NativeRuntime(const std::string &script, const int argc, char **argv)
    : m_script(script), m_argc(argc), m_argv(argv)
{
	Lexer lexer(m_script);
	auto  tokens = lexer.tokenize();

	Parser parser(tokens);
	auto   program = parser.parse();

	CodeGenerator codegen;
	m_bytecode = codegen.generate(*program);
	m_vm = std::make_unique<VM>();

	m_vm->registerNativeFunction("lib_Phasor", runScript);
}

NativeRuntime::~NativeRuntime()
{
	m_vm.reset();
	m_vm = nullptr;
}

void NativeRuntime::addNativeFunction(const std::string &name, void *function)
{
	using RawFunctionPtr = Value (*)(const std::vector<Value> &, VM *);
	RawFunctionPtr rawPtr = reinterpret_cast<RawFunctionPtr>(function);
	NativeFunction nativeFunction = rawPtr;
	m_vm->registerNativeFunction(name, nativeFunction);
}

int NativeRuntime::eval(VM *vm, const std::string &script)
{
	Lexer lexer(script);
	auto  tokens = lexer.tokenize();

	Parser parser(tokens);
	auto   program = parser.parse();

	CodeGenerator codegen;
	auto          bytecode = codegen.generate(*program);

	return vm->run(bytecode);
}

int NativeRuntime::run()
{

	try
	{
		StdLib::argc = m_argc;
		StdLib::argv = m_argv;
		StdLib::registerFunctions(*m_vm);
#if defined(_WIN32)
		FFI ffi("plugins", m_vm.get());
#elif defined(__APPLE__)
		FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", m_vm.get());
#elif defined(__linux__)
		FFI ffi("/opt/Phasor/plugins", m_vm.get());
#endif
		m_vm->setImportHandler([](const std::filesystem::path &path) {
			throw std::runtime_error("Imports not supported in pure binary runtime yet: " + path.string());
		});

		return m_vm->run(m_bytecode);
	}
	catch (const std::exception &e)
	{
		std::string errorMsg = std::string(e.what()) + " | " + m_vm->getInformation() + "\n";
		error(errorMsg);
		return 1;
	}
	return 0;
}

Value NativeRuntime::runScript(const std::vector<Value> &args, VM *)
{
	VM newVM;
	StdLib::checkArgCount(args, 1, "lib_Phasor");
	Lexer lexer(args[1].asString());
	Parser parser(lexer.tokenize());
	CodeGenerator codegen;
	auto program = parser.parse();
	auto bytecode = codegen.generate(*program);
	return newVM.run(bytecode);
}

} // namespace Phasor


--- .\src\Runtime\Phasor\NativeRuntime.hpp ---
#pragma once

#include <vector>
#include <cstdint>
#include <string>
#include "../../Codegen/Bytecode/BytecodeSerializer.hpp"
#include "../../Runtime/VM/VM.hpp"
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class NativeRuntime
 * @brief CLI wrapper for running Phasor scripts and bytecode in-process
 *
 * Allows embedding and running Phasor scripts and bytecode within a native application.
 */
class NativeRuntime
{
  public:
	NativeRuntime(const std::vector<uint8_t> &bytecodeData, const int argc, const char **argv);
	NativeRuntime(const std::string &script, int argc, char **argv);
	~NativeRuntime();
	int  run();
	void addNativeFunction(const std::string &name, void *function);

	static int eval(VM *vm, const std::string &script);

  private:
	static Value runScript(const std::vector<Value> &args, VM *vm); // Run script on independent VM
	Bytecode             m_bytecode;
	std::vector<uint8_t> m_bytecodeData;
	std::string          m_script;
	std::unique_ptr<VM>  m_vm;
	int                  m_argc;
	char               **m_argv;
};

} // namespace Phasor


--- .\src\Runtime\Phasor\ScriptingRuntime.cpp ---
#include "ScriptingRuntime.hpp"
#include "../../Language/Phasor/Lexer/Lexer.hpp"
#include "../../Language/Phasor/Parser/Parser.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Frontend/Phasor/Frontend.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "../../Runtime/FFI/ffi.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

namespace Phasor
{

ScriptingRuntime::ScriptingRuntime(int argc, char *argv[], char *envp[])
{
	m_args.envp = envp;
	parseArguments(argc, argv);
}

int ScriptingRuntime::run()
{
	if (m_args.inputFile.empty())
		return 0;

	return runSource();
}

int ScriptingRuntime::runSource()
{
	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		auto vm = createVm();
		runSourceString(source, *vm);
	}
	catch (const std::exception &e)
	{
		std::string errorMsg = std::string(e.what()) + "\n";
		error(errorMsg);
		return 1;
	}

	return 0;
}

int ScriptingRuntime::runSourceString(const std::string &source, VM &vm)
{
	Lexer  lexer(source);
	auto   tokens = lexer.tokenize();
	Parser parser(tokens);
	auto   program = parser.parse();

	if (m_args.verbose)
	{
		std::cout << "AST:\n";
		program->print();
		std::cout << "\n";
	}

	CodeGenerator codegen;
	auto          bytecode = codegen.generate(*program);

	return vm.run(bytecode);
}

std::unique_ptr<VM> ScriptingRuntime::createVm()
{
	auto vm = std::make_unique<VM>();
	StdLib::registerFunctions(*vm);
	StdLib::argv = m_args.scriptArgv;
	StdLib::argc = m_args.scriptArgc;
	StdLib::envp = m_args.envp;

#if defined(_WIN32)
	FFI ffi("plugins", vm.get());
#elif defined(__APPLE__)
	FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm.get());
#elif defined(__linux__)
	FFI ffi("/opt/Phasor/plugins", vm.get());
#endif

	vm->setImportHandler([this, vm_ptr = vm.get()](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
			throw std::runtime_error("Could not open imported file: " + path.string());
		std::stringstream buffer;
		buffer << file.rdbuf();
		runSourceString(buffer.str(), *vm_ptr);
	});

	return vm;
}

void ScriptingRuntime::parseArguments(int argc, char *argv[])
{
	int defaultArgLocation = 1;
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "-h" || arg == "--help")
		{
			showHelp(argv[0]);
			exit(0);
		}
		else
		{
			defaultArgLocation = i;
			m_args.inputFile = arg;
			break; // Stop parsing after finding the input file
		}
	}
	m_args.scriptArgv = argv + defaultArgLocation;
	m_args.scriptArgc = argc - defaultArgLocation;
}

void ScriptingRuntime::showHelp(const std::string &programName)
{
	std::string filename = std::filesystem::path(programName).filename().string();
	std::cout << "Phasor Scripting Runtime\n\n";
	std::cout << "Usage:\n";
	std::cout << "  " << filename << " [options] [file.phs] [...script args]\n\n";
	std::cout << "Options:\n";
	std::cout << "  -v, --verbose       Enable verbose output (print AST)\n";
	std::cout << "  -h, --help          Show this help message\n";
}

} // namespace Phasor


--- .\src\Runtime\Phasor\ScriptingRuntime.hpp ---
#pragma once

#include <memory>
#include <string>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{
class VM;
}

namespace Phasor
{

/**
 * @class ScriptingRuntime
 * @brief CLI wrapper for running Phasor scripts
 *
 * Loads and executes Phasor source files (.phs files).
 */
class ScriptingRuntime
{
  public:
	ScriptingRuntime(int argc, char *argv[], char *envp[]);
	int run();

  private:
	struct Args
	{
		std::string inputFile;
		bool        verbose = false;
		int         scriptArgc = 0;
		char      **scriptArgv = nullptr;
		char      **envp = nullptr;
	} m_args;

	void parseArguments(int argc, char *argv[]);
	void showHelp(const std::string &programName);

	int  runSource();
	int runSourceString(const std::string &source, VM &vm);

	std::unique_ptr<VM> createVm();
};

} // namespace Phasor


--- .\src\Runtime\Pulsar\ScriptingRuntime.cpp ---
#include "ScriptingRuntime.hpp"
#include "../../Language/Pulsar/Lexer/Lexer.hpp"
#include "../../Language/Pulsar/Parser/Parser.hpp"
#include "../../Codegen/CodeGen.hpp"
#include "../../Frontend/Pulsar/Frontend.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include "../../Runtime/FFI/ffi.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor VM Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

namespace pulsar
{

Interpreter::Interpreter(int argc, char *argv[], char *envp[])
{
	m_args.envp = envp;
	parseArguments(argc, argv);
}

int Interpreter::run()
{
	if (m_args.inputFile.empty())
		return 0;

	return runSource();
}

int Interpreter::runSource()
{
	std::ifstream file(m_args.inputFile);
	if (!file.is_open())
	{
		std::cerr << "Could not open file: " << m_args.inputFile << "\n";
		return 1;
	}

	std::stringstream buffer;
	buffer << file.rdbuf();
	std::string source = buffer.str();

	try
	{
		auto vm = createVm();
		runSourceString(source, *vm);
	}
	catch (const std::exception &e)
	{
		std::string errorMsg = std::string(e.what()) + "\n";
		error(errorMsg);
		return 1;
	}

	return 0;
}

int Interpreter::runSourceString(const std::string &source, Phasor::VM &vm)
{
	Lexer                 lexer(source);
	Parser                parser(lexer.tokenize());
	Phasor::CodeGenerator codegen;
	auto                  program = parser.parse();

	if (m_args.verbose)
	{
		std::cout << "AST:\n";
		program->print();
		std::cout << "\n";
	}
	auto bytecode = codegen.generate(*program);

	return vm.run(bytecode);
}

std::unique_ptr<Phasor::VM> Interpreter::createVm()
{
	auto vm = std::make_unique<Phasor::VM>();
	Phasor::StdLib::registerFunctions(*vm);
	Phasor::StdLib::argv = m_args.scriptArgv;
	Phasor::StdLib::argc = m_args.scriptArgc;
	Phasor::StdLib::envp = m_args.envp;

#if defined(_WIN32)
	Phasor::FFI ffi("plugins", vm.get());
#elif defined(__APPLE__)
	Phasor::FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm.get());
#elif defined(__linux__)
	Phasor::FFI ffi("/opt/Phasor/plugins", vm.get());
#endif

	vm->setImportHandler([this, vm_ptr = vm.get()](const std::filesystem::path &path) {
		std::ifstream file(path);
		if (!file.is_open())
			throw std::runtime_error("Could not open imported file: " + path.string());
		std::stringstream buffer;
		buffer << file.rdbuf();
		runSourceString(buffer.str(), *vm_ptr);
	});

	return vm;
}

void Interpreter::parseArguments(int argc, char *argv[])
{
	m_args.program = std::filesystem::path(argv[0]);
	int defaultArgLocation = 1;
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "-h" || arg == "--help")
		{
			showHelp();
			exit(0);
		}
		else
		{
			defaultArgLocation = i;
			m_args.inputFile = arg;
			break;
		}
	}
	m_args.scriptArgv = argv + defaultArgLocation;
	m_args.scriptArgc = argc - defaultArgLocation;
}

void Interpreter::showHelp()
{
	std::cout << "Usage:\n" << "  " << m_args.program.stem().string() << " [inFile] [...script args]\n\n";
}

} // namespace pulsar


--- .\src\Runtime\Pulsar\ScriptingRuntime.hpp ---
#pragma once

#include <memory>
#include <string>
#include <vector>

#include "../../Runtime/VM/VM.hpp"
/// @brief The Pulsar Scripting Language
namespace pulsar
{

/**
 * @class Interpreter
 * @brief CLI wrapper for running Pulsar scripts
 */
class Interpreter
{
  public:
	Interpreter(int argc, char *argv[], char *envp[]);
	int run();

  private:
	struct Args
	{
		std::filesystem::path inputFile;
		bool                  verbose = false;
		int                   scriptArgc = 0;
		char                **scriptArgv = nullptr;
		char                **envp = nullptr;
		std::filesystem::path program;
	} m_args;

	void parseArguments(int argc, char *argv[]);
	void showHelp();

	int runSource();
	int runSourceString(const std::string &source, Phasor::VM &vm);

	std::unique_ptr<Phasor::VM> createVm();
};

} // namespace pulsar


--- .\src\Runtime\Shared\BinaryRuntime.cpp ---
#include "BinaryRuntime.hpp"
#include "../../Codegen/Bytecode/BytecodeDeserializer.hpp"
#include "../../Runtime/Stdlib/StdLib.hpp"
#include "../../Runtime/VM/VM.hpp"
#include <filesystem>
#include <iostream>
#include "../../Runtime/FFI/ffi.hpp"

#ifdef _WIN32
#include <Windows.h>
#define error(msg) MessageBoxA(NULL, std::string(msg).c_str(), "Phasor Runtime Error", MB_OK | MB_ICONERROR)
#else
#define error(msg) std::cerr << "Error: " << msg << std::endl
#endif

namespace Phasor
{

BinaryRuntime::BinaryRuntime(int argc, char *argv[], char *envp[])
{
	m_args.envp = envp;
	parseArguments(argc, argv);
}

int BinaryRuntime::run()
{
	if (m_args.inputFile.empty())
	{
		std::cerr << "Error: No input file provided\n";
		return 1;
	}

	try
	{
		if (m_args.verbose)
			std::cerr << "DEBUG: Loading bytecode from: " << m_args.inputFile << std::endl;

		BytecodeDeserializer deserializer;
		Bytecode             bytecode = deserializer.loadFromFile(m_args.inputFile);

		if (m_args.verbose)
		{
			std::cerr << "DEBUG: Bytecode loaded successfully" << std::endl;
			std::cerr << "DEBUG: Instructions: " << bytecode.instructions.size() << std::endl;
			std::cerr << "DEBUG: Constants: " << bytecode.constants.size() << std::endl;
		}

		auto vm = std::make_unique<VM>();
		StdLib::registerFunctions(*vm);
		StdLib::argv = m_args.scriptArgv;
		StdLib::argc = m_args.scriptArgc;
		StdLib::envp = m_args.envp;

#if defined(_WIN32)
		FFI ffi("plugins", vm.get());
#elif defined(__APPLE__)
		FFI ffi("/Library/Application Support/org.Phasor.Phasor/plugins", vm.get());
#elif defined(__linux__)
		FFI ffi("/opt/Phasor/plugins", vm.get());
#endif

		vm->setImportHandler([](const std::filesystem::path &path) {
			throw std::runtime_error("Imports not supported in pure binary runtime yet: " + path.string());
		});

		if (m_args.verbose)
			std::cerr << "DEBUG: About to run bytecode" << std::endl;

		int status = vm->run(bytecode);

		if (m_args.verbose)
			std::cerr << "DEBUG: Bytecode execution complete with return " << status << std::endl;

		return status;
	}
	catch (const std::exception &e)
	{
		error(e.what());
		return 1;
	}
}

void BinaryRuntime::parseArguments(int argc, char *argv[])
{
	int defaultArgLocation = 1;
	for (int i = 1; i < argc; i++)
	{
		std::string arg = argv[i];

		if (arg == "-v" || arg == "--verbose")
		{
			m_args.verbose = true;
		}
		else if (arg == "-h" || arg == "--help")
		{
			showHelp(argv[0]);
			exit(0);
		}
		else
		{
			defaultArgLocation = i;
			m_args.inputFile = arg;
			break; // Stop parsing after finding the input file
		}
	}
	m_args.scriptArgv = argv + defaultArgLocation;
	m_args.scriptArgc = argc - defaultArgLocation;
}

void BinaryRuntime::showHelp(const std::string &programName)
{
	std::string filename = std::filesystem::path(programName).filename().string();
	std::cout << "Phasor Binary Runtime\n\n";
	std::cout << "Usage:\n";
	std::cout << "  " << filename << " [options] <file.phsb> [...script args]\n\n";
	std::cout << "Options:\n";
	std::cout << "  -v, --verbose       Enable verbose output\n";
	std::cout << "  -h, --help          Show this help message\n";
}

} // namespace Phasor


--- .\src\Runtime\Shared\BinaryRuntime.hpp ---
#pragma once

#include <string>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @class BinaryRuntime
 * @brief CLI wrapper for running Phasor bytecode binaries
 *
 * Loads and executes Phasor bytecode binaries (.phsb files).
 */
class BinaryRuntime
{
  public:
	BinaryRuntime(int argc, char *argv[], char *envp[]);
	int run();

  private:
	struct Args
	{
		std::string inputFile;
		bool        verbose = false;
		int         scriptArgc = 0;
		char      **scriptArgv = nullptr;
		char      **envp = nullptr;
	} m_args;

	void parseArguments(int argc, char *argv[]);
	void showHelp(const std::string &programName);
};

} // namespace Phasor


--- .\src\Runtime\Stdlib\CMakeLists.txt ---
set(STDLIB_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/core/file_properties.c
    ${CMAKE_CURRENT_SOURCE_DIR}/core/system.c
    ${CMAKE_CURRENT_SOURCE_DIR}/StdLib.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/file.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/io.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/math.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/string.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/system.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/typeconv.cpp
)

set(STDLIB_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/core/file_properties.h
    ${CMAKE_CURRENT_SOURCE_DIR}/core/system.h
    ${CMAKE_CURRENT_SOURCE_DIR}/StdLib.hpp
)

set(STDLIB_SOURCES ${STDLIB_SOURCES} PARENT_SCOPE)
set(STDLIB_HEADERS ${STDLIB_HEADERS} PARENT_SCOPE)

--- .\src\Runtime\Stdlib\core\file_properties.c ---
#include <stdint.h>
#include <stdbool.h>
#include "file_properties.h"

#ifdef _WIN32
#include <windows.h>
#include <fileapi.h>
#include <handleapi.h>
#include <winnt.h>
#include <Aclapi.h>
#else
#include <sys/stat.h>
#include <unistd.h>
#include <utime.h>
#include <errno.h>
#include <string.h>
#endif

bool file_set_properties(char *path, char param, int64_t epoch)
{
#ifdef _WIN32
	HANDLE hFile = CreateFileA(path, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	FILETIME ft;
	LONGLONG ll = Int32x32To64(epoch, 10000000) + 116444736000000000; // convert epoch to FILETIME
	ft.dwLowDateTime = (DWORD)ll;
	ft.dwHighDateTime = (DWORD)(ll >> 32);

	bool result = false;
	if (param == 'a')
	{
		result = SetFileTime(hFile, NULL, &ft, NULL) != 0;
	}
	else if (param == 'c')
	{
		result = SetFileTime(hFile, &ft, NULL, NULL) != 0;
	}
	else if (param == 'm')
	{
		result = SetFileTime(hFile, NULL, NULL, &ft) != 0;
	}

	CloseHandle(hFile);
	return result;

#else
	struct stat st;
	if (stat(path, &st) != 0)
		return false;

	struct utimbuf times;
	times.actime = st.st_atime;
	times.modtime = st.st_mtime;

	if (param == 'a')
	{
		times.actime = epoch;
	}
	else if (param == 'm')
	{
		times.modtime = epoch;
	}
	else
	{
		return false; // POSIX doesn't support setting creation time
	}

	return utime(path, &times) == 0;
#endif
}

int64_t file_get_properties(char *path, char param)
{
#ifdef _WIN32
	WIN32_FILE_ATTRIBUTE_DATA fileInfo;
	if (!GetFileAttributesExA(path, GetFileExInfoStandard, &fileInfo))
		return -1;

	FILETIME ft;
	if (param == 'a')
		ft = fileInfo.ftLastAccessTime;
	else if (param == 'c')
		ft = fileInfo.ftCreationTime;
	else if (param == 'm')
		ft = fileInfo.ftLastWriteTime;
	else
		return -1;

	ULARGE_INTEGER ull;
	ull.LowPart = ft.dwLowDateTime;
	ull.HighPart = ft.dwHighDateTime;
	return (int64_t)((ull.QuadPart - 116444736000000000) / 10000000);

#else
	struct stat st;
	if (stat(path, &st) != 0)
		return -1;

	if (param == 'a')
		return (int64_t)st.st_atime;
	else if (param == 'm')
		return (int64_t)st.st_mtime;
#if defined(__APPLE__) || defined(__FreeBSD__)
	else if (param == 'c')
		return (int64_t)st.st_birthtime; // BSD creation time
#endif
	else
		return -1; // creation time not supported on other POSIX systems
#endif
}

nlink_t file_get_links_count(const char *path)
#ifdef _WIN32
{

	HANDLE hFile = CreateFileA(path, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL,
	                           OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return 0;

	BY_HANDLE_FILE_INFORMATION info;
	if (!GetFileInformationByHandle(hFile, &info))
	{
		CloseHandle(hFile);
		return 0;
	}
	CloseHandle(hFile);
	return (nlink_t)info.nNumberOfLinks;
}
#else
{
	struct stat st;
	if (stat(path, &st) != 0)
		return 0;
	return st.st_nlink;
}
#endif

bool file_get_owner_id(const char *path, uid_t *uid, gid_t *gid)
#ifdef _WIN32
{
	// Windows does not have UID/GID like POSIX, but we can get the owner SID
	*uid = 0;
	*gid = 0;

	PSID                 pSidOwner = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;
	if (GetNamedSecurityInfoA(path, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION, &pSidOwner, NULL, NULL, NULL, &pSD) !=
	    ERROR_SUCCESS)
	{
		return false;
	}

	*uid = (uid_t)GetSidIdentifierAuthority(pSidOwner)->Value[5]; // crude
	*gid = 0;

	if (pSD)
		LocalFree(pSD);
	return true;
}
#else // POSIX
{
	struct stat st;
	if (stat(path, &st) != 0)
		return false;
	if (uid)
		*uid = st.st_uid;
	if (gid)
		*gid = st.st_gid;
	return true;
}
#endif


--- .\src\Runtime\Stdlib\core\file_properties.h ---
#ifndef FILE_PROPERTIES_H
#define FILE_PROPERTIES_H

#include <stdint.h>
#include <stdbool.h>

#ifdef _WIN32
typedef unsigned long nlink_t;
typedef unsigned long uid_t;
typedef unsigned long gid_t;
#else
#include <sys/types.h>
#endif

#ifdef __cplusplus
extern "C"
{
#endif
	/**
	 * @brief Set file metadata time property
	 *
	 * @param path Path to file
	 * @param param What to change a=Access c=Creation m=Modified
	 * @param epoch Epoch time to set
	 * @return Status of operation
	 */
	bool file_set_properties(char *path, char param, int64_t epoch);

	/**
	 * @brief Get file metadata time property
	 *
	 * @param path Path to file
	 * @param param What to get a=Access c=Creation m=Modified
	 * @returns epoch Epoch time
	 */
	int64_t file_get_properties(char *path, char param);

	/**
	 * @brief Retrieves the number of hard links to a file.
	 *
	 * This function returns the count of hard links associated with the specified file.
	 * On POSIX systems, it uses `stat` to get `st_nlink`. On Windows, it uses
	 * `GetFileInformationByHandle` to obtain `nNumberOfLinks`.
	 *
	 * @param path The path to the file.
	 * @return The number of hard links to the file. Returns 0 if the file cannot be accessed.
	 */
	nlink_t file_get_links_count(const char *path);

	/**
	 * @brief Retrieves the owner identifier of a file.
	 *
	 * On POSIX systems, this sets `*uid` to the file owner's UID and `*gid` to the file owner's GID.
	 * On Windows, there is no direct UID/GID, but a numeric representation of the owner SID is assigned
	 * to `*uid` and `*gid` is set to 0.
	 *
	 * @param path The path to the file.
	 * @param uid Pointer to a variable that receives the owner's UID.
	 * @param gid Pointer to a variable that receives the owner's GID.
	 * @return `true` if the owner information was successfully retrieved, `false` otherwise.
	 */
	bool file_get_owner_id(const char *path, uid_t *uid, gid_t *gid);
#ifdef __cplusplus
} // extern "C"
#endif

#endif // FILE_PROPERTIES_H

--- .\src\Runtime\Stdlib\core\system.c ---
#include "system.h"

size_t PHASORstd_sys_getAvailableMemory()
{
#ifdef _WIN32
	MEMORYSTATUSEX statex;
	statex.dwLength = sizeof(statex);
	if (!GlobalMemoryStatusEx(&statex))
		return 0;
	return (size_t)statex.ullAvailPhys;

#elif defined(__APPLE__) && defined(__MACH__)
	mach_msg_type_number_t count = HOST_VM_INFO_COUNT;
	vm_statistics_data_t   vmstat;
	if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vmstat, &count) != KERN_SUCCESS)
		return 0;

	vm_size_t page_size = 0;
	if (host_page_size(mach_host_self(), &page_size) != KERN_SUCCESS || page_size == 0)
		return 0;

	natural_t available_pages = vmstat.free_count + vmstat.inactive_count;
	return (size_t)available_pages * (size_t)page_size;

#elif defined(__linux__)
	long pages = sysconf(_SC_AVPHYS_PAGES);
	long page_size = sysconf(_SC_PAGESIZE);
	if (pages == -1 || page_size == -1)
		return 0;
	return (size_t)pages * (size_t)page_size;

#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
	size_t page_size = 0;
	size_t len = sizeof(page_size);
	if (sysctlbyname("hw.pagesize", &page_size, &len, NULL, 0) != 0 || page_size == 0)
		return 0;

	long free_pages = 0;
#if defined(__OpenBSD__)
	len = sizeof(free_pages);
	if (sysctlbyname("uvm.stats.sys.free", &free_pages, &len, NULL, 0) != 0)
		return 0;
#else
	len = sizeof(free_pages);
	if (sysctlbyname("vm.stats.vm.v_free_count", &free_pages, &len, NULL, 0) != 0)
		return 0;
#endif

	return (size_t)free_pages * (size_t)page_size;

#else
	return 0;
#endif
}

int PHASORstd_sys_run(const char *name, int argc, char **argv)
{
	char **args = (char **)malloc((argc + 2) * sizeof(char *));
	if (!args)
		return -1;
	 
	args[0] = (char *)name;
	for (int i = 0; i < argc; i++)
		args[i + 1] = argv[i];
	args[argc + 1] = NULL;

#ifdef _WIN32
	int ret = (int)_spawnvp(_P_WAIT, name, (const char *const *)args);
	if (ret == -1)
	{
		perror(name);
	}
#else
	int   ret = -1;
	pid_t pid = fork();
	if (pid == 0)
	{
		execvp(name, args);
		exit(1); // execvp failed
	}
	int status;
	waitpid(pid, &status, 0);
	ret = WEXITSTATUS(status);
#endif

	free(args);
	return ret;
}

int PHASORstd_sys_run_detached(const char *name, int argc, char **argv)
{
	char **args = (char **)malloc((argc + 2) * sizeof(char *));
	if (!args)
		return -1;

	args[0] = (char *)name;
	for (int i = 0; i < argc; i++)
		args[i + 1] = argv[i];
	args[argc + 1] = NULL;

#ifdef _WIN32

	int ret = (int)_spawnvp(_P_NOWAIT, name, (const char *const *)args);
	if (ret == -1)
		perror(name);

	free(args);
	return ret;

#else

	pid_t pid = fork();
	if (pid < 0)
	{
		free(args);
		return -1;
	}

	if (pid == 0)
	{
		setsid();

		pid_t pid2 = fork();
		if (pid2 < 0)
			exit(1);

		if (pid2 > 0)
			exit(0);

		execvp(name, args);
		exit(1);
	}
	
	free(args);
	return 0;

#endif
}

--- .\src\Runtime\Stdlib\core\system.h ---
#ifndef CORE_SYSTEM_H
#define CORE_SYSTEM_H

#ifdef _WIN32
#include <windows.h>
#include <process.h>
#elif defined(__APPLE__) && defined(__MACH__)
#include <unistd.h>
#include <mach/mach.h>
#include <mach/host_info.h>
#elif defined(__linux__)
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#elif defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
#include <sys/types.h>
#include <sys/sysctl.h>
#include <unistd.h>
#include <sys/wait.h>
#endif

#include <stdlib.h>

#ifdef __cplusplus
extern "C"
{
#endif

	size_t PHASORstd_sys_getAvailableMemory();

	int PHASORstd_sys_run(const char *name, int argc, char **argv);

	int PHASORstd_sys_run_detached(const char *name, int argc, char **argv);

#ifdef __cplusplus
}
#endif
#endif // CORE_SYSTEM_H

--- .\src\Runtime\Stdlib\file.cpp ---
#include <filesystem>
#include <vector>

#include "StdLib.hpp"
#include "core/file_properties.h"

namespace Phasor
{

Value StdLib::registerFileFunctions(const std::vector<Value> &args, VM *vm)
{
	vm->registerNativeFunction("fabsolute", StdLib::file_absolute);
	vm->registerNativeFunction("fread", StdLib::file_read);
	vm->registerNativeFunction("fwrite", StdLib::file_write);
	vm->registerNativeFunction("fexists", StdLib::file_exists);
	vm->registerNativeFunction("freadln", StdLib::file_read_line);
	vm->registerNativeFunction("fwriteln", StdLib::file_write_line);
	vm->registerNativeFunction("fappend", StdLib::file_append);
	vm->registerNativeFunction("frm", StdLib::file_delete);
	vm->registerNativeFunction("frn", StdLib::file_rename);
	vm->registerNativeFunction("fcd", StdLib::file_current_directory);
	vm->registerNativeFunction("fcp", StdLib::file_copy);
	vm->registerNativeFunction("fmv", StdLib::file_move);
	vm->registerNativeFunction("fpropset", StdLib::file_property_edit);
	vm->registerNativeFunction("fpropget", StdLib::file_property_get);
	vm->registerNativeFunction("fmk", StdLib::file_create);
	vm->registerNativeFunction("fmkdir", StdLib::file_create_directory);
	vm->registerNativeFunction("frmdir", StdLib::file_remove_directory);
	vm->registerNativeFunction("freaddir", StdLib::file_read_directory);
	vm->registerNativeFunction("fstat", StdLib::file_statistics);

	return true;
}

Value StdLib::file_absolute(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fabsolute");
	std::filesystem::path path = args[0].asString();
	std::filesystem::path fullPath = std::filesystem::weakly_canonical(path);
	return fullPath.string();
}

Value StdLib::file_read(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fread");
	std::filesystem::path path = args[0].asString();
	std::ifstream         file(path);
	if (!file.is_open())
	{
		return Value(); // Return null if file cannot be opened
	}
	std::stringstream buffer;
	buffer << file.rdbuf();
	return buffer.str();
}

Value StdLib::file_read_line(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "freadln");
	std::filesystem::path path = args[0].asString();
	int64_t               lineNum = args[1].asInt();
	std::ifstream         file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("Could not open file: " + path.string());
	}
	std::string lineContent;
	int         currentLine = 0;
	while (std::getline(file, lineContent) && currentLine < lineNum)
	{
		currentLine++;
	}
	return lineContent;
}

Value StdLib::file_write_line(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 3, "fwriteln");
	std::filesystem::path path = args[0].asString();
	int64_t               lineNum = args[1].asInt();
	std::string           content = args[2].asString();

	// Read all lines first
	std::ifstream inFile(path);
	if (!inFile.is_open())
	{
		throw std::runtime_error("Could not open file for reading: " + path.string());
	}

	std::vector<std::string> lines;
	std::string              line;
	while (std::getline(inFile, line))
	{
		lines.push_back(line);
	}
	inFile.close();

	// Ensure we have enough lines
	while (lines.size() <= static_cast<size_t>(lineNum))
	{
		lines.emplace_back("");
	}

	// Update the line
	lines[lineNum] = content;

	// Write back to file
	std::ofstream outFile(path);
	if (!outFile.is_open())
	{
		throw std::runtime_error("Could not open file for writing: " + path.string());
	}

	for (size_t i = 0; i < lines.size(); ++i)
	{
		outFile << lines[i];
		if (i != lines.size() - 1)
		{
			outFile << '\n';
		}
	}

	return true;
}

Value StdLib::file_write(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "fwrite");
	std::filesystem::path path = args[0].asString();
	std::ofstream         file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("Could not open file for writing: " + path.string());
	}
	file << args[1].asString();
	return true;
}

Value StdLib::file_exists(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fexists");
	return std::filesystem::exists(args[0].asString());
}

Value StdLib::file_append(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "fappend");
	std::filesystem::path path = args[0].asString();
	std::ofstream         file(path, std::ios::app);
	if (!file.is_open())
	{
		throw std::runtime_error("Could not open file for writing: " + path.string());
	}
	file << args[1].asString();
	return true;
}

Value StdLib::file_delete(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "frm");
	std::filesystem::path path = args[0].asString();
	if (std::filesystem::exists(path))
	{
		std::filesystem::remove(path);
		return true;
	}
	return false;
}

Value StdLib::file_rename(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "frn");
	std::filesystem::path src = args[0].asString();
	std::string           dest = args[1].asString();
	if (std::filesystem::exists(src))
	{
		std::filesystem::rename(src, dest);
		return true;
	}
	return false;
}

Value StdLib::file_current_directory(const std::vector<Value> &args, VM *)
{
	// If no arguments, return current directory
	if (args.empty())
	{
		return std::filesystem::current_path().string();
	}
	checkArgCount(args, 1, "fcd");
	std::filesystem::path dest = args[0].asString();
	if (std::filesystem::exists(dest) && std::filesystem::is_directory(dest))
	{
		std::filesystem::current_path(dest);
		return std::filesystem::current_path().string();
	}

	return false;
}

Value StdLib::file_copy(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "fcp", true);
	bool overwrite = false;
	if (args.size() <= 3 && args.size() >= 2)
	{
		overwrite = args[2].asBool();
	}
	std::filesystem::path src = args[0].asString();
	std::filesystem::path dest = args[1].asString();

	if (!std::filesystem::exists(src))
	{
		std::cerr << "Source file doesn't exist." << std::endl;
		return false;
	}

	if (std::filesystem::exists(dest) && !overwrite)
	{
		std::cerr << "Destination file already exists." << std::endl;
		return false;
	}

	std::ifstream source(src, std::ios::binary | std::ios::in);
	if (!source.is_open())
	{
		std::cerr << "Failed to open source file." << std::endl;
		return false;
	}

	std::ofstream destination(dest, std::ios::binary | std::ios::out | std::ios::trunc);
	if (!destination.is_open())
	{
		std::cerr << "Failed to open destination file." << std::endl;
		return false;
	}

	destination << source.rdbuf();

	if (source.fail() || destination.fail())
	{
		std::cerr << "Error during file copy." << std::endl;
		return false;
	}

	return true;
}

Value StdLib::file_move(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "fmv");
	std::filesystem::path src = args[0].asString();
	std::filesystem::path dest = args[1].asString();
	bool status;
	status = std::filesystem::copy_file(src, dest);
	if (!status)
	{
		std::cerr << "Failed to copy file during move." << std::endl;
		return false;
	}
	status = std::filesystem::remove(src);
	return status;
}

Value StdLib::file_property_edit(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 3, "fpropedit");
	if (args[2].isInt() && args[2].asInt() < 0)
	{
		throw std::runtime_error("epoch must be a non-negative integer");
	}
	std::filesystem::path path = args[0].asString();
	char                  param = args[1].asString()[0];
	int64_t               epoch = args[2].asInt();
	return file_set_properties(const_cast<char *>(path.string().c_str()), param, epoch);
}

Value StdLib::file_property_get(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "fpropget");
	std::filesystem::path path = args[0].asString();
	char                  param = args[1].asString()[0];
	return file_get_properties(const_cast<char *>(path.string().c_str()), param);
}

Value StdLib::file_create(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fcreate");
	std::filesystem::path path = args[0].asString();
	std::ofstream         file(path);
	if (!file.is_open())
	{
		throw std::runtime_error("Could not open file: " + path.string());
	}
	file.close();
	return true;
}

Value StdLib::file_read_directory(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "freaddir");
	std::string path = args[0].asString();
	std::string result;
	try
	{
		for (const auto &entry : std::filesystem::directory_iterator(path))
		{
			if (!result.empty())
				result += "\n";
			result += entry.path().filename().string();
		}
		return result;
	}
	catch (const std::exception &e)
	{
		return Value(e.what()); // Return null on error
	}
}

Value StdLib::file_statistics(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fstat");
	std::string path = args[0].asString();
	uid_t       uid = 0;
	gid_t       gid = 0;
	nlink_t     nlink = file_get_links_count(path.c_str());
	file_get_owner_id(path.c_str(), &uid, &gid);
	try
	{
		auto status = std::filesystem::status(path);
		auto perms = status.permissions();

		Value::StructInstance stat;
		stat.structName = "FileStat";

		// Convert permissions to mode_t style
		int mode = 0;

		// Set file type bits
		if (std::filesystem::is_directory(status))
		{
			mode |= 0x4000; // Directory
		}
		else if (std::filesystem::is_regular_file(status))
		{
			mode |= 0x8000; // Regular file
		}
		else if (std::filesystem::is_symlink(status))
		{
			mode |= 0xA000; // Symbolic link
		}
		else
		{
			mode |= 0x8000; // Default to regular file
		}

		// Set permission bits
		mode |= ((perms & std::filesystem::perms::owner_read) != std::filesystem::perms::none) ? 0x100 : 0;
		mode |= ((perms & std::filesystem::perms::owner_write) != std::filesystem::perms::none) ? 0x80 : 0;
		mode |= ((perms & std::filesystem::perms::owner_exec) != std::filesystem::perms::none) ? 0x40 : 0;
		mode |= ((perms & std::filesystem::perms::group_read) != std::filesystem::perms::none) ? 0x20 : 0;
		mode |= ((perms & std::filesystem::perms::group_write) != std::filesystem::perms::none) ? 0x10 : 0;
		mode |= ((perms & std::filesystem::perms::group_exec) != std::filesystem::perms::none) ? 0x8 : 0;
		mode |= ((perms & std::filesystem::perms::others_read) != std::filesystem::perms::none) ? 0x4 : 0;
		mode |= ((perms & std::filesystem::perms::others_write) != std::filesystem::perms::none) ? 0x2 : 0;
		mode |= ((perms & std::filesystem::perms::others_exec) != std::filesystem::perms::none) ? 0x1 : 0;

		// Set file stats
		stat.fields["mode"] = Value(static_cast<int64_t>(mode));
		stat.fields["nlink"] = Value(static_cast<int64_t>(nlink));
		stat.fields["uid"] = Value(static_cast<int64_t>(uid));
		stat.fields["gid"] = Value(static_cast<int64_t>(gid));
		stat.fields["size"] = Value(static_cast<int64_t>(std::filesystem::file_size(path)));

		return Value(std::make_shared<Value::StructInstance>(std::move(stat)));
	}
	catch (const std::exception &e)
	{
		// Log the actual error for debugging
		std::cerr << "fstat error: " << e.what() << std::endl;
		return Value(); // Return null on error
	}
}

Value StdLib::file_create_directory(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "fmkdir");
	std::filesystem::path path = args[0].asString();
	if (std::filesystem::exists(path))
		return false;
	std::filesystem::create_directory(path);
	return true;
}

Value StdLib::file_remove_directory(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "frmdir");
	std::filesystem::path path = args[0].asString();
	bool recursive = args[1].asBool();	
	if (std::filesystem::exists(path))
	{
		if (recursive)
		{
			if (std::filesystem::remove_all(path) > 0) 
				return true;
			else
				return false;
		} else {
			return std::filesystem::remove(path);
		}
	}
	return true;
}
} // namespace Phasor

--- .\src\Runtime\Stdlib\io.cpp ---
#include "StdLib.hpp"

static std::string toHex(int value)
{
	std::stringstream ss;
	ss << std::showbase << std::hex << value;
	return ss.str();
}

namespace Phasor
{

Value StdLib::registerIOFunctions(const std::vector<Value> &args, VM *vm)
{
	vm->registerNativeFunction("c_fmt", StdLib::io_c_format);
	vm->registerNativeFunction("clear", StdLib::io_clear);
	vm->registerNativeFunction("prints", StdLib::io_prints);
	vm->registerNativeFunction("printf", StdLib::io_printf);
	vm->registerNativeFunction("puts", StdLib::io_puts);
	vm->registerNativeFunction("putf", StdLib::io_putf);
	vm->registerNativeFunction("gets", StdLib::io_gets);
	vm->registerNativeFunction("puts_error", StdLib::io_puts_error);
	vm->registerNativeFunction("putf_error", StdLib::io_putf_error);
	return true;
}

Value StdLib::io_clear(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "clear");
	vm->regRun(OpCode::PRINT_R, "\033[2J\033[H");
	return Value();
}
Value StdLib::io_c_format(const std::vector<Value> &args, VM *)
{
	if (args.empty())
	{
		return Value(""); // Return empty string if no arguments
	}

	const std::string &fmt = args[0].asString();
	std::string        out;
	size_t             argIndex = 1; // Start from 1 because args[0] is the format string

	for (size_t i = 0; i < fmt.size(); ++i)
	{
		if (fmt[i] == '%' && i + 1 < fmt.size())
		{
			char spec = fmt[++i]; // Move to the format specifier
			if (argIndex < args.size())
			{
				const Value &v = args[argIndex++];
				switch (spec)
				{
				case 's':
				case 'c':
					out += v.asString();
					break;
				case 'd':
					out += std::to_string(v.asInt());
					break;
				case 'f':
					out += std::to_string(v.asFloat());
					break;
				case '%':
					out += '%';
					break;
				case 'x':
					out += "0x" + toHex((int)v.asInt());
					break;
				default:
					// Unknown specifier, include it literally
					out += '%';
					out += spec;
					break;
				}
				continue;
			}
		}
		out += fmt[i];
	}
	return Value(out);
}

Value StdLib::io_prints(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "prints");
	vm->regRun(OpCode::PRINT_R, args[0]);
	return Value("");
}

Value StdLib::io_printf(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "printf", true);
	std::vector<Value> formatArgs(args.begin(), args.end());
	vm->regRun(OpCode::PRINT_R, io_c_format(formatArgs, vm));
	return Value("");
}

Value StdLib::io_puts(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "puts", true);
	std::string input = args[0].toString();
	vm->regRun(OpCode::PRINT_R, input + "\n");
	return Value("");
}

Value StdLib::io_putf(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "putf", true);
	std::vector<Value> formatArgs(args.begin(), args.end());
	std::string        input = io_c_format(formatArgs, vm).toString();
	vm->regRun(OpCode::PRINT_R, input + "\n");
	return Value("");
}

Value StdLib::io_gets(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "gets");
	vm->operation(OpCode::READLINE_R, VM::Register::r1);
	std::string ret = vm->getRegister(VM::Register::r1).toString();
	return ret;
}

Value StdLib::io_puts_error(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "puts_error", true);
	std::string input = args[0].toString();
	return vm->regRun(OpCode::PRINTERROR_R, input + "\n");
}

Value StdLib::io_putf_error(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "putf_error", true);
	std::vector<Value> formatArgs(args.begin(), args.end());
	std::string        input = io_c_format(formatArgs, vm).toString();
	return vm->regRun(OpCode::PRINTERROR_R, input + "\n");
}
} // namespace Phasor

--- .\src\Runtime\Stdlib\math.cpp ---
#include "StdLib.hpp"

namespace Phasor
{

Value StdLib::registerMathFunctions(const std::vector<Value> &args, VM *vm)
{
	vm->registerNativeFunction("math_sqrt", StdLib::math_sqrt);
	vm->registerNativeFunction("math_pow", StdLib::math_pow);
	vm->registerNativeFunction("math_abs", StdLib::math_abs);
	vm->registerNativeFunction("math_floor", StdLib::math_floor);
	vm->registerNativeFunction("math_ceil", StdLib::math_ceil);
	vm->registerNativeFunction("math_round", StdLib::math_round);
	vm->registerNativeFunction("math_min", StdLib::math_min);
	vm->registerNativeFunction("math_max", StdLib::math_max);
	vm->registerNativeFunction("math_log", StdLib::math_log);
	vm->registerNativeFunction("math_exp", StdLib::math_exp);
	vm->registerNativeFunction("math_sin", StdLib::math_sin);
	vm->registerNativeFunction("math_cos", StdLib::math_cos);
	vm->registerNativeFunction("math_tan", StdLib::math_tan);
	return true;
}

Value StdLib::math_sqrt(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_sqrt");
	return Value(asm_sqrt(args[0].asFloat()));
}

Value StdLib::math_pow(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "math_pow");
	double base = args[0].asFloat();
	double expv = args[1].asFloat();
	return Value(asm_pow(base, expv));
}

Value StdLib::math_abs(const std::vector<Value> &args, VM *)
{
	// @TODO: Implement abs natively
	checkArgCount(args, 1, "math_abs");
	if (args[0].isInt())
		return std::abs(args[0].asInt());
	return std::abs(args[0].asFloat());
}

Value StdLib::math_floor(const std::vector<Value> &args, VM *)
{
	// @TODO: Implement floor natively
	checkArgCount(args, 1, "math_floor");
	return static_cast<int64_t>(std::floor(args[0].asFloat()));
}

Value StdLib::math_ceil(const std::vector<Value> &args, VM *)
{
	// @TODO: Implement ceil natively
	checkArgCount(args, 1, "math_ceil");
	return static_cast<int64_t>(std::ceil(args[0].asFloat()));
}

Value StdLib::math_round(const std::vector<Value> &args, VM *)
{
	// @TODO: Implement round natively
	checkArgCount(args, 1, "math_round");
	return static_cast<int64_t>(std::round(args[0].asFloat()));
}

Value StdLib::math_min(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "math_min");
	const Value &a = args[0];
	const Value &b = args[1];
	if (a.isInt() && b.isInt())
	{
		int64_t ai = a.asInt();
		int64_t bi = b.asInt();
		return Value(asm_iless_than(ai, bi) ? ai : bi);
	}
	if (a.isNumber() && b.isNumber())
	{
		double af = a.asFloat();
		double bf = b.asFloat();
		return Value(asm_flless_than(af, bf) ? af : bf);
	}
	return a < b ? a : b;
}

Value StdLib::math_max(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "math_max");
	const Value &a = args[0];
	const Value &b = args[1];
	if (a.isInt() && b.isInt())
	{
		int64_t ai = a.asInt();
		int64_t bi = b.asInt();
		return Value(ai > bi ? ai : bi);
	}
	if (a.isNumber() && b.isNumber())
	{
		double af = a.asFloat();
		double bf = b.asFloat();
		return Value(af > bf ? af : bf);
	}
	return a > b ? a : b;
}

Value StdLib::math_log(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_log");
	return Value(asm_log(args[0].asFloat()));
}

Value StdLib::math_exp(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_exp");
	return Value(asm_exp(args[0].asFloat()));
}

Value StdLib::math_sin(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_sin");
	return Value(asm_sin(args[0].asFloat()));
}

Value StdLib::math_cos(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_cos");
	return Value(asm_cos(args[0].asFloat()));
}

Value StdLib::math_tan(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "math_tan");
	return Value(asm_tan(args[0].asFloat()));
}
} // namespace Phasor

--- .\src\Runtime\Stdlib\StdLib.cpp ---
#include "StdLib.hpp"

namespace Phasor
{

char **StdLib::argv = nullptr;
int    StdLib::argc = 0;
char **StdLib::envp = nullptr;

void StdLib::registerFunctions(VM &vm)
{
	vm.registerNativeFunction("using", std_import);
}

int StdLib::dupenv(std::string &out, const char *name, char *const argp[])
{
	if (!name || !argp)
	{
		return 1;
	}

	const size_t key_len = strlen(name);

	const char *val = NULL;
	for (size_t i = 0; argp[i]; i++)
	{
		const char *entry = argp[i];
		if (strncmp(entry, name, key_len) == 0 && entry[key_len] == '=')
		{
			val = entry + key_len + 1;
			break;
		}
	}
	if (!val)
	{
		out.clear();
		return 2;
	}

	out = std::string(val);
	return 0;
}

void StdLib::checkArgCount(const std::vector<Value> &args, size_t minimumArguments, const std::string &name,
                           bool allowMoreArguments)
{
	if (args.size() < minimumArguments)
	{
		throw std::runtime_error("Function '" + name + "' expects at least " + std::to_string(minimumArguments) +
		                         " arguments, but got " + std::to_string(args.size()));
	}
	if (!allowMoreArguments && args.size() > minimumArguments)
	{
		throw std::runtime_error("Function '" + name + "' expects exactly " + std::to_string(minimumArguments) +
		                         " arguments, but got " + std::to_string(args.size()));
	}
}

Value StdLib::std_import(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "using", true);
	for (const auto &arg : args)
	{
		if (arg.getType() != ValueType::String)
		{
			throw std::runtime_error("All arguments to 'using' must be strings");
			return false;
		}
		auto moduleName = arg.asString();
		if (moduleName == "stdio") registerIOFunctions(std::vector<Value>{}, vm);
		else if (moduleName == "stdsys") registerSysFunctions(std::vector<Value>{}, vm);
		else if (moduleName == "stdmath") registerMathFunctions(std::vector<Value>{}, vm);
		else if (moduleName == "stdstr") registerStringFunctions(std::vector<Value>{}, vm);
		else if (moduleName == "stdtype") registerTypeConvFunctions(std::vector<Value>{}, vm);
		else if (moduleName == "stdfile") registerFileFunctions(std::vector<Value>{}, vm);
		else
		{
			throw std::runtime_error("Unknown standard library module: " + moduleName);
			return false;
		}
	}
	return true;
}

} // namespace Phasor

--- .\src\Runtime\Stdlib\StdLib.hpp ---
#pragma once
#include "../VM/VM.hpp"
#include <Value.hpp>
#include <functional>
#include <map>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <stdlib.h>
#include <string.h>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/// @brief Native function signature
using NativeFunction = std::function<Value(const std::vector<Value> &args, VM *vm)>;

/// @class StdLib
/// @brief Standard library
/// Contains all the standard library functions
class StdLib
{
  public:
	static void registerFunctions(VM &vm);

	static char **argv; ///< Command line arguments
	static int    argc; ///< Number of command line arguments
	static char **envp; ///< Environment variables

	static void checkArgCount(const std::vector<Value> &args, size_t minimumArguments, const std::string &name,
	                          bool allowMoreArguments = false);

  private:
	static Value std_import(const std::vector<Value> &args, VM *vm);

	static int dupenv(std::string &out, const char *name, char *const argp[]);

	static Value registerMathFunctions(const std::vector<Value> &args, VM *vm);
	static Value registerStringFunctions(const std::vector<Value> &args, VM *vm);
	static Value registerTypeConvFunctions(const std::vector<Value> &args, VM *vm);
	static Value registerFileFunctions(const std::vector<Value> &args, VM *vm);
	static Value registerSysFunctions(const std::vector<Value> &args, VM *vm);
	static Value registerIOFunctions(const std::vector<Value> &args, VM *vm);

	// Math functions
	static Value math_sqrt(const std::vector<Value> &args, VM *vm);  ///< Square root
	static Value math_pow(const std::vector<Value> &args, VM *vm);   ///< Power
	static Value math_abs(const std::vector<Value> &args, VM *vm);   ///< Absolute value
	static Value math_floor(const std::vector<Value> &args, VM *vm); ///< Floor
	static Value math_ceil(const std::vector<Value> &args, VM *vm);  ///< Ceiling
	static Value math_round(const std::vector<Value> &args, VM *vm); ///< Round
	static Value math_min(const std::vector<Value> &args, VM *vm);   ///< Minimum
	static Value math_max(const std::vector<Value> &args, VM *vm);   ///< Maximum
	static Value math_log(const std::vector<Value> &args, VM *vm);   ///< Natural logarithm
	static Value math_exp(const std::vector<Value> &args, VM *vm);   ///< Exponential
	static Value math_sin(const std::vector<Value> &args, VM *vm);   ///< Sine
	static Value math_cos(const std::vector<Value> &args, VM *vm);   ///< Cosine
	static Value math_tan(const std::vector<Value> &args, VM *vm);   ///< Tangent

	// File IO
	static Value file_absolute(const std::vector<Value> &args, VM *vm);     ///< Get full path to relative path
	static Value file_read(const std::vector<Value> &args, VM *vm);              ///< Read file
	static Value file_write(const std::vector<Value> &args, VM *vm);             ///< Write to file
	static Value file_exists(const std::vector<Value> &args, VM *vm);            ///< Check if file exists
	static Value file_read_line(const std::vector<Value> &args, VM *vm);         ///< Read a line from file
	static Value file_write_line(const std::vector<Value> &args, VM *vm);        ///< Write a line to file
	static Value file_append(const std::vector<Value> &args, VM *vm);            ///< Append to file
	static Value file_delete(const std::vector<Value> &args, VM *vm);            ///< Delete file
	static Value file_rename(const std::vector<Value> &args, VM *vm);            ///< Rename file
	static Value file_current_directory(const std::vector<Value> &args, VM *vm); ///< Get/set working directory
	static Value file_copy(const std::vector<Value> &args, VM *vm);              ///< Copy file
	static Value file_move(const std::vector<Value> &args, VM *vm);              ///< Move file
	static Value file_property_edit(const std::vector<Value> &args, VM *vm);
	static Value file_property_get(const std::vector<Value> &args, VM *vm);
	static Value file_create(const std::vector<Value> &args, VM *vm);
	static Value file_read_directory(const std::vector<Value> &args, VM *vm);
	static Value file_statistics(const std::vector<Value> &args, VM *vm);
	static Value file_create_directory(const std::vector<Value> &args, VM *vm);
	static Value file_remove_directory(const std::vector<Value> &args, VM *vm);

	// System (meaning VM/CRT more than actual system)
	static Value sys_time(const std::vector<Value> &args, VM *vm);           ///< Current time
	static Value sys_time_formatted(const std::vector<Value> &args, VM *vm); ///< Current time formatted
	static Value sys_sleep(const std::vector<Value> &args, VM *vm);          ///< Sleep for a specified amount of time
	static Value sys_os(const std::vector<Value> &args, VM *vm);             ///< Get the current OS
	static Value sys_env(const std::vector<Value> &args, VM *vm);            ///< Get the current environment variables
	static Value sys_argv(const std::vector<Value> &args, VM *vm);           ///< Get the current command line arguments
	static Value system_get_free_memory(const std::vector<Value> &args, VM *vm); ///< Get current free memory
	static Value sys_argc(const std::vector<Value> &args, VM *vm); ///< Get the current number of command line arguments
	static Value sys_wait_for_input(const std::vector<Value> &args, VM *vm);  ///< Wait for input
	static Value sys_shell(const std::vector<Value> &args, VM *vm);            ///< Run a shell command
	static Value sys_fork(const std::vector<Value> &args, VM *vm);           ///< Run a native program
	static Value sys_fork_detached(const std::vector<Value> &args, VM *vm); ///< Run a native program detached
	static Value sys_crash(const std::vector<Value> &args, VM *vm);    ///< Crash the VM / Program
	static Value sys_reset(const std::vector<Value> &args, VM *vm);    ///< Reset the VM
	static Value sys_shutdown(const std::vector<Value> &args, VM *vm); ///< Shutdown the VM
	static Value sys_pid(const std::vector<Value> &args, VM *vm);      ///< Get the current process ID

	// Type conversion functions
	static Value to_int(const std::vector<Value> &args, VM *vm);    ///< Convert to integer
	static Value to_float(const std::vector<Value> &args, VM *vm);  ///< Convert to float
	static Value to_string(const std::vector<Value> &args, VM *vm); ///< Convert to string
	static Value to_bool(const std::vector<Value> &args, VM *vm);   ///< Convert to boolean

	// String functions
	static Value str_find(const std::vector<Value> &args, VM *vm);        ///< Find string in string
	static Value str_len(const std::vector<Value> &args, VM *vm);         ///< Get string length
	static Value str_char_at(const std::vector<Value> &args, VM *vm);     ///< Get character at index
	static Value str_substr(const std::vector<Value> &args, VM *vm);      ///< Get substring
	static Value str_concat(const std::vector<Value> &args, VM *vm);      ///< Concatenate strings
	static Value str_upper(const std::vector<Value> &args, VM *vm);       ///< Convert to uppercase
	static Value str_lower(const std::vector<Value> &args, VM *vm);       ///< Convert to lowercase
	static Value str_starts_with(const std::vector<Value> &args, VM *vm); ///< Check if string starts with
	static Value str_ends_with(const std::vector<Value> &args, VM *vm);   ///< Check if string ends with
	// StringBuilder functions
	static Value sb_new(const std::vector<Value> &args, VM *vm);       ///< Create new string builder
	static Value sb_append(const std::vector<Value> &args, VM *vm);    ///< Append to string builder
	static Value sb_to_string(const std::vector<Value> &args, VM *vm); ///< Convert string builder to string
	static Value sb_clear(const std::vector<Value> &args, VM *vm);     ///< Clear string builder
	static Value sb_free(const std::vector<Value> &args, VM *vm);      ///< Free string builder

	// IO
	static Value io_c_format(const std::vector<Value> &args, VM *vm); ///< Format string
	static Value io_clear(const std::vector<Value> &args, VM *vm);    ///< Clear the console
	static Value io_prints(const std::vector<Value> &args, VM *vm);   ///< Print string without newline
	static Value io_printf(const std::vector<Value> &args, VM *vm);   ///< Print formatted string
	static Value io_puts(const std::vector<Value> &args, VM *vm);     ///< Print string with newline
	static Value io_putf(const std::vector<Value> &args, VM *vm);     ///< Print formatted string with newline
	static Value io_gets(const std::vector<Value> &args, VM *vm);     ///< Get string
	static Value io_putf_error(const std::vector<Value> &args,
	                           VM                       *vm); ///< Print formatted string with newline to error output
	static Value io_puts_error(const std::vector<Value> &args, VM *vm); ///< Print string with newline to error output
};

} // namespace Phasor

--- .\src\Runtime\Stdlib\string.cpp ---
#include "StdLib.hpp"
#include <string>

namespace Phasor
{

Value StdLib::registerStringFunctions(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "include_stdstr");
	vm->registerNativeFunction("find", StdLib::str_find);
	vm->registerNativeFunction("len", StdLib::str_len);
	vm->registerNativeFunction("char_at", StdLib::str_char_at);
	vm->registerNativeFunction("substr", StdLib::str_substr);
	vm->registerNativeFunction("concat", StdLib::str_concat);
	vm->registerNativeFunction("to_upper", StdLib::str_upper);
	vm->registerNativeFunction("to_lower", StdLib::str_lower);
	vm->registerNativeFunction("starts_with", StdLib::str_starts_with);
	vm->registerNativeFunction("ends_with", StdLib::str_ends_with);

	// StringBuilder
	vm->registerNativeFunction("sb_new", StdLib::sb_new);
	vm->registerNativeFunction("sb_append", StdLib::sb_append);
	vm->registerNativeFunction("sb_to_string", StdLib::sb_to_string);
	vm->registerNativeFunction("sb_free", StdLib::sb_free);
	vm->registerNativeFunction("sb_clear", StdLib::sb_clear);
	return true;
}

// StringBuilder Pool
static std::vector<std::string> sbPool;
static std::vector<size_t>      sbFreeIndices;

Value StdLib::str_find(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "find", true);
	std::string s = args[0].asString();
	std::string sub = args[1].asString();
	size_t pos;
	if (args.size() == 3) {
		int64_t start = args[2].asInt();
		pos = s.find(sub, start);
		if (pos != std::string::npos) {
			return static_cast<int64_t>(pos);
		}
		return -1;
	} else if (args.size() == 4) {
		int64_t start = args[2].asInt();
		int64_t end = args[3].asInt();
		pos = s.find(sub, start);
		if (pos != std::string::npos && pos < static_cast<size_t>(end)) {
			return static_cast<int64_t>(pos);
		}
		return -1;
	} else {
	pos = s.find(sub);
	}
	return pos != std::string::npos ? static_cast<int64_t>(pos) : false;
}

Value StdLib::sb_new(const std::vector<Value> &args, VM *)
{
	StdLib::checkArgCount(args, 0, "sb_new");
	size_t idx;
	if (!sbFreeIndices.empty())
	{
		idx = sbFreeIndices.back();
		sbFreeIndices.pop_back();
		sbPool[idx] = "";
	}
	else
	{
		idx = sbPool.size();
		sbPool.push_back("");
	}
	return static_cast<int64_t>(idx);
}

Value StdLib::sb_append(const std::vector<Value> &args, VM *)
{
	StdLib::checkArgCount(args, 2, "sb_append");
	int64_t idx = args[0].asInt();
	if (idx < 0 || idx >= static_cast<int64_t>(sbPool.size()))
		throw std::runtime_error("Invalid StringBuilder handle");

	sbPool[idx] += args[1].toString();
	return args[0]; // Return handle for chaining
}

Value StdLib::sb_to_string(const std::vector<Value> &args, VM *)
{
	StdLib::checkArgCount(args, 1, "sb_to_string");
	int64_t idx = args[0].asInt();
	if (idx < 0 || idx >= static_cast<int64_t>(sbPool.size()))
		throw std::runtime_error("Invalid StringBuilder handle");

	return Value(sbPool[idx]);
}

Value StdLib::sb_free(const std::vector<Value> &args, VM *)
{
	StdLib::checkArgCount(args, 1, "sb_free");
	size_t      idx = args[0].asInt();
	std::string value = sbPool[idx];
	sbFreeIndices.push_back(idx);
	return value;
}

Value StdLib::sb_clear(const std::vector<Value> &args, VM *)
{
	StdLib::checkArgCount(args, 1, "sb_clear");
	size_t idx = args[0].asInt();
	if (idx >= sbPool.size())
		throw std::runtime_error("Invalid StringBuilder handle");
	sbPool[idx].clear();
	return args[0]; // Return handle for chaining
}

Value StdLib::str_char_at(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "char_at");
	if (args[0].isString())
	{
		const std::string &s = args[0].asString();
		int64_t            idx = args[1].asInt();
		if (idx < 0 || idx >= static_cast<int64_t>(s.length()))
			return Value("");
		return Value(std::string(1, s[idx]));
	}
	throw std::runtime_error("char_at() expects a string");
}

Value StdLib::str_substr(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "substr", true);
	if (args.size() < 2 || args.size() > 3)
	{
		throw std::runtime_error("substr() expects 2 or 3 arguments");
	}
	std::string s = args[0].asString();
	int64_t     start = args[1].asInt();
	int64_t     len = args.size() == 3 ? args[2].asInt() : s.length() - start;

	if (start < 0 || start >= static_cast<int64_t>(s.length()))
	{
		return Value("");
	}

	return Value(s.substr(start, len));
}

Value StdLib::str_concat(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "concat");
	std::string result = "";
	for (const auto &arg : args)
	{
		result += arg.toString();
	}
	return Value(result);
}

Value StdLib::str_len(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "len");
	std::string s = args[0].toString();
	return static_cast<int64_t>(s.length());
}

Value StdLib::str_upper(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_upper");
	std::string s = args[0].asString();
	std::transform(s.begin(), s.end(), s.begin(), ::toupper);
	return Value(s);
}

Value StdLib::str_lower(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_lower");
	std::string s = args[0].asString();
	std::transform(s.begin(), s.end(), s.begin(), ::tolower);
	return Value(s);
}

Value StdLib::str_starts_with(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "starts_with");
	std::string s = args[0].asString();
	std::string prefix = args[1].asString();
	if (s.length() >= prefix.length())
	{
		return Value(s.compare(0, prefix.length(), prefix) == 0);
	}
	return Value(false);
}

Value StdLib::str_ends_with(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 2, "ends_with");
	std::string s = args[0].asString();
	std::string suffix = args[1].asString();
	if (s.length() >= suffix.length())
	{
		return Value(s.compare(s.length() - suffix.length(), suffix.length(), suffix) == 0);
	}
	return Value(false);
}
} // namespace Phasor

--- .\src\Runtime\Stdlib\system.cpp ---
#include "StdLib.hpp"
#include <atomic>
#include <chrono>
#include <thread>
#if defined(_MSC_VER)
#include <vcruntime_startup.h>
#endif

#include "core/system.h"

#if defined(_WIN32)
#include <windows.h>
#else
#include <unistd.h>
#endif

namespace Phasor
{

Value StdLib::registerSysFunctions(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "include_stdsys");
	vm->registerNativeFunction("time", StdLib::sys_time);
	vm->registerNativeFunction("timef", StdLib::sys_time_formatted);
	vm->registerNativeFunction("sleep", StdLib::sys_sleep);
	vm->registerNativeFunction("sys_os", StdLib::sys_os);
	vm->registerNativeFunction("sys_env", StdLib::sys_env);
	vm->registerNativeFunction("sys_argv", StdLib::sys_argv);
	vm->registerNativeFunction("sys_argc", StdLib::sys_argc);
	vm->registerNativeFunction("sys_get_memory", StdLib::system_get_free_memory);
	vm->registerNativeFunction("wait_for_input", StdLib::sys_wait_for_input);
	vm->registerNativeFunction("sys_shell", StdLib::sys_shell);
	vm->registerNativeFunction("sys_fork", StdLib::sys_fork);
	vm->registerNativeFunction("sys_fork_detached", StdLib::sys_fork_detached);
	vm->registerNativeFunction("error", StdLib::sys_crash);
	vm->registerNativeFunction("reset", StdLib::sys_reset);
	vm->registerNativeFunction("shutdown", StdLib::sys_shutdown);
	vm->registerNativeFunction("sys_pid", StdLib::sys_pid);
	return true;
}

Value StdLib::sys_time(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 0, "time");
	auto   now = std::chrono::steady_clock::now();
	auto   duration = now.time_since_epoch();
	double millis = std::chrono::duration<double, std::milli>(duration).count();
	return millis;
}

Value StdLib::sys_time_formatted(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "timef");
	std::string format = args[0].asString();

	auto        now = std::chrono::system_clock::now();
	std::time_t t = std::chrono::system_clock::to_time_t(now);

	std::tm tm{};
#if defined(_WIN32)
	localtime_s(&tm, &t);
#else
	localtime_r(&t, &tm);
#endif

	char buffer[256];
	if (std::strftime(buffer, sizeof(buffer), format.c_str(), &tm) == 0)
	{
		return Value(" ");
	}

	return std::string(buffer);
}

Value StdLib::sys_sleep(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "sleep");
	int64_t ms = args[0].asInt();
	std::this_thread::sleep_for(std::chrono::milliseconds(ms));
	return Value(" ");
}

Value StdLib::sys_os(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 0, "sys_os");
#if defined(_WIN32)
	return Value("win32");
#elif defined(__linux__)
	return Value("Linux");
#elif defined(__APPLE__)
	return Value("Darwin");
#elif defined(__FreeBSD__)
	return Value("FreeBSD");
#elif defined(__unix__)
	return Value("UNIX");
#else
	return Value("Unknown");
#endif
	return false;
}

Value StdLib::sys_env(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "sys_env");
	std::string key = args[0].asString();
	std::string value;
	dupenv(value, key.c_str(), envp);
	return value;
}

Value StdLib::sys_argv(const std::vector<Value> &args, VM *)
{
	if (args.size() == 0)
	{
		auto l_argv = std::make_shared<Value::StructInstance>();

		for (size_t i = 0; i < static_cast<size_t>(argc); i++)
		{
			l_argv->fields["arg" + std::to_string(i)] = Value(argv[i]);
		}

		return Value(l_argv);
	}

	checkArgCount(args, 1, "sys_argv");
	int64_t index = args[0].asInt();
	if (argv != nullptr)
		return argv[index];
	else
		return Value();
}

Value StdLib::sys_argc(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 0, "sys_argc");
	return argc;
}

Value StdLib::system_get_free_memory(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 0, "sys_get_memory");
	return static_cast<int64_t>(PHASORstd_sys_getAvailableMemory());
}

Value StdLib::sys_wait_for_input(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "wait_for_input");
	io_gets({}, vm);
	return Value("");
}

Value StdLib::sys_shell(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "sys_shell");
	return vm->regRun(OpCode::SYSTEM_R, args[0]);
}

Value StdLib::sys_fork(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "sys_fork", true);
	const char         *executable = args[0].c_str();
	int                 argc = (int)args.size() - 1;
	std::vector<char *> v_argv(argc);
	for (int i = 0; i < argc; ++i)
	{
		v_argv[i] = const_cast<char *>(args[i + 1].c_str());
	}
	return PHASORstd_sys_run(executable, argc, v_argv.data());
}

Value StdLib::sys_fork_detached(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "sys_fork_detached", true);
	const char         *executable = args[0].c_str();
	int                 argc = (int)args.size() - 1;
	std::vector<char *> v_argv(argc);
	for (int i = 0; i < argc; ++i)
	{
		v_argv[i] = const_cast<char *>(args[i + 1].c_str());
	}
	return PHASORstd_sys_run_detached(executable, argc, v_argv.data());
}

Value StdLib::sys_crash(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "error", true);
	vm->reset();
	vm->status = -1;
	throw std::runtime_error(args[0].asString());
}

Value StdLib::sys_reset(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "reset");
	vm->reset();
	return Value();
}

Value StdLib::sys_shutdown(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 1, "shutdown");
	vm->reset();
	int ret = static_cast<int>(args[0].asInt());
	vm->status = ret;
	throw VM::Halt();
	return Value();
}

Value StdLib::sys_pid(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 0, "sys_pid");
#if defined(_WIN32)
	return static_cast<int64_t>(GetCurrentProcessId());
#else
	return static_cast<int64_t>(getpid());
#endif
}

} // namespace Phasor


--- .\src\Runtime\Stdlib\typeconv.cpp ---
#include "StdLib.hpp"

namespace Phasor
{

Value StdLib::registerTypeConvFunctions(const std::vector<Value> &args, VM *vm)
{
	checkArgCount(args, 0, "include_stdtype");
	vm->registerNativeFunction("to_int", StdLib::to_int);
	vm->registerNativeFunction("to_float", StdLib::to_float);
	vm->registerNativeFunction("to_string", StdLib::to_string);
	vm->registerNativeFunction("to_bool", StdLib::to_bool);
	return true;
}

Value StdLib::to_int(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_int");
	if (args[0].isInt())
		return args[0];
	if (args[0].isFloat())
		return Value(static_cast<int64_t>(args[0].asFloat()));
	if (args[0].isString())
	{
		try
		{
			return static_cast<int64_t>(std::stoll(args[0].asString()));
		}
		catch (...)
		{
			return 0;
		}
	}
	if (args[0].isBool())
		return args[0].asBool() ? 1 : 0;
	return 0;
}

Value StdLib::to_float(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_float");
	return args[0].asFloat();
}

Value StdLib::to_string(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_string");
	return args[0].toString();
}

Value StdLib::to_bool(const std::vector<Value> &args, VM *)
{
	checkArgCount(args, 1, "to_bool");
	if (args[0].isBool())
		return args[0];
	if (args[0].isInt())
		return args[0].asInt() != 0;
	if (args[0].isString())
		return !args[0].asString().empty();
	return false;
}

} // namespace Phasor

--- .\src\Runtime\VM\CMakeLists.txt ---
set(VM_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/Native.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Operations.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Register.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Stack.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Utility.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/Variables.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/core/IO/IO.c
)

if(ASSEMBLY)
    list(APPEND VM_SOURCES ${ARITHMETIC_ASM} ${LOGICAL_ASM})
else()
    list(APPEND VM_SOURCES
        ${CMAKE_CURRENT_SOURCE_DIR}/core/arithmetic/crt.c
        ${CMAKE_CURRENT_SOURCE_DIR}/core/logical/crt.c
    )
endif()

set(VM_HEADERS
    ${CMAKE_CURRENT_SOURCE_DIR}/VM.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/core/core.h
    ${CMAKE_CURRENT_SOURCE_DIR}/core/arithmetic/arithmetic.h
    ${CMAKE_CURRENT_SOURCE_DIR}/core/logical/logical.h
    ${CMAKE_CURRENT_SOURCE_DIR}/core/IO/IO.h
)

set(VM_SOURCES ${VM_SOURCES} PARENT_SCOPE)
set(VM_HEADERS ${VM_HEADERS} PARENT_SCOPE)

--- .\src\Runtime\VM\core\arithmetic\arithmetic.h ---
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif
	/// @brief Native addition
	int64_t asm_iadd(int64_t a, int64_t b);
	double  asm_fladd(double a, double b);
	/// @brief Native subtraction
	int64_t asm_isub(int64_t a, int64_t b);
	double  asm_flsub(double a, double b);
	/// @brief Native multiplication
	int64_t asm_imul(int64_t a, int64_t b);
	double  asm_flmul(double a, double b);
	/// @brief Native negation
	int64_t asm_flneg(double a);
	/// @brief Native division
	int64_t asm_idiv(int64_t a, int64_t b);
	double  asm_fldiv(double a, double b);
	/// @brief Native modulus
	int64_t asm_imod(int64_t a, int64_t b);
	double  asm_flmod(double a, double b);
	/// @brief Native square root
	double asm_sqrt(double a);
	/// @brief Native power
	double asm_pow(double a, double b);
	/// @brief Native natural logarithm
	double asm_log(double a);
	/// @brief Native exponential
	double asm_exp(double a);
	/// @brief Native sine
	double asm_sin(double a);
	/// @brief Native cosine
	double asm_cos(double a);
	/// @brief Native tangent
	double asm_tan(double a);
#ifdef __cplusplus
}
#endif

--- .\src\Runtime\VM\core\arithmetic\bsd_x86_64.s ---
.intel_syntax noprefix
.text

.global _asm_iadd
.global _asm_isub
.global _asm_imul
.global _asm_ineg
.global _asm_idiv
.global _asm_imod
.global _asm_fladd
.global _asm_flsub
.global _asm_flmul
.global _asm_flneg
.global _asm_fldiv
.global _asm_flmod
.global _asm_sqrt
.global _asm_pow
.global _asm_log
.global _asm_exp
.global _asm_sin
.global _asm_cos
.global _asm_tan

.extern _sqrt
.extern _pow
.extern _log
.extern _exp
.extern _sin
.extern _cos
.extern _tan

_asm_iadd:
    mov rax, rdi
    add rax, rsi
    ret

_asm_isub:
    mov rax, rdi
    sub rax, rsi
    ret

_asm_imul:
    mov rax, rdi
    imul rax, rsi
    ret

_asm_ineg:
    mov rax, rdi
    neg rax
    ret

_asm_idiv:
    mov rax, rdi
    cqo
    idiv rsi
    ret

_asm_imod:
    mov rax, rdi
    cqo
    idiv rsi
    mov rax, rdx
    ret

_asm_fladd:
    addsd xmm0, xmm1
    ret

_asm_flsub:
    subsd xmm0, xmm1
    ret

_asm_flmul:
    mulsd xmm0, xmm1
    ret

_asm_flneg:
    xorpd xmm1, xmm1
    subsd xmm1, xmm0
    movapd xmm0, xmm1
    ret

_asm_fldiv:
    divsd xmm0, xmm1
    ret

_asm_flmod:
    movapd xmm2, xmm0
    divsd xmm2, xmm1
    roundsd xmm2, xmm2, 3
    mulsd xmm2, xmm1
    subsd xmm0, xmm2
    ret

_asm_sqrt:
    sub rsp, 8
    call _sqrt
    add rsp, 8
    ret

_asm_pow:
    sub rsp, 8
    call _pow
    add rsp, 8
    ret

_asm_log:
    sub rsp, 8
    call _log
    add rsp, 8
    ret

_asm_exp:
    sub rsp, 8
    call _exp
    add rsp, 8
    ret

_asm_sin:
    sub rsp, 8
    call _sin
    add rsp, 8
    ret

_asm_cos:
    sub rsp, 8
    call _cos
    add rsp, 8
    ret

_asm_tan:
    sub rsp, 8
    call _tan
    add rsp, 8
    ret


--- .\src\Runtime\VM\core\arithmetic\crt.c ---
#include "arithmetic.h"
#include <math.h>

int64_t asm_iadd(int64_t a, int64_t b)
{
	return a + b;
}
double asm_fladd(double a, double b)
{
	return a + b;
}

int64_t asm_isub(int64_t a, int64_t b)
{
	return a - b;
}
double asm_flsub(double a, double b)
{
	return a - b;
}

int64_t asm_imul(int64_t a, int64_t b)
{
	return a * b;
}
double asm_flmul(double a, double b)
{
	return a * b;
}

int64_t asm_ineg(int64_t a)
{
	return -a;
}
int64_t asm_flneg(double a)
{
	return -a;
}

int64_t asm_idiv(int64_t a, int64_t b)
{
	return a / b;
}
double asm_fldiv(double a, double b)
{
	return a / b;
}

int64_t asm_imod(int64_t a, int64_t b)
{
	return a % b;
}
double asm_flmod(double a, double b)
{
	return fmod(a, b);
}

double asm_sqrt(double a)
{
	return sqrt(a);
}

double asm_pow(double a, double b)
{
	return pow(a, b);
}

double asm_log(double a)
{
	return log(a);
}

double asm_exp(double a)
{
	return exp(a);
}

double asm_sin(double a)
{
	return sin(a);
}

double asm_cos(double a)
{
	return cos(a);
}

double asm_tan(double a)
{
	return tan(a);
}


--- .\src\Runtime\VM\core\arithmetic\linux_x86_64.s ---
.intel_syntax noprefix
.text

.global asm_iadd
.global asm_isub
.global asm_imul
.global asm_ineg
.global asm_idiv
.global asm_imod
.global asm_fladd
.global asm_flsub
.global asm_flmul
.global asm_flneg
.global asm_fldiv
.global asm_flmod
.global asm_sqrt
.global asm_pow
.global asm_log
.global asm_exp
.global asm_sin
.global asm_cos
.global asm_tan

.extern sqrt
.extern pow
.extern log
.extern exp
.extern sin
.extern cos
.extern tan

# int64_t asm_iadd(int64_t a, int64_t b)
# rdi = a, rsi = b
asm_iadd:
    mov rax, rdi
    add rax, rsi
    ret

# int64_t asm_isub(int64_t a, int64_t b)
asm_isub:
    mov rax, rdi
    sub rax, rsi
    ret

# int64_t asm_imul(int64_t a, int64_t b)
asm_imul:
    mov rax, rdi
    imul rax, rsi
    ret

# int64_t asm_ineg(int64_t a)
asm_ineg:
    mov rax, rdi
    neg rax
    ret

# int64_t asm_idiv(int64_t a, int64_t b)
asm_idiv:
    mov rax, rdi
    cqo
    idiv rsi
    ret

# int64_t asm_imod(int64_t a, int64_t b)
asm_imod:
    mov rax, rdi
    cqo
    idiv rsi
    mov rax, rdx
    ret

# double asm_fladd(double a, double b)
# xmm0 = a, xmm1 = b
asm_fladd:
    addsd xmm0, xmm1
    ret

# double asm_flsub(double a, double b)
asm_flsub:
    subsd xmm0, xmm1
    ret

# double asm_flmul(double a, double b)
asm_flmul:
    mulsd xmm0, xmm1
    ret

# double asm_flneg(double a)
asm_flneg:
    xorpd xmm1, xmm1
    subsd xmm1, xmm0
    movapd xmm0, xmm1
    ret

# double asm_fldiv(double a, double b)
asm_fldiv:
    divsd xmm0, xmm1
    ret

# double asm_flmod(double a, double b)
asm_flmod:
    movapd xmm2, xmm0
    divsd xmm2, xmm1
    roundsd xmm2, xmm2, 3
    mulsd xmm2, xmm1
    subsd xmm0, xmm2
    ret

# double asm_sqrt(double a)
asm_sqrt:
    sub rsp, 8
    call sqrt
    add rsp, 8
    ret

# double asm_pow(double a, double b)
asm_pow:
    sub rsp, 8
    call pow
    add rsp, 8
    ret

# double asm_log(double a)
asm_log:
    sub rsp, 8
    call log
    add rsp, 8
    ret

# double asm_exp(double a)
asm_exp:
    sub rsp, 8
    call exp
    add rsp, 8
    ret

# double asm_sin(double a)
asm_sin:
    sub rsp, 8
    call sin
    add rsp, 8
    ret

# double asm_cos(double a)
asm_cos:
    sub rsp, 8
    call cos
    add rsp, 8
    ret

# double asm_tan(double a)
asm_tan:
    sub rsp, 8
    call tan
    add rsp, 8
    ret

.section .note.GNU-stack,"",@progbits


--- .\src\Runtime\VM\core\arithmetic\windows_x86_64.asm ---
; arithmetic/windows_x86_64.asm
; Defines arithmetic operations used by the VM for x86_64 on Windows

; PUBLIC SYMBOLS
PUBLIC asm_iadd
PUBLIC asm_isub
PUBLIC asm_imul
PUBLIC asm_ineg
PUBLIC asm_idiv
PUBLIC asm_imod
PUBLIC asm_sqrt
PUBLIC asm_pow
PUBLIC asm_log
PUBLIC asm_exp
PUBLIC asm_sin
PUBLIC asm_cos
PUBLIC asm_tan

EXTERN sqrt:PROC
EXTERN pow:PROC
EXTERN log:PROC
EXTERN exp:PROC
EXTERN sin:PROC
EXTERN cos:PROC
EXTERN tan:PROC

.CODE

; int64_t asm_iadd(int64_t a, int64_t b)
; asm_iadd rcx a, rdx b
asm_iadd PROC
    mov rax, rcx      ; copy first argument a into return register
    add rax, rdx      ; add second argument b
    ret
asm_iadd ENDP

; int64_t asm_isub(int64_t a, int64_t b)
; asm_isub rcx a, rdx b
asm_isub PROC
    mov rax, rcx      ; copy a
    sub rax, rdx      ; subtract b
    ret
asm_isub ENDP

; int64_t asm_imul(int64_t a, int64_t b)
; asm_imul rcx a, rdx b
asm_imul PROC
    mov rax, rcx      ; copy a
    imul rax, rdx     ; multiply by b
    ret
asm_imul ENDP

; int64_t asm_ineg(int64_t a)
; asm_ineg rcx a
asm_ineg PROC
    mov rax, rcx      ; copy a
    neg rax           ; negate value
    ret
asm_ineg ENDP

; int64_t asm_idiv(int64_t a, int64_t b)
; asm_idiv rcx a, rdx b
asm_idiv PROC
    mov rax, rcx      ; copy dividend into rax
    mov r8, rdx       ; save divisor in r8 to avoid clobber from cqo
    cqo                ; sign-extend rax into rdx:rax
    idiv r8           ; divide by b
    ret
asm_idiv ENDP

; int64_t asm_imod(int64_t a, int64_t b)
; asm_imod rcx a, rdx b
asm_imod PROC
    mov rax, rcx      ; copy dividend
    mov r8, rdx       ; save divisor
    cqo
    idiv r8           ; divide, remainder in rdx
    mov rax, rdx      ; return remainder
    ret
asm_imod ENDP

; double asm_fladd(double a, double b)
; asm_fladd xmm0 a, xmm1 b
asm_fladd PROC
    addsd xmm0, xmm1       ; a + b
    ret
asm_fladd ENDP

; double asm_flsub(double a, double b)
; asm_flsub xmm0 a, xmm1 b
asm_flsub PROC
    subsd xmm0, xmm1       ; a - b
    ret
asm_flsub ENDP

; double asm_flmul(double a, double b)
; asm_flmul xmm0 a, xmm1 b
asm_flmul PROC
    mulsd xmm0, xmm1       ; a * b
    ret
asm_flmul ENDP

; double asm_flneg(double a)
; asm_flneg xmm0 a
asm_flneg PROC
    xorpd xmm1, xmm1       ; zero in xmm1
    subsd xmm0, xmm1       ; 0 - a
    ret
asm_flneg ENDP

; double asm_fldiv(double a, double b)
; asm_fldiv xmm0 a, xmm1 b
asm_fldiv PROC
    divsd xmm0, xmm1       ; a / b
    ret
asm_fldiv ENDP

; double asm_flmod(double a, double b)
; asm_flmod xmm0 a, xmm1 b
asm_flmod PROC
    movapd xmm2, xmm0   ; xmm2 = a
    divsd xmm2, xmm1    ; xmm2 = a / b
    roundsd xmm2, xmm2, 3  ; truncate toward zero (SSE4.1)
    mulsd xmm2, xmm1    ; xmm2 = trunc(a/b) * b
    subsd xmm0, xmm2    ; xmm0 = a - xmm2
    ret
asm_flmod ENDP

; double asm_sqrt(double a)
; asm_sqrt xmm0 a
asm_sqrt PROC
    sub rsp, 40       ; shadow space (32) + alignment (8)
    call sqrt
    add rsp, 40
    ret
asm_sqrt ENDP

; double asm_pow(double a, double b)
; asm_pow xmm0 a, xmm1 b
asm_pow PROC
    sub rsp, 40
    call pow
    add rsp, 40
    ret
asm_pow ENDP

; double asm_log(double a)
; asm_log xmm0 a
asm_log PROC
    sub rsp, 40
    call log
    add rsp, 40
    ret
asm_log ENDP

; double asm_exp(double a)
; asm_exp xmm0 a
asm_exp PROC
    sub rsp, 40
    call exp
    add rsp, 40
    ret
asm_exp ENDP

; double asm_sin(double a)
; asm_sin xmm0 a
asm_sin PROC
    sub rsp, 40
    call sin
    add rsp, 40
    ret
asm_sin ENDP

; double asm_cos(double a)
; asm_cos xmm0 a
asm_cos PROC
    sub rsp, 40
    call cos
    add rsp, 40
    ret
asm_cos ENDP

; double asm_tan(double a)
; asm_tan xmm0 a
asm_tan PROC
    sub rsp, 40
    call tan
    add rsp, 40
    ret
asm_tan ENDP

END

--- .\src\Runtime\VM\core\core.h ---
// Native machine functions
#include "arithmetic/arithmetic.h"
#include "logical/logical.h"
#include "IO/IO.h"

--- .\src\Runtime\VM\core\IO\IO.c ---
#include "IO.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#include <sys/wait.h>
#endif

static char **parse_argv(const char *cmd, int *argc)
{
	if (!cmd || !*cmd)
		return NULL;
	size_t len = strlen(cmd);
	char  *copy = malloc(len + 1);
	if (!copy)
		return NULL;

#ifdef _WIN32
	strcpy_s(copy, len + 1, cmd);
#else
	strcpy(copy, cmd);
#endif

	*argc = 0;
#ifdef _WIN32
	char *context = NULL;
	char *token = strtok_s(copy, " ", &context);
#else
	char *token = strtok(copy, " ");
#endif
	while (token)
	{
		(*argc)++;
#ifdef _WIN32
		token = strtok_s(NULL, " ", &context);
#else
		token = strtok(NULL, " ");
#endif
	}

#ifdef _WIN32
	strcpy_s(copy, len + 1, cmd);
#else
	strcpy(copy, cmd);
#endif

	char **argv = malloc((*argc + 1) * sizeof(char *));
	if (!argv)
	{
		free(copy);
		return NULL;
	}

	int i = 0;
#ifdef _WIN32
	token = strtok_s(copy, " ", &context);
#else
	token = strtok(copy, " ");
#endif
	while (token)
	{
		argv[i] = malloc(strlen(token) + 1);
		if (!argv[i])
		{
			for (int j = 0; j < i; j++)
				free(argv[j]);
			free(argv);
			free(copy);
			return NULL;
		}
#ifdef _WIN32
		strcpy_s(argv[i], strlen(token) + 1, token);
#else
		strcpy(argv[i], token);
#endif
		i++;
#ifdef _WIN32
		token = strtok_s(NULL, " ", &context);
#else
		token = strtok(NULL, " ");
#endif
	}
	argv[i] = NULL;
	free(copy);
	return argv;
}

static void free_argv(char **argv)
{
	if (!argv)
		return;
	for (int i = 0; argv[i]; i++)
		free(argv[i]);
	free(argv);
}

void asm_print_stdout(const char *s, int64_t len)
{
	fwrite(s, 1, (size_t)len, stdout);
	fflush(stdout);
}

void asm_print_stderr(const char *s, int64_t len)
{
	fwrite(s, 1, (size_t)len, stderr);
	fflush(stderr);
}

int64_t asm_system(const char *cmd)
{
	return (int64_t)system(cmd);
}

char *asm_system_out(const char *cmd)
{
	int    argc;
	char **argv = parse_argv(cmd, &argc);
	if (!argv)
		return NULL;
	char  *output = NULL;
	size_t output_size = 0;
	size_t output_capacity = 1024;
	output = malloc(output_capacity);
	if (!output)
	{
		free_argv(argv);
		return NULL;
	}
#ifdef _WIN32
	SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
	HANDLE              hRead, hWrite;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		free(output);
		free_argv(argv);
		return NULL;
	}
	STARTUPINFO si = {sizeof(STARTUPINFO)};
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdOutput = hWrite; // capture stdout
	si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	PROCESS_INFORMATION pi;
	if (!CreateProcess(NULL, (char *)cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		CloseHandle(hRead);
		CloseHandle(hWrite);
		free(output);
		free_argv(argv);
		return NULL;
	}
	CloseHandle(hWrite);
	DWORD bytesRead;
	char  buffer[1024];
	while (ReadFile(hRead, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0)
	{
		if (output_size + bytesRead >= output_capacity)
		{
			output_capacity *= 2;
			char *new_output = realloc(output, output_capacity);
			if (!new_output)
			{
				CloseHandle(hRead);
				CloseHandle(pi.hProcess);
				CloseHandle(pi.hThread);
				free(output);
				free_argv(argv);
				return NULL;
			}
			output = new_output;
		}
		memcpy(output + output_size, buffer, bytesRead);
		output_size += bytesRead;
	}
	output[output_size] = '\0';
	CloseHandle(hRead);
	WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
#else
	int pipefd[2];
	if (pipe(pipefd) == -1)
	{
		free(output);
		free_argv(argv);
		return NULL;
	}
	pid_t pid = fork();
	if (pid == -1)
	{
		close(pipefd[0]);
		close(pipefd[1]);
		free(output);
		free_argv(argv);
		return NULL;
	}
	if (pid == 0)
	{
		close(pipefd[0]);
		dup2(pipefd[1], STDOUT_FILENO);
		close(pipefd[1]);
		execvp(argv[0], argv);
		_exit(1);
	}
	else
	{
		close(pipefd[1]);
		ssize_t bytesRead;
		char    buffer[1024];
		while ((bytesRead = read(pipefd[0], buffer, sizeof(buffer))) > 0)
		{
			if (output_size + bytesRead >= output_capacity)
			{
				output_capacity *= 2;
				char *new_output = realloc(output, output_capacity);
				if (!new_output)
				{
					close(pipefd[0]);
					free(output);
					free_argv(argv);
					return NULL;
				}
				output = new_output;
			}
			memcpy(output + output_size, buffer, bytesRead);
			output_size += bytesRead;
		}
		output[output_size] = '\0';
		close(pipefd[0]);
		int status;
		waitpid(pid, &status, 0);
	}
#endif
	free_argv(argv);
	return output;
}

char *asm_system_err(const char *cmd)
{
	int    argc;
	char **argv = parse_argv(cmd, &argc);
	if (!argv)
		return NULL;
	char  *output = NULL;
	size_t output_size = 0;
	size_t output_capacity = 1024;
	output = malloc(output_capacity);
	if (!output)
	{
		free_argv(argv);
		return NULL;
	}
#ifdef _WIN32
	SECURITY_ATTRIBUTES sa = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
	HANDLE              hRead, hWrite;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		free(output);
		free_argv(argv);
		return NULL;
	}
	STARTUPINFO si = {sizeof(STARTUPINFO)};
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	si.hStdError = hWrite;
	si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	PROCESS_INFORMATION pi;
	if (!CreateProcess(NULL, (char *)cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi))
	{
		CloseHandle(hRead);
		CloseHandle(hWrite);
		free(output);
		free_argv(argv);
		return NULL;
	}
	CloseHandle(hWrite);
	DWORD bytesRead;
	char  buffer[1024];
	while (ReadFile(hRead, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead > 0)
	{
		if (output_size + bytesRead >= output_capacity)
		{
			output_capacity *= 2;
			char *new_output = realloc(output, output_capacity);
			if (!new_output)
			{
				CloseHandle(hRead);
				CloseHandle(pi.hProcess);
				CloseHandle(pi.hThread);
				free(output);
				free_argv(argv);
				return NULL;
			}
			output = new_output;
		}
		memcpy(output + output_size, buffer, bytesRead);
		output_size += bytesRead;
	}
	output[output_size] = '\0';
	CloseHandle(hRead);
	WaitForSingleObject(pi.hProcess, INFINITE);
	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
#else
	int pipefd[2];
	if (pipe(pipefd) == -1)
	{
		free(output);
		free_argv(argv);
		return NULL;
	}
	pid_t pid = fork();
	if (pid == -1)
	{
		close(pipefd[0]);
		close(pipefd[1]);
		free(output);
		free_argv(argv);
		return NULL;
	}
	if (pid == 0)
	{
		close(pipefd[0]);
		dup2(pipefd[1], STDERR_FILENO);
		close(pipefd[1]);
		execvp(argv[0], argv);
		_exit(1);
	}
	else
	{
		close(pipefd[1]);
		ssize_t bytesRead;
		char    buffer[1024];
		while ((bytesRead = read(pipefd[0], buffer, sizeof(buffer))) > 0)
		{
			if (output_size + bytesRead >= output_capacity)
			{
				output_capacity *= 2;
				char *new_output = realloc(output, output_capacity);
				if (!new_output)
				{
					close(pipefd[0]);
					free(output);
					free_argv(argv);
					return NULL;
				}
				output = new_output;
			}
			memcpy(output + output_size, buffer, bytesRead);
			output_size += bytesRead;
		}
		output[output_size] = '\0';
		close(pipefd[0]);
		int status;
		waitpid(pid, &status, 0);
	}
#endif
	free_argv(argv);
	return output;
}


--- .\src\Runtime\VM\core\IO\IO.h ---
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif
	/// @brief Native print function
	void asm_print_stdout(const char *s, int64_t len);
	/// @brief Native print error function
	void asm_print_stderr(const char *s, int64_t len);
	/// @brief CRT system call
	int64_t asm_system(const char *cmd);
	/// @brief CRT system call, get out
	char *asm_system_out(const char *cmd);
	/// @brief CRT system call, get err
	char *asm_system_err(const char *cmd);
#ifdef __cplusplus
}
#endif

--- .\src\Runtime\VM\core\logical\bsd_x86_64.s ---
.intel_syntax noprefix
.text
.global _asm_inot
.global _asm_iand
.global _asm_ior
.global _asm_ixor
.global _asm_iequal
.global _asm_inot_equal
.global _asm_iless_than
.global _asm_igreater_than
.global _asm_iless_equal
.global _asm_igreater_equal
.global _asm_flnot
.global _asm_fland
.global _asm_flor
.global _asm_flxor
.global _asm_flequal
.global _asm_flnot_equal
.global _asm_flless_than
.global _asm_flgreater_than
.global _asm_flless_equal
.global _asm_flgreater_equal

# int64_t asm_inot(int64_t a)
# rdi = a
_asm_inot:
    xor rax, rax
    test rdi, rdi
    setz al
    ret

# int64_t asm_iand(int64_t a, int64_t b)
# rdi = a, rsi = b
_asm_iand:
    xor rax, rax
    test rdi, rdi
    jz L_and_done
    test rsi, rsi
    jz L_and_done
    mov rax, 1
L_and_done:
    ret

# int64_t asm_ior(int64_t a, int64_t b)
_asm_ior:
    xor rax, rax
    test rdi, rdi
    jnz L_or_true
    test rsi, rsi
    jz L_or_done
L_or_true:
    mov rax, 1
L_or_done:
    ret

# int64_t asm_ixor(int64_t a, int64_t b)
_asm_ixor:
    xor rax, rax
    test rdi, rdi
    setnz al
    mov rcx, rax
    xor rax, rax
    test rsi, rsi
    setnz al
    xor rax, rcx
    ret

# int64_t asm_iequal(int64_t a, int64_t b)
_asm_iequal:
    xor rax, rax
    cmp rdi, rsi
    sete al
    ret

# int64_t asm_inot_equal(int64_t a, int64_t b)
_asm_inot_equal:
    xor rax, rax
    cmp rdi, rsi
    setne al
    ret

# int64_t asm_iless_than(int64_t a, int64_t b)
_asm_iless_than:
    xor rax, rax
    cmp rdi, rsi
    setl al
    ret

# int64_t asm_igreater_than(int64_t a, int64_t b)
_asm_igreater_than:
    xor rax, rax
    cmp rdi, rsi
    setg al
    ret

# int64_t asm_iless_equal(int64_t a, int64_t b)
_asm_iless_equal:
    xor rax, rax
    cmp rdi, rsi
    setle al
    ret

# int64_t asm_igreater_equal(int64_t a, int64_t b)
_asm_igreater_equal:
    xor rax, rax
    cmp rdi, rsi
    setge al
    ret

# int64_t asm_flnot(double a)
# xmm0 = a
_asm_flnot:
    xor rax, rax
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    sete al
    ret

# int64_t asm_fland(double a, double b)
# xmm0 = a, xmm1 = b
_asm_fland:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    and al, cl
    ret

# int64_t asm_flor(double a, double b)
_asm_flor:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    or al, cl
    ret

# int64_t asm_flxor(double a, double b)
_asm_flxor:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    xor al, cl
    ret

# int64_t asm_flequal(double a, double b)
_asm_flequal:
    xor rax, rax
    ucomisd xmm0, xmm1
    sete al
    ret

# int64_t asm_flnot_equal(double a, double b)
_asm_flnot_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setne al
    ret

# int64_t asm_flless_than(double a, double b)
_asm_flless_than:
    xor rax, rax
    ucomisd xmm0, xmm1
    setb al
    ret

# int64_t asm_flgreater_than(double a, double b)
_asm_flgreater_than:
    xor rax, rax
    ucomisd xmm0, xmm1
    seta al
    ret

# int64_t asm_flless_equal(double a, double b)
_asm_flless_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setbe al
    ret

# int64_t asm_flgreater_equal(double a, double b)
_asm_flgreater_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setae al
    ret

--- .\src\Runtime\VM\core\logical\crt.c ---
#include "logical.h"

int64_t asm_inot(int64_t a)
{
	return a == 0 ? 1 : 0;
}

int64_t asm_iand(int64_t a, int64_t b)
{
	return (a != 0 && b != 0) ? 1 : 0;
}

int64_t asm_ior(int64_t a, int64_t b)
{
	return (a != 0 || b != 0) ? 1 : 0;
}

int64_t asm_ixor(int64_t a, int64_t b)
{
	int a_bool = (a != 0);
	int b_bool = (b != 0);
	return (a_bool ^ b_bool) ? 1 : 0;
}

int64_t asm_iequal(int64_t a, int64_t b)
{
	return (a == b) ? 1 : 0;
}

int64_t asm_inot_equal(int64_t a, int64_t b)
{
	return (a != b) ? 1 : 0;
}

int64_t asm_iless_than(int64_t a, int64_t b)
{
	return (a < b) ? 1 : 0;
}

int64_t asm_igreater_than(int64_t a, int64_t b)
{
	return (a > b) ? 1 : 0;
}

int64_t asm_iless_equal(int64_t a, int64_t b)
{
	return (a <= b) ? 1 : 0;
}

int64_t asm_igreater_equal(int64_t a, int64_t b)
{
	return (a >= b) ? 1 : 0;
}

int64_t asm_flnot(double a)
{
	return a == 0 ? 1 : 0;
}

int64_t asm_fland(double a, double b)
{
	return (a != 0 && b != 0) ? 1 : 0;
}

int64_t asm_flor(double a, double b)
{
	return (a != 0 || b != 0) ? 1 : 0;
}

int64_t asm_flxor(double a, double b)
{
	int a_bool = (a != 0);
	int b_bool = (b != 0);
	return (a_bool ^ b_bool) ? 1 : 0;
}

int64_t asm_flequal(double a, double b)
{
	return (a == b) ? 1 : 0;
}

int64_t asm_flnot_equal(double a, double b)
{
	return (a != b) ? 1 : 0;
}

int64_t asm_flless_than(double a, double b)
{
	return (a < b) ? 1 : 0;
}

int64_t asm_flgreater_than(double a, double b)
{
	return (a > b) ? 1 : 0;
}

int64_t asm_flless_equal(double a, double b)
{
	return (a <= b) ? 1 : 0;
}

int64_t asm_flgreater_equal(double a, double b)
{
	return (a >= b) ? 1 : 0;
}


--- .\src\Runtime\VM\core\logical\linux_x86_64.s ---
.intel_syntax noprefix
.text

.global asm_inot
.global asm_iand
.global asm_ior
.global asm_ixor
.global asm_iequal
.global asm_inot_equal
.global asm_iless_than
.global asm_igreater_than
.global asm_iless_equal
.global asm_igreater_equal
.global asm_flnot
.global asm_fland
.global asm_flor
.global asm_flxor
.global asm_flequal
.global asm_flnot_equal
.global asm_flless_than
.global asm_flgreater_than
.global asm_flless_equal
.global asm_flgreater_equal

# int64_t asm_inot(int64_t a)
# rdi = a
asm_inot:
    xor rax, rax
    test rdi, rdi
    setz al
    ret

# int64_t asm_iand(int64_t a, int64_t b)
# rdi = a, rsi = b
asm_iand:
    xor rax, rax
    test rdi, rdi
    jz .and_done
    test rsi, rsi
    jz .and_done
    mov rax, 1
.and_done:
    ret

# int64_t asm_ior(int64_t a, int64_t b)
asm_ior:
    xor rax, rax
    test rdi, rdi
    jnz .or_true
    test rsi, rsi
    jz .or_done
.or_true:
    mov rax, 1
.or_done:
    ret

# int64_t asm_ixor(int64_t a, int64_t b)
asm_ixor:
    xor rax, rax
    test rdi, rdi
    setnz al
    mov rcx, rax
    xor rax, rax
    test rsi, rsi
    setnz al
    xor rax, rcx
    ret

# int64_t asm_iequal(int64_t a, int64_t b)
asm_iequal:
    xor rax, rax
    cmp rdi, rsi
    sete al
    ret

# int64_t asm_inot_equal(int64_t a, int64_t b)
asm_inot_equal:
    xor rax, rax
    cmp rdi, rsi
    setne al
    ret

# int64_t asm_iless_than(int64_t a, int64_t b)
asm_iless_than:
    xor rax, rax
    cmp rdi, rsi
    setl al
    ret

# int64_t asm_igreater_than(int64_t a, int64_t b)
asm_igreater_than:
    xor rax, rax
    cmp rdi, rsi
    setg al
    ret

# int64_t asm_iless_equal(int64_t a, int64_t b)
asm_iless_equal:
    xor rax, rax
    cmp rdi, rsi
    setle al
    ret

# int64_t asm_igreater_equal(int64_t a, int64_t b)
asm_igreater_equal:
    xor rax, rax
    cmp rdi, rsi
    setge al
    ret

# int64_t asm_flnot(double a)
# xmm0 = a
asm_flnot:
    xor rax, rax
    xorpd xmm1, xmm1
    ucomisd xmm0, xmm1
    sete al
    ret

# int64_t asm_fland(double a, double b)
# xmm0 = a, xmm1 = b
asm_fland:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    and al, cl
    ret

# int64_t asm_flor(double a, double b)
asm_flor:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    or al, cl
    ret

# int64_t asm_flxor(double a, double b)
asm_flxor:
    xor rax, rax
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne al
    ucomisd xmm1, xmm2
    setne cl
    xor al, cl
    ret

# int64_t asm_flequal(double a, double b)
asm_flequal:
    xor rax, rax
    ucomisd xmm0, xmm1
    sete al
    ret

# int64_t asm_flnot_equal(double a, double b)
asm_flnot_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setne al
    ret

# int64_t asm_flless_than(double a, double b)
asm_flless_than:
    xor rax, rax
    ucomisd xmm0, xmm1
    setb al
    ret

# int64_t asm_flgreater_than(double a, double b)
asm_flgreater_than:
    xor rax, rax
    ucomisd xmm0, xmm1
    seta al
    ret

# int64_t asm_flless_equal(double a, double b)
asm_flless_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setbe al
    ret

# int64_t asm_flgreater_equal(double a, double b)
asm_flgreater_equal:
    xor rax, rax
    ucomisd xmm0, xmm1
    setae al
    ret

.section .note.GNU-stack,"",@progbits


--- .\src\Runtime\VM\core\logical\logical.h ---
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif
	/// @brief Native bitwise NOT
	int64_t asm_flnot(double a);
	/// @brief Native bitwise AND
	int64_t asm_iand(int64_t a, int64_t b);
	int64_t asm_fland(double a, double b);
	/// @brief Native bitwise OR
	int64_t asm_ior(int64_t a, int64_t b);
	int64_t asm_flor(double a, double b);
	/// @brief Native bitwise XOR
	int64_t asm_ixor(int64_t a, int64_t b);
	int64_t asm_flxor(double a, double b);
	/// @brief Native Equality comparison
	int64_t asm_iequal(int64_t a, int64_t b);
	int64_t asm_flequal(double a, double b);
	/// @brief Native Inequality comparison
	int64_t asm_inot_equal(int64_t a, int64_t b);
	int64_t asm_flnot_equal(double a, double b);
	/// @brief Native Less than comparison
	int64_t asm_iless_than(int64_t a, int64_t b);
	int64_t asm_flless_than(double a, double b);
	/// @brief Native Greater than comparison
	int64_t asm_igreater_than(int64_t a, int64_t b);
	int64_t asm_flgreater_than(double a, double b);
	/// @brief Native Less than or equal comparison
	int64_t asm_iless_equal(int64_t a, int64_t b);
	int64_t asm_flless_equal(double a, double b);
	/// @brief Native Greater than or equal comparison
	int64_t asm_igreater_equal(int64_t a, int64_t b);
	int64_t asm_flgreater_equal(double a, double b);
#ifdef __cplusplus
}
#endif

--- .\src\Runtime\VM\core\logical\windows_x86_64.asm ---
; core/logical/windows_x86_64.asm
; Defines logical operations used by the VM for x86_64 on Windows

; PUBLIC SYMBOLS
PUBLIC asm_inot
PUBLIC asm_iand
PUBLIC asm_ior
PUBLIC asm_ixor
PUBLIC asm_iequal
PUBLIC asm_inot_equal
PUBLIC asm_iless_than
PUBLIC asm_igreater_than
PUBLIC asm_iless_equal
PUBLIC asm_igreater_equal
PUBLIC asm_flnot
PUBLIC asm_fland
PUBLIC asm_flor
PUBLIC asm_flxor
PUBLIC asm_flequal
PUBLIC asm_flnot_equal
PUBLIC asm_flless_than
PUBLIC asm_flgreater_than
PUBLIC asm_flless_equal
PUBLIC asm_flgreater_equal

.CODE

; int64_t asm_inot(int64_t a)
; asm_inot rcx a
asm_inot PROC
    xor rax, rax      ; clear rax
    test rcx, rcx     ; check if a == 0
    setz al           ; set rax = 1 if zero, 0 otherwise
    ret
asm_inot ENDP

; int64_t asm_iand(int64_t a, int64_t b)
; asm_iand rcx a, rdx b
asm_iand PROC
    xor rax, rax      ; initialize result = 0
    test rcx, rcx     ; check a
    jz done_and       ; short-circuit if a == 0
    test rdx, rdx     ; check b
    jz done_and       ; short-circuit if b == 0
    mov rax, 1        ; both non-zero -> result = 1
done_and:
    ret
asm_iand ENDP

; int64_t asm_ior(int64_t a, int64_t b)
; asm_ior rcx a, rdx b
asm_ior PROC
    xor rax, rax      ; initialize result = 0
    test rcx, rcx     ; check a
    jnz set_true_or   ; if a != 0, result = 1
    test rdx, rdx     ; check b
    jz done_or        ; if b == 0, result = 0
set_true_or:
    mov rax, 1        ; either a or b non-zero -> result = 1
done_or:
    ret
asm_ior ENDP

; int64_t asm_ixor(int64_t a, int64_t b)
; asm_ixor rcx a, rdx b
asm_ixor PROC
    xor rax, rax              ; clear result
    test rcx, rcx             ; check a
    setnz al                  ; set al = 1 if a != 0
    mov r8, rax               ; store a's truth value in r8
    xor rax, rax              ; clear rax again
    test rdx, rdx             ; check b
    setnz al                  ; set al = 1 if b != 0
    xor rax, r8               ; rax = a_truth_value XOR b_truth_value
    ret
asm_ixor ENDP

; int64_t asm_iequal(int64_t a, int64_t b)
; asm_iequal rcx a, rdx b
asm_iequal PROC
    xor rax, rax              ; clear result
    cmp rcx, rdx              ; compare a and b
    sete al                   ; set rax = 1 if equal
    ret
asm_iequal ENDP

; int64_t asm_inot_equal(int64_t a, int64_t b)
; asm_inot_equal rcx a, rdx b
asm_inot_equal PROC
    xor rax, rax
    cmp rcx, rdx
    setne al                  ; set rax = 1 if not equal
    ret
asm_inot_equal ENDP

; int64_t asm_iless_than(int64_t a, int64_t b)
; asm_iless_than rcx a, rdx b
asm_iless_than PROC
    xor rax, rax
    cmp rcx, rdx
    setl al                   ; set rax = 1 if a < b
    ret
asm_iless_than ENDP

; int64_t asm_igreater_than(int64_t a, int64_t b)
; asm_igreater_than rcx a, rdx b
asm_igreater_than PROC
    xor rax, rax
    cmp rcx, rdx
    setg al                   ; set rax = 1 if a > b
    ret
asm_igreater_than ENDP

; int64_t asm_iless_equal(int64_t a, int64_t b)
; asm_iless_equal rcx a, rdx b
asm_iless_equal PROC
    xor rax, rax
    cmp rcx, rdx
    setle al                  ; set rax = 1 if a <= b
    ret
asm_iless_equal ENDP

; int64_t asm_igreater_equal(int64_t a, int64_t b)
; asm_igreater_equal rcx a, rdx b
asm_igreater_equal PROC
    xor rax, rax
    cmp rcx, rdx
    setge al                  ; set rax = 1 if a >= b
    ret
asm_igreater_equal ENDP

; int64_t asm_flnot(double a)
; asm_flnot xmm0 a
asm_flnot PROC
    xor rax, rax
    xorpd xmm2, xmm2          ; zero xmm2
    ucomisd xmm0, xmm2        ; compare xmm0 with 0.0
    sete al                   ; rax = 1 if xmm0 == 0.0
    ret
asm_flnot ENDP

; int64_t asm_fland(double a, double b)
; asm_fland xmm0 a, xmm1 b
asm_fland PROC
    xor rax, rax
    xor r8, r8
    xor r9, r9
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne r8b                 ; r8 = xmm0 != 0
    ucomisd xmm1, xmm2
    setne r9b                 ; r9 = xmm1 != 0
    mov al, r8b
    and al, r9b               ; rax = xmm0 && xmm1
    ret
asm_fland ENDP

; int64_t asm_flor(double a, double b)
; asm_flor xmm0 a, xmm1 b
asm_flor PROC
    xor rax, rax
    xor r8, r8
    xor r9, r9
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne r8b
    ucomisd xmm1, xmm2
    setne r9b
    mov al, r8b
    or al, r9b                ; rax = xmm0 || xmm1
    ret
asm_flor ENDP

; int64_t asm_flxor(double a, double b)
; asm_flxor xmm0 a, xmm1 b
asm_flxor PROC
    xor rax, rax
    xor r8, r8
    xor r9, r9
    xorpd xmm2, xmm2
    ucomisd xmm0, xmm2
    setne r8b
    ucomisd xmm1, xmm2
    setne r9b
    mov al, r8b
    xor al, r9b               ; rax = xmm0 != xmm1
    ret
asm_flxor ENDP

; int64_t asm_flequal(double a, double b)
; asm_flequal xmm0 a, xmm1 b
asm_flequal PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    sete al                   ; rax = 1 if xmm0 == xmm1
    ret
asm_flequal ENDP

; int64_t asm_flnot_equal(double a, double b)
; asm_flnot_equal xmm0 a, xmm1 b
asm_flnot_equal PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    setne al                  ; rax = 1 if xmm0 != xmm1
    ret
asm_flnot_equal ENDP

; int64_t asm_flless_than(double a, double b)
; asm_flless_than xmm0 a, xmm1 b
asm_flless_than PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    setb al                   ; rax = 1 if xmm0 < xmm1
    ret
asm_flless_than ENDP

; int64_t asm_flgreater_than(double a, double b)
; asm_flgreater_than xmm0 a, xmm1 b
asm_flgreater_than PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    seta al                   ; rax = 1 if xmm0 > xmm1
    ret
asm_flgreater_than ENDP

; int64_t asm_flless_equal(double a, double b)
; asm_flless_equal xmm0 a, xmm1 b
asm_flless_equal PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    setbe al                  ; rax = 1 if xmm0 <= xmm1
    ret
asm_flless_equal ENDP

; int64_t asm_flgreater_equal(double a, double b)
; asm_flgreater_equal xmm0 a, xmm1 b
asm_flgreater_equal PROC
    xor rax, rax
    ucomisd xmm0, xmm1
    setae al                  ; rax = 1 if xmm0 >= xmm1
    ret
asm_flgreater_equal ENDP


END

--- .\src\Runtime\VM\Native.cpp ---
#include "VM.hpp"

void Phasor::VM::registerNativeFunction(const std::string &name, NativeFunction fn)
{
	nativeFunctions[name] = fn;
}

--- .\src\Runtime\VM\Operations.cpp ---
#include "VM.hpp"
#include <iostream>

namespace Phasor
{
Value VM::operation(const OpCode &op, const int &operand1, const int &operand2, const int &operand3,
                    const int &, const int &)
{
	uint8_t rA = static_cast<uint8_t>(operand1);
	uint8_t rB = static_cast<uint8_t>(operand2);
	uint8_t rC = static_cast<uint8_t>(operand3);
//      uint8_t rD = static_cast<uint8_t>(operand4);
//      uint8_t rE = static_cast<uint8_t>(operand5);
#ifdef _DEBUG
	log(std::string("OP: " + std::to_string(static_cast<int>(op)) + " operands=[" + std::to_string(operand1) + ", " + std::to_string(operand2) + ", " + std::to_string(operand3)
	          + "] stack=" + std::to_string(stack.size()) + "\n"));
#endif
	switch (op)
	{
	case OpCode::PUSH_CONST:
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->constants.size()))
			throw std::runtime_error("Invalid constant index");
		push(m_bytecode->constants[operand1]);
		break;

	case OpCode::POP:
		pop();
		break;

	case OpCode::IADD: {
		Value b = pop();
		Value a = pop();
		push(asm_iadd(a.asInt(), b.asInt()));
		break;
	}

	case OpCode::ISUBTRACT: {
		Value b = pop();
		Value a = pop();
		push(asm_isub(a.asInt(), b.asInt()));
		break;
	}

	case OpCode::IMULTIPLY: {
		Value b = pop();
		Value a = pop();
		push(asm_imul(a.asInt(), b.asInt()));
		break;
	}

	case OpCode::IDIVIDE: {
		Value b = pop();
		Value a = pop();
		push(asm_idiv(a.asInt(), b.asInt()));
		break;
	}

	case OpCode::IMODULO: {
		Value b = pop();
		Value a = pop();
		push(asm_imod(a.asInt(), b.asInt()));
		break;
	}

	case OpCode::FLADD: {
		Value b = pop();
		Value a = pop();
		push(asm_fladd(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::FLSUBTRACT: {
		Value b = pop();
		Value a = pop();
		push(asm_flsub(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::FLMULTIPLY: {
		Value b = pop();
		Value a = pop();
		push(asm_flmul(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::FLDIVIDE: {
		Value b = pop();
		Value a = pop();
		push(asm_fldiv(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::FLMODULO: {
		Value b = pop();
		Value a = pop();
		push(asm_flmod(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::SQRT: {
		Value a = pop();
		push(asm_sqrt(a.asFloat()));
		break;
	}

	case OpCode::POW: {
		Value b = pop();
		Value a = pop();
		push(asm_pow(a.asFloat(), b.asFloat()));
		break;
	}

	case OpCode::LOG: {
		Value a = pop();
		push(asm_log(a.asFloat()));
		break;
	}

	case OpCode::EXP: {
		Value a = pop();
		push(asm_exp(a.asFloat()));
		break;
	}

	case OpCode::SIN: {
		Value a = pop();
		push(asm_sin(a.asFloat()));
		break;
	}

	case OpCode::COS: {
		Value a = pop();
		push(asm_cos(a.asFloat()));
		break;
	}

	case OpCode::TAN: {
		Value a = pop();
		push(asm_tan(a.asFloat()));
		break;
	}

	case OpCode::NEGATE:
		push(asm_flneg(pop().asFloat()));
		break;

	case OpCode::NOT:
		push(Value(asm_flnot(pop().isTruthy() ? 1 : 0)));
		break;

	case OpCode::IAND: {
		Value b = pop();
		Value a = pop();
		push(Value(asm_iand(a.isTruthy() ? 1 : 0, b.isTruthy() ? 1 : 0)));
		break;
	}

	case OpCode::IOR: {
		Value b = pop();
		Value a = pop();
		push(Value(asm_ior(a.isTruthy() ? 1 : 0, b.isTruthy() ? 1 : 0)));
		break;
	}

	case OpCode::IEQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_iequal(a.asInt(), b.asInt())) : Value(a == b));
		break;
	}

	case OpCode::INOT_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_inot_equal(a.asInt(), b.asInt())) : Value(a != b));
		break;
	}

	case OpCode::ILESS_THAN: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_iless_than(a.asInt(), b.asInt())) : Value(a < b));
		break;
	}

	case OpCode::IGREATER_THAN: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_igreater_than(a.asInt(), b.asInt())) : Value(a > b));
		break;
	}

	case OpCode::ILESS_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_iless_equal(a.asInt(), b.asInt())) : Value(a <= b));
		break;
	}

	case OpCode::IGREATER_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isInt() && b.isInt() ? Value(asm_igreater_equal(a.asInt(), b.asInt())) : Value(a >= b));
		break;
	}

	case OpCode::FLAND: {
		Value b = pop();
		Value a = pop();
		push(Value(asm_fland(a.isTruthy() ? 1 : 0, b.isTruthy() ? 1 : 0)));
		break;
	}

	case OpCode::FLOR: {
		Value b = pop();
		Value a = pop();
		push(Value(asm_flor(a.isTruthy() ? 1 : 0, b.isTruthy() ? 1 : 0)));
		break;
	}

	case OpCode::FLEQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flequal(a.asFloat(), b.asFloat())) : Value(a == b));
		break;
	}

	case OpCode::FLNOT_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flnot_equal(a.asFloat(), b.asFloat())) : Value(a != b));
		break;
	}

	case OpCode::FLLESS_THAN: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flless_than(a.asFloat(), b.asFloat())) : Value(a < b));
		break;
	}

	case OpCode::FLGREATER_THAN: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flgreater_than(a.asFloat(), b.asFloat())) : Value(a > b));
		break;
	}

	case OpCode::FLLESS_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flless_equal(a.asFloat(), b.asFloat())) : Value(a <= b));
		break;
	}

	case OpCode::FLGREATER_EQUAL: {
		Value b = pop();
		Value a = pop();
		push(a.isFloat() && b.isFloat() ? Value(asm_flgreater_equal(a.asFloat(), b.asFloat())) : Value(a >= b));
		break;
	}

	case OpCode::JUMP:
		pc = operand1;
		break;

	case OpCode::JUMP_IF_FALSE:
		if (!pop().isTruthy())
			pc = operand1;
		break;

	case OpCode::JUMP_IF_TRUE:
		if (pop().isTruthy())
			pc = operand1;
		break;

	case OpCode::JUMP_BACK:
		pc = operand1;
		break;

	case OpCode::STORE_VAR:
		if (operand1 < 0 || operand1 >= static_cast<int>(variables.size()))
			throw std::runtime_error("Invalid variable index");
		variables[operand1] = pop();
		break;

	case OpCode::LOAD_VAR:
		if (operand1 < 0 || operand1 >= static_cast<int>(variables.size()))
			throw std::runtime_error("Invalid variable index");
		push(variables[operand1]);
		break;

	case OpCode::PRINT: {
		Value       v = pop();
		std::string s = v.toString();
		asm_print_stdout(s.c_str(), s.length());
		break;
	}

	case OpCode::PRINTERROR: {
		Value       v = pop();
		std::string s = v.toString();
		asm_print_stderr(s.c_str(), s.length());
		flusherr();
		break;
	}

	case OpCode::READLINE: {
		std::string s;
		std::getline(std::cin, s);
		push(s);
		break;
	}

	case OpCode::IMPORT: {
		Value       pathVal = m_bytecode->constants[operand1];
		std::string path = pathVal.asString();
		if (importHandler)
			importHandler(path);
		else
			throw std::runtime_error("Import handler not set");
		break;
	}
	case OpCode::HALT:
		pc = m_bytecode->instructions.size(); // stop execution
		break;

	case OpCode::CALL_NATIVE: {
		Value       funcNameVal = m_bytecode->constants[operand1];
		std::string funcName = funcNameVal.asString();
		auto        it = nativeFunctions.find(funcName);
		if (it == nativeFunctions.end())
			throw std::runtime_error("Unknown native function: " + funcName);

		int                argCount = static_cast<int>(pop().asInt());
		std::vector<Value> args(argCount);
		for (int i = argCount - 1; i >= 0; --i)
			args[i] = pop();

		push(it->second(args, this));
		break;
	}
	case OpCode::TRUE_P:
		push(Value(true));
		break;

	case OpCode::FALSE_P:
		push(Value(false));
		break;

	case OpCode::NULL_VAL:
		push(Value());
		break;

	case OpCode::CALL: {
		Value       funcNameVal = m_bytecode->constants[operand1];
		std::string funcName = funcNameVal.asString();
		auto        it = m_bytecode->functionEntries.find(funcName);
		if (it == m_bytecode->functionEntries.end())
			throw std::runtime_error("Unknown function: " + funcName);

		callStack.push_back(static_cast<int>(pc));
		pc = it->second;
		break;
	}
	case OpCode::RETURN: {
		if (callStack.empty())
		{
			pc = m_bytecode->instructions.size();
			break;
		}
		pc = callStack.back();
		callStack.pop_back();
		break;
	}

	case OpCode::SYSTEM: {
		asm_system(registers[rA].c_str());
		break;
	}

	case OpCode::SYSTEM_OUT: {
		push(asm_system_out(registers[rA].c_str()));
		break;
	}

	case OpCode::SYSTEM_ERR: {
		push(asm_system_err(registers[rA].c_str()));
		break;
	}

	// Register-based operations (v2.0)
	case OpCode::MOV: {
		registers[rA] = registers[rB];
		break;
	}

	case OpCode::LOAD_CONST_R: {
		// LOAD_CONST_R rA, constIndex
		int constIndex = operand2;
		if (constIndex < 0 || constIndex >= static_cast<int>(m_bytecode->constants.size()))
			throw std::runtime_error("Invalid constant index");
		registers[rA] = m_bytecode->constants[constIndex];
		break;
	}

	case OpCode::LOAD_VAR_R: {
		// LOAD_VAR_R rA, varIndex
		int varIndex = operand2;
		if (varIndex < 0 || varIndex >= static_cast<int>(variables.size()))
			throw std::runtime_error("Invalid variable index");
		registers[rA] = variables[varIndex];
		break;
	}

	case OpCode::STORE_VAR_R: {
		// STORE_VAR_R rA, varIndex - store register rA to variable varIndex
		int varIndex = operand2;
		if (varIndex < 0 || varIndex >= static_cast<int>(variables.size()))
			throw std::runtime_error("Invalid variable index");
		variables[varIndex] = registers[rA];
		break;
	}

	// Register arithmetic (3-address code)
	// Format: operand1=rA (dest), operand2=rB, operand3=rC
	case OpCode::IADD_R: {
		registers[rA] = Value(asm_iadd(registers[rB].asInt(), registers[rC].asInt()));
		break;
	}

	case OpCode::ISUB_R: {
		registers[rA] = Value(asm_isub(registers[rB].asInt(), registers[rC].asInt()));
		break;
	}

	case OpCode::IMUL_R: {
		registers[rA] = Value(asm_imul(registers[rB].asInt(), registers[rC].asInt()));
		break;
	}

	case OpCode::IDIV_R: {
		registers[rA] = Value(asm_idiv(registers[rB].asInt(), registers[rC].asInt()));
		break;
	}

	case OpCode::IMOD_R: {
		registers[rA] = Value(asm_imod(registers[rB].asInt(), registers[rC].asInt()));
		break;
	}

	case OpCode::FLADD_R: {
		registers[rA] = Value(asm_fladd(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::FLSUB_R: {
		registers[rA] = Value(asm_flsub(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::FLMUL_R: {
		registers[rA] = Value(asm_flmul(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::FLDIV_R: {
		registers[rA] = Value(asm_fldiv(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::FLMOD_R: {
		registers[rA] = Value(asm_flmod(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::SQRT_R: {
		registers[rA] = Value(asm_sqrt(registers[rB].asFloat()));
		break;
	}

	case OpCode::POW_R: {
		registers[rA] = Value(asm_pow(registers[rB].asFloat(), registers[rC].asFloat()));
		break;
	}

	case OpCode::LOG_R: {
		registers[rA] = Value(asm_log(registers[rB].asFloat()));
		break;
	}

	case OpCode::EXP_R: {
		registers[rA] = Value(asm_exp(registers[rB].asFloat()));
		break;
	}

	case OpCode::SIN_R: {
		registers[rA] = Value(asm_sin(registers[rB].asFloat()));
		break;
	}

	case OpCode::COS_R: {
		registers[rA] = Value(asm_cos(registers[rB].asFloat()));
		break;
	}

	case OpCode::TAN_R: {
		registers[rA] = Value(asm_tan(registers[rB].asFloat()));
		break;
	}

	// Register comparisons
	// Format: operand1=rA (dest), operand2=rB, operand3=rC
	case OpCode::IEQ_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_iequal(b.asInt(), c.asInt())) : Value(b == c);
		break;
	}

	case OpCode::INE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_inot_equal(b.asInt(), c.asInt())) : Value(b != c);
		break;
	}

	case OpCode::ILT_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_iless_than(b.asInt(), c.asInt())) : Value(b < c);
		break;
	}

	case OpCode::IGT_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_igreater_than(b.asInt(), c.asInt())) : Value(b > c);
		break;
	}

	case OpCode::ILE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_iless_equal(b.asInt(), c.asInt())) : Value(b <= c);
		break;
	}

	case OpCode::IGE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isInt() && c.isInt()) ? Value(asm_igreater_equal(b.asInt(), c.asInt())) : Value(b >= c);
		break;
	}

	case OpCode::IAND_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = Value(asm_iand(b.isTruthy() ? 1 : 0, c.isTruthy() ? 1 : 0));
		break;
	}

	case OpCode::IOR_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = Value(asm_ior(b.isTruthy() ? 1 : 0, c.isTruthy() ? 1 : 0));
		break;
	}

	case OpCode::FLEQ_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isFloat() && c.isFloat()) ? Value(asm_flequal(b.asFloat(), c.asFloat())) : Value(b == c);
		break;
	}

	case OpCode::FLNE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isFloat() && c.isFloat()) ? Value(asm_flnot_equal(b.asFloat(), c.asFloat())) : Value(b != c);
		break;
	}

	case OpCode::FLLT_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = (b.isFloat() && c.isFloat()) ? Value(asm_flless_than(b.asFloat(), c.asFloat())) : Value(b < c);
		break;
	}

	case OpCode::FLGT_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] =
		    (b.isFloat() && c.isFloat()) ? Value(asm_flgreater_than(b.asFloat(), c.asFloat())) : Value(b > c);
		break;
	}

	case OpCode::FLLE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] =
		    (b.isFloat() && c.isFloat()) ? Value(asm_flless_equal(b.asFloat(), c.asFloat())) : Value(b <= c);
		break;
	}

	case OpCode::FLGE_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] =
		    (b.isFloat() && c.isFloat()) ? Value(asm_flgreater_equal(b.asFloat(), c.asFloat())) : Value(b >= c);
		break;
	}

	case OpCode::FLAND_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = Value(asm_fland(b.isTruthy() ? 1 : 0, c.isTruthy() ? 1 : 0));
		break;
	}

	case OpCode::FLOR_R: {
		Value &b = registers[rB];
		Value &c = registers[rC];
		registers[rA] = Value(asm_flor(b.isTruthy() ? 1 : 0, c.isTruthy() ? 1 : 0));
		break;
	}

	// Register-stack interaction
	case OpCode::PUSH_R: {
		push(registers[rA]);
		break;
	}

	case OpCode::PUSH2_R: {
		push(registers[rA]);
		push(registers[rB]);
		break;
	}

	case OpCode::POP_R: {
		registers[rA] = pop();
		break;
	}

	case OpCode::POP2_R: {
		registers[rA] = pop();
		registers[rB] = pop();
		break;
	}

	// Register unary operations
	case OpCode::NEG_R: {
		// NEG_R rA, rB - rA = -rB
		registers[rA] = Value(asm_flneg(registers[rB].asFloat()));
		break;
	}

	case OpCode::NOT_R: {
		// NOT_R rA, rB - rA = !rB
		registers[rA] = Value(asm_flnot(registers[rB].isTruthy() ? 1 : 0));
		break;
	}

	// Register I/O
	case OpCode::PRINT_R: {
		std::string s = registers[rA].toString();
		asm_print_stdout(s.c_str(), s.length());
		break;
	}

	case OpCode::PRINTERROR_R: {
		std::string s = registers[rA].toString();
		asm_print_stderr(s.c_str(), s.length());
		break;
	}

	case OpCode::READLINE_R: {
		std::string s;
		std::getline(std::cin, s);
		registers[rA] = s;
		break;
	}

	case OpCode::SYSTEM_R: {
		registers[rA] = asm_system(registers[rA].c_str());
		break;
	}

	case OpCode::SYSTEM_OUT_R: {
		registers[rA] = asm_system_out(registers[rA].c_str());
		break;
	}

	case OpCode::SYSTEM_ERR_R: {
		registers[rA] = asm_system_err(registers[rA].c_str());
		break;
	}

	case OpCode::LEN: {
		Value v = pop();
		push(Value(static_cast<int64_t>(v.asString().length())));
		break;
	}

	case OpCode::CHAR_AT: {
		Value idxVal = pop();
		Value strVal = pop();

		std::string s;
		if (strVal.isString())
			s = strVal.asString();
		else
			s = strVal.toString();

		int64_t idx = 0;
		if (idxVal.isInt())
			idx = idxVal.asInt();
		else if (idxVal.isFloat())
			idx = static_cast<int64_t>(idxVal.asFloat());
		else if (idxVal.isString())
		{
			// Try to parse numeric string
			try
			{
				idx = std::stoll(idxVal.asString());
			}
			catch (...)
			{
				throw std::runtime_error("char_at() expects index convertible to integer");
			}
		}
		else
			throw std::runtime_error("char_at() expects string and integer");

		if (idx < 0 || idx >= static_cast<int64_t>(s.length()))
			push(Value(""));
		else
			push(Value(std::string(1, s[static_cast<size_t>(idx)])));
		break;
	}

	case OpCode::SUBSTR: {
		Value lenVal = pop();
		Value startVal = pop();
		Value strVal = pop();

		if (strVal.isString() && startVal.isInt() && lenVal.isInt())
		{
			const std::string &s = strVal.asString();
			int64_t            start = startVal.asInt();
			int64_t            len = lenVal.asInt();

			if (start < 0 || start >= static_cast<int64_t>(s.length()))
			{
				push(Value(""));
			}
			else
			{
				push(Value(s.substr(start, len)));
			}
		}
		else
		{
			throw std::runtime_error("substr() expects string, int, int");
		}
		break;
	}

	case OpCode::NEW_STRUCT_INSTANCE_STATIC: {
		// operand1: structIndex into bytecode->structs
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->structs.size()))
			throw std::runtime_error("Invalid struct index for NEW_STRUCT_INSTANCE_STATIC");

		const StructInfo &info = m_bytecode->structs[operand1];
		// Create struct instance by name, then apply default values from constants
		Value instance = Value::createStruct(info.name);
		for (int i = 0; i < info.fieldCount; ++i)
		{
			int constIndex = info.firstConstIndex + i;
			if (constIndex < 0 || constIndex >= static_cast<int>(m_bytecode->constants.size()))
				throw std::runtime_error("Invalid default constant index for struct field");
			const Value       &defVal = m_bytecode->constants[constIndex];
			const std::string &fieldName = info.fieldNames[i];
			instance.setField(fieldName, defVal);
		}
		push(instance);
		break;
	}

	case OpCode::GET_FIELD_STATIC: {
		// operand1: structIndex, operand2: fieldOffset
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->structs.size()))
			throw std::runtime_error("Invalid struct index for GET_FIELD_STATIC");
		const StructInfo &info = m_bytecode->structs[operand1];
		int               fieldOffset = operand2;
		if (fieldOffset < 0 || fieldOffset >= info.fieldCount)
			throw std::runtime_error("Invalid field offset for GET_FIELD_STATIC");
		const std::string &fieldName = info.fieldNames[fieldOffset];
		Value              obj = pop();
		push(obj.getField(fieldName));
		break;
	}

	case OpCode::SET_FIELD_STATIC: {
		// operand1: structIndex, operand2: fieldOffset
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->structs.size()))
			throw std::runtime_error("Invalid struct index for SET_FIELD_STATIC");
		const StructInfo &info = m_bytecode->structs[operand1];
		int               fieldOffset = operand2;
		if (fieldOffset < 0 || fieldOffset >= info.fieldCount)
			throw std::runtime_error("Invalid field offset for SET_FIELD_STATIC");
		const std::string &fieldName = info.fieldNames[fieldOffset];
		Value              value = pop();
		Value              obj = pop();
		obj.setField(fieldName, value);
		push(obj);
		break;
	}

	case OpCode::NEW_STRUCT: {
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->constants.size()))
			throw std::runtime_error("Invalid constant index for NEW_STRUCT");
		Value       nameVal = m_bytecode->constants[operand1];
		std::string structName = nameVal.asString();
		push(Value::createStruct(structName));
		break;
	}

	case OpCode::SET_FIELD: {
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->constants.size()))
			throw std::runtime_error("Invalid constant index for SET_FIELD");
		std::string fieldName = m_bytecode->constants[operand1].asString();
		Value       value = pop();
		Value       obj = pop();
		obj.setField(fieldName, value);
		push(obj);
		break;
	}

	case OpCode::GET_FIELD: {
		if (operand1 < 0 || operand1 >= static_cast<int>(m_bytecode->constants.size()))
			throw std::runtime_error("Invalid constant index for GET_FIELD");
		std::string fieldName = m_bytecode->constants[operand1].asString();
		Value       obj = pop();
		push(obj.getField(fieldName));
		break;
	}

	default:
		throw std::runtime_error("Unknown opcode");
	}
	return Value(operand1);
}
} // namespace Phasor

--- .\src\Runtime\VM\Register.cpp ---
#include "VM.hpp"

namespace Phasor
{

void VM::setRegister(const uint8_t index, const Value &value)
{
	registers[index] = value;
}

void VM::freeRegister(const uint8_t index)
{
	registers[index] = Value(); // Reset to null
}

Value VM::getRegister(const uint8_t index)
{
	return registers[index];
}

size_t VM::getRegisterCount()
{
	return registers.size();
}

} // namespace Phasor

--- .\src\Runtime\VM\Stack.cpp ---
#include "VM.hpp"
#include <stdexcept>

namespace Phasor
{

void VM::push(const Value &value)
{
	stack.push_back(value);
}

Value VM::pop()
{
	if (stack.empty())
	{
		// Provide PC information to aid debugging
		std::string msg = "Stack underflow at pc=" + std::to_string(pc);
		throw std::runtime_error(msg);
	}
	Value value = stack.back();
	stack.pop_back();
	return value;
}

Value VM::peek()
{
	if (stack.empty())
	{
		std::string msg = "Stack is empty at pc=" + std::to_string(pc);
		throw std::runtime_error(msg);
	}
	return stack.back();
}

} // namespace Phasor

--- .\src\Runtime\VM\Utility.cpp ---
#include "VM.hpp"
#include <iostream>
#include <stdexcept>
#include "core/core.h"

namespace Phasor
{

int VM::run(const Bytecode &bc)
{
	m_bytecode = &bc;
	pc = 0;
	stack.clear();
	callStack.clear();

	registers.fill(Value());
	variables.resize(m_bytecode->nextVarIndex);

	while (pc < m_bytecode->instructions.size())
	{
		const Instruction &instr = m_bytecode->instructions[pc++];
#ifdef _DEBUG
		log(std::string("EXEC idx=" + std::to_string(pc - 1) + " op=" + std::to_string(static_cast<int>(instr.op)) + " stack=" + std::to_string(stack.size()) + "\n"));
		flush();
#endif
		try
		{
			operation(instr.op, instr.operand1, instr.operand2, instr.operand3, instr.operand4, instr.operand5);
		}
		catch (const VM::Halt &)
		{
			return status;
		}
		catch (const std::exception &ex)
		{
			std::cerr << ex.what() << "\n\n" << getInformation() << "\n";
			throw;
		}
	}
	return 1;
}

void VM::setImportHandler(const ImportHandler &handler)
{
	importHandler = handler;
}

void VM::reset(const bool &resetStack, const bool &resetFunctions, const bool &resetVariables)
{
	if (resetStack)
	{
		stack.clear();
		callStack.clear();
	}
	if (resetFunctions)
	{
		nativeFunctions.clear();
	}
	if (resetVariables)
	{
		variables.clear();
	}
	pc = 0;
	m_bytecode = nullptr;
}

std::string VM::getInformation()
{
	int    callStackTop = callStack.empty() ? -1 : callStack.back();
	size_t programCounter = pc;

	std::string info = "Stack Top: ";
	info += peek().toString();
	info += " | R0: ";
	info += registers[0].toString();
	info += " | R1: ";
	info += registers[1].toString();
	info += " | R2: ";
	info += registers[2].toString();
	info += " | R3: ";
	info += registers[3].toString();
	info += " | Current Program Counter: " + std::to_string(programCounter);
	info += " | PC Stack Top: " + std::to_string(callStackTop);
	return info;
}

void VM::log(const Value &msg)
{
	std::string s = msg.toString();
	asm_print_stdout(s.c_str(), s.length());
}

void VM::logerr(const Value &msg)
{
	std::string s = msg.toString();
	asm_print_stderr(s.c_str(), s.length());
}

void VM::flush() 
{
	fflush(stdout);
}

void VM::flusherr()
{
	fflush(stderr);
}
} // namespace Phasor

--- .\src\Runtime\VM\Variables.cpp ---
#include "VM.hpp"

namespace Phasor
{

size_t VM::addVariable(const Value &value)
{
	variables.push_back(value);
	return variables.size() - 1;
}

void VM::freeVariable(const size_t index)
{
	if (index < variables.size())
	{
		variables[index] = Value(); // Reset to null
	}
}

void VM::setVariable(const size_t index, const Value &value)
{
	if (index >= variables.size())
	{
		throw std::runtime_error("Invalid variable index");
	}
	variables[index] = value;
}

Value VM::getVariable(const size_t index)
{
	if (index >= variables.size())
	{
		throw std::runtime_error("Invalid variable index");
	}
	return variables[index];
}

size_t VM::getVariableCount()
{
	return variables.size();
}

} // namespace Phasor

--- .\src\Runtime\VM\VM.hpp ---
#pragma once
#include "../../Codegen/CodeGen.hpp"
#include <Value.hpp>
#include <vector>
#include <filesystem>
#include <functional>
#include <map>
#include <array>
#include "core/core.h"
#include <iostream>
#include <stdexcept>

/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/// @class VM
/// @brief Virtual Machine
class VM
{
  public:
	explicit VM()
	{
	}
	explicit VM(const Bytecode &bytecode)
	{
		run(bytecode);
	}
	explicit VM(const OpCode &op, const int &operand1 = 0, const int &operand2 = 0, const int &operand3 = 0,
	            const int &operand4 = 0, const int &operand5 = 0)
	{
		operation(op, operand1, operand2, operand3, operand4, operand5);
	}
	~VM()
	{
		flush();
		flusherr();
	}
	/// @brief Run the virtual machine
	/// Exits -11654 on unknown error
	int run(const Bytecode &bytecode);

	/// @brief Native function signature
	using NativeFunction = std::function<Value(const std::vector<Value> &args, VM *vm)>;

	/// @brief Register a native function
	void registerNativeFunction(const std::string &name, NativeFunction fn);

	using ImportHandler = std::function<void(const std::filesystem::path &path)>;
	void setImportHandler(const ImportHandler &handler);

	/// @brief Free a variable in the VM
	void freeVariable(const size_t index);

	/// @brief Add a variable to the VM
	/// @param value The value to add
	/// @return The index of the variable
	size_t addVariable(const Value &value);

	/// @brief Set a variable in the VM
	/// @param index The index of the variable
	/// @param value The value to set
	void setVariable(const size_t index, const Value &value);

	/// @brief Get a variable from the VM
	Value getVariable(const size_t index);

	/// @brief Get the number of variables in the VM
	size_t getVariableCount();

	/// @brief Set a register value
	/// @param index Register index
	/// @param value Value to set
	void setRegister(uint8_t index, const Value &value);

	/// @brief Free a register (reset to null)
	/// @param index Register index to free
	void freeRegister(uint8_t index);

	/// @brief Get a register value
	/// @param index Register index
	/// @return Value in the register
	Value getRegister(uint8_t index);

	/// @brief Get the total number of registers
	/// @return Number of registers
	size_t getRegisterCount();

	/// @brief Enum for registers
	enum Register
	{
		r0,
		r1,
		r2,
		r3,
		r4,
		r5,
		r6,
		r7,
		r8,
		r9,
		r10,
		r11,
		r12,
		r13,
		r14,
		r15,
		r16,
		r17,
		r18,
		r19,
		r20,
		r21,
		r22,
		r23,
		r24,
		r25,
		r26,
		r27,
		r28,
		r29,
		r30,
		r31
	};

	#define REGISTER1 VM::Register::r0
	#define REGISTER2 VM::Register::r1
	#define REGISTER3 VM::Register::r2

	class Halt : public std::exception
	{
	  public:
		const char *what() const noexcept override
		{
			return "";
		}
	};

#ifdef _WIN32
	/// @brief Execute a single operation
	Value __fastcall operation(const OpCode &op, const int &operand1 = 0, const int &operand2 = 0,
	                           const int &operand3 = 0, const int &operand4 = 0, const int &operand5 = 0);
#else
	/// @brief Execute a single operation
	Value operation(const OpCode &op, const int &operand1 = 0, const int &operand2 = 0, const int &operand3 = 0,
	                const int &operand4 = 0, const int &operand5 = 0);
#endif
	/// @brief Push a value onto the stack
	void push(const Value &value);

	/// @brief Pop a value from the stack
	Value pop();

	/// @brief Peek at the top value on the stack
	Value peek();

	/// @brief Reset the virtual machine
	void reset(const bool &resetStack = true, const bool &resetFunctions = true, const bool &resetVariables = true);

	/// @brief Get VM information for debugging
	std::string getInformation();

	/// @brief Use the VM's logging via print opcode
	void log(const Value &msg);
	void logerr(const Value &msg);
	void flush();
	void flusherr();

	int status = 0;

	template <typename... Args> inline Value regRun( OpCode opcode, Args &&...args)
	{
		int regIndex = 0;
		(setRegister(regIndex++, std::forward<Args>(args)), ...);
		return operation(opcode);
	}

  private:
	/// @brief Import handler for loading modules
	ImportHandler importHandler;

	/// @brief Virtual registers for register-based operations (v2.0)
	std::array<Value, 32> registers;

	/// @brief Stack for function calls
	std::vector<Value> stack;

	/// @brief Call stack for function calls
	std::vector<int> callStack;

	/// @brief Variable storage indexed by variable index
	std::vector<Value> variables;

	/// @brief Bytecode to execute
	const Bytecode *m_bytecode{};

	/// @brief Program counter
	size_t pc = 0;

	/// @brief Native function registry
	std::map<std::string, NativeFunction> nativeFunctions;
};
} // namespace Phasor


--- .\src\Update-ResourceVersion.py ---
#!/usr/bin/env python3

import sys
import re
from pathlib import Path


def dot_to_comma(version: str) -> str:
    return version.replace('.', ',')


def update_resource_version(old_version: str, new_version: str) -> None:
    app_dir = Path("./Executable")
    
    if not app_dir.exists():
        print(f"Error: Directory '{app_dir}' does not exist")
        sys.exit(1)
    
    old_version_comma = dot_to_comma(old_version)
    new_version_comma = dot_to_comma(new_version)
    
    old_version_string = f"{old_version}.0"
    new_version_string = f"{new_version}.0"
    
    old_version_comma_escaped = re.escape(old_version_comma)
    
    rc_files = list(app_dir.rglob("*.rc"))
    
    if not rc_files:
        print(f"No .rc files found in {app_dir}")
        return
    
    files_updated = 0
    for file_path in rc_files:
        try:
            lines = file_path.read_text(encoding='utf-8').splitlines(keepends=True)
            updated_lines = []
            file_modified = False
            
            for line in lines:
                new_line = line
                trimmed = line.lstrip()
                
                if trimmed.startswith("FILEVERSION") and re.search(old_version_comma_escaped, line):
                    new_line = re.sub(old_version_comma_escaped, new_version_comma, line)
                    file_modified = True

                elif trimmed.startswith("PRODUCTVERSION") and re.search(old_version_comma_escaped, line):
                    new_line = re.sub(old_version_comma_escaped, new_version_comma, line)
                    file_modified = True
                
                elif 'VALUE "FileVersion",' in line:
                    parts = line.split('"')
                    if len(parts) > 3 and parts[3] == old_version_string:
                        parts[3] = new_version_string
                        new_line = '"'.join(parts)
                        file_modified = True
                
                elif 'VALUE "ProductVersion",' in line:
                    parts = line.split('"')
                    if len(parts) > 3 and parts[3] == old_version_string:
                        parts[3] = new_version_string
                        new_line = '"'.join(parts)
                        file_modified = True
                
                updated_lines.append(new_line)
            
            if file_modified:
                file_path.write_text(''.join(updated_lines), encoding='utf-8')
                files_updated += 1
                
        except Exception as e:
            print(f"Error processing {file_path}: {e}")
    
    print(f"Updated .rc files from {old_version} to {new_version}")
    print(f"Files modified: {files_updated}/{len(rc_files)}")


def main():
    if len(sys.argv) != 3:
        print(f"Usage: python {Path(__file__).name} <old version> <new version>")
        sys.exit(1)
    
    old_version = sys.argv[1]
    new_version = sys.argv[2]
    
    update_resource_version(old_version, new_version)


if __name__ == "__main__":
    main()

--- .\src\utils\coreutils\cat.conf ---
src/utils/coreutils/cat.phs
cat.phsb
phasorcompiler
--no-logo -o %s %s


--- .\src\utils\coreutils\cat.phs ---
#!/usr/bin/env phasor
// Port of 'cat' - concatenate files and print on the standard output for GNU.
// 'cat' file concatenation program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Include standard libraries
using("stdio", "stdfile", "stdsys", "stdstr");

// Global variables for options
var g_show_all = false;        // -A, --show-all
var g_number_nonblank = false; // -b, --number-nonblank
var g_show_ends = false;       // -e, -E, --show-ends
var g_number = false;          // -n, --number
var g_squeeze_blank = false;   // -s, --squeeze-blank
var g_show_tabs = false;       // -t, -T, --show-tabs
var g_show_nonprinting = false; // -v, --show-nonprinting

// Line number counter
var g_line_number = 1;

fn startsWith(input: string, prefix: string) {
    if (len(input) < len(prefix)) return false;
    return substr(input, 0, len(prefix)) == prefix;
}

// Function to display help message
fn show_help() -> void {
    puts("Usage: cat [OPTION]... [FILE]...");
    puts("Concatenate FILE(s) to standard output.");
    puts("");
    puts("With no FILE, or when FILE is -, read standard input.");
    puts("");
    puts("Options:");
    puts("  -A, --show-all           equivalent to -vET");
    puts("  -b, --number-nonblank    number nonempty output lines, overrides -n");
    puts("  -e                       equivalent to -vE");
    puts("  -E, --show-ends          display $ at end of each line");
    puts("  -n, --number             number all output lines");
    puts("  -s, --squeeze-blank      suppress repeated empty output lines");
    puts("  -t                       equivalent to -vT");
    puts("  -T, --show-tabs          display TAB characters as ^I");
    puts("  -u                       (ignored)");
    puts("  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB");
    puts("      --help               display this help and exit");
    puts("      --version            output version information and exit");
    puts("");
    puts("Examples:");
    puts("  cat f - g  Output f's contents, then standard input, then g's contents.");
    puts("  cat        Copy standard input to standard output.");
    puts("");
    puts("GNU coreutils online help: <https://www.gnu.org/software/coreutils/>");
    puts("Report any translation bugs to <https://translationproject.org/team/>");
}

// Function to display version information
fn show_version() -> void {
    puts("cat (Phasor coreutils) 0.1");
    puts("License GPLv3+: GNU GPL version 3 or later");
    puts("This is free software: you are free to change and redistribute it.");
    puts("There is NO WARRANTY, to the extent permitted by law.");
    puts("");
    puts("Written by Daniel McGuire");
}

// Process a file (or stdin if filename is "-")
fn process_file(filename: string) -> void {
    if (filename == "-") {
        var line = gets();
        while (line != null) {
            puts(line);
            line = gets();
        }
        return;
    }
    
    if (!fexists(filename)) {
        puts_error("cat: file not found");
        return;
    }
    
    var content = fread(filename);
    if (content != null) {
        puts(content);
    }
}

// Main function
fn main() -> int {
    var arg_count = sys_argc();
    var i = 1;
    
    if (arg_count == 1) {
        process_file("-");
        return 0;
    }
    
    // Process options
    for (; i < arg_count; i = i + 1) {
        var arg = sys_argv(i);
        
        if (arg == "--") {
            i = i + 1;
            break;
        }
        
        if (!startsWith(arg, "-")) break;
        
        if (arg == "--help") {
            show_help();
            return 0;
        }
        
        if (arg == "--version") {
            show_version();
            return 0;
        }
        
        if (arg == "-A" || arg == "--show-all") {
            g_show_all = true;
            g_show_nonprinting = true;
            g_show_ends = true;
            g_show_tabs = true;
            continue;
        }
        
        if (arg == "-b" || arg == "--number-nonblank") {
            g_number_nonblank = true;
            g_number = false;
            continue;
        }
        
        if (arg == "-e") {
            g_show_nonprinting = true;
            g_show_ends = true;
            continue;
        }
        
        if (arg == "-E" || arg == "--show-ends") {
            g_show_ends = true;
            continue;
        }
        
        if (arg == "-n" || arg == "--number") {
            if (!g_number_nonblank) g_number = true;
            continue;
        }
        
        if (arg == "-s" || arg == "--squeeze-blank") {
            g_squeeze_blank = true;
            continue;
        }
        
        if (arg == "-t") {
            g_show_nonprinting = true;
            g_show_tabs = true;
            continue;
        }
        
        if (arg == "-T" || arg == "--show-tabs") {
            g_show_tabs = true;
            continue;
        }
        
        if (arg == "-v" || arg == "--show-nonprinting") {
            g_show_nonprinting = true;
            continue;
        }
        
        puts_error("cat: invalid option");
        puts("Try 'cat --help' for more information.");
        return 1;
    }
    
    // Process files
    if (i >= arg_count) {
        process_file("-");
    } else {
        while (i < arg_count) {
            process_file(sys_argv(i));
            i = i + 1;
        }
    }
    
    return 0;
}

shutdown(main());

--- .\src\utils\coreutils\cp.conf ---
src/utils/coreutils/cp.phs
cp.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\cp.phs ---
#!/usr/bin/env phasor
// Port of 'cp' file copying (main routines).
// 'cp' file copying program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdio", "stdfile", "stdsys");

fn main() {
    var argc = sys_argc();
    if (argc < 3) {
        putf("Usage: %s SOURCE DEST", sys_argv(0)); puts("");
        puts("Copy SOURCE to DEST.");
        puts("");
        puts("-f, --overwrite          overwrite destination if it exists");
        return 0;    
    }

    var ow = false;
    var i = 1;
    
    for (i = 1; i < argc; i = i + 1) {
        var arg = sys_argv(i);
        if (arg == "-f" || arg == "--overwrite") {
            ow = true;
            break;
        }
    }

    var src = sys_argv(1);
    var dest = sys_argv(2);

    if (fcp(src, dest, ow) == null)
        return 0;
    else 
        return 1;
}

shutdown(main());

--- .\src\utils\coreutils\echo.conf ---
src/utils/coreutils/echo.phs
echo.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\echo.phs ---
#!/usr/bin/env phasor
// Port of GNU echo.
// 'echo' print out program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdsys");

for (var i = 1; i < sys_argc(); i = i + 1) {
    if (i > 1) {
        print(" ");
    }
    print(sys_argv(i));
}
print("\n");
shutdown(0);

--- .\src\utils\coreutils\license.coreutils ---
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


--- .\src\utils\coreutils\license.phscoreutils ---
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2026 Daniel McGuire
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.


--- .\src\utils\coreutils\ls.conf ---
src/utils/coreutils/ls.phs
ls.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\ls.phs ---
#!/usr/bin/env phasor
// Port of 'ls' directory listing program for GNU.
// 'ls' directory listing program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdio", "stdfile", "stdsys", "stdstr");

var g_show_hidden = false;
var g_long_format = false;
var g_path = ".";

fn show_help() -> void {
    puts("Usage: ls [OPTION]... [FILE]");
    puts("List information about the FILE (the current directory by default).");
    puts("");
    puts("Options:");
    puts("  -a, --all          do not ignore entries starting with .");
    puts("  -l                 use a long listing format");
    puts("  --help             display this help and exit");
    puts("  --version          output version information and exit");
}

fn show_version() -> void {
    puts("ls (Phasor coreutils) 0.1");
    puts("License GPLv3+: GNU GPL version 3 or later");
    puts("This is free software: you are free to change and redistribute it.");
    puts("There is NO WARRANTY, to the extent permitted by law.");
}

fn list_directory() -> int {
    var dir_listing = freaddir(g_path);
    if (dir_listing == null || dir_listing == "") {
        puts_error("ls: cannot access '" + g_path + "': No such file or directory");
        return 1;
    }
    
    puts(dir_listing);
    return 0;
}

fn starts_with(input: string, prefix: string) -> bool {
    if (len(input) < len(prefix)) return false;
    return substr(input, 0, len(prefix)) == prefix;
}

fn main() -> int {
    var i = 1;
    var arg_count = sys_argc();
    
    while (i < arg_count) {
        var arg = sys_argv(i);
        
        if (arg == "--help") {
            show_help();
            return 0;
        } else if (arg == "--version") {
            show_version();
            return 0;
        } else if (arg == "--all") {
            g_show_hidden = true;
        } else if (arg == "-a") {
            g_show_hidden = true;
        } else if (arg == "-l") {
            g_long_format = true;
        } else if (starts_with(arg, "-")) {
            puts("ls: invalid option");
            puts("Try 'ls --help' for more information.");
            return 1;
        } else if (g_path == "." && i == arg_count - 1) {
            g_path = arg;
        }
        
        i = i + 1;
    }
    
    return list_directory();
}

shutdown(main());


--- .\src\utils\coreutils\mv.conf ---
src/utils/coreutils/mv.phs
mv.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\mv.phs ---
#!/usr/bin/env phasor
// Port of 'mv' - move (rename) files for GNU.
// 'mv' file moving program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdio", "stdfile", "stdsys");

fn show_help() -> void {
    puts("Usage: mv [OPTION]... SOURCE DEST");
    puts("Rename SOURCE to DEST, or move SOURCE(s) into DEST directory.");
    puts("");
    puts("Options:");
    puts("  -f, --force              overwrite destination if it exists");
    puts("  --help                   display this help and exit");
    puts("  --version                output version information and exit");
}

fn show_version() -> void {
    puts("mv (Phasor coreutils) 0.1");
    puts("License GPLv3+: GNU GPL version 3 or later");
    puts("This is free software: you are free to change and redistribute it.");
    puts("There is NO WARRANTY, to the extent permitted by law.");
}

fn main() -> int {
    var argc = sys_argc();
    if (argc < 3) {
        putf("Usage: %s SOURCE DEST", sys_argv(0)); puts("");
        puts("Move SOURCE to DEST.");
        return 1;
    }

    var force = false;
    var i = 1;
    
    for (i = 1; i < argc - 2; i = i + 1) {
        var arg = sys_argv(i);
        if (arg == "-f" || arg == "--force") {
            force = true;
        } else if (arg == "--help") {
            show_help();
            return 0;
        } else if (arg == "--version") {
            show_version();
            return 0;
        }
    }

    var src = sys_argv(argc - 2);
    var dest = sys_argv(argc - 1);

    fmv(src, dest);
    return 0;
}

shutdown(main());


--- .\src\utils\coreutils\rm.conf ---
src/utils/coreutils/rm.phs
rm.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\rm.phs ---
#!/usr/bin/env phasor
// Port of 'rm' - remove files for GNU.
// 'rm' file removal program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdio", "stdfile", "stdsys", "stdstr");

fn show_help() -> void {
    puts("Usage: rm [OPTION]... FILE...");
    puts("Remove (unlink) the FILE(s).");
    puts("");
    puts("Options:");
    puts("  -f, --force              ignore nonexistent files");
    puts("  --help                   display this help and exit");
    puts("  --version                output version information and exit");
}

fn show_version() -> void {
    puts("rm (Phasor coreutils) 0.1");
    puts("License GPLv3+: GNU GPL version 3 or later");
    puts("This is free software: you are free to change and redistribute it.");
    puts("There is NO WARRANTY, to the extent permitted by law.");
}

fn main() -> int {
    var argc = sys_argc();
    if (argc < 2) {
        putf("Usage: %s FILE...", sys_argv(0)); puts("");
        puts("Remove FILE(s).");
        return 1;
    }

    var force = false;
    var i = 1;
    
    while (i < argc) {
        var arg = sys_argv(i);
        
        if (arg == "--") {
            i = i + 1;
            break;
        }
        
        if (arg == "-f" || arg == "--force") {
            force = true;
            i = i + 1;
            continue;
        }
        
        if (arg == "--help") {
            show_help();
            return 0;
        }
        
        if (arg == "--version") {
            show_version();
            return 0;
        }
        
        if (starts_with(arg, "-")) {
            puts("rm: invalid option");
            puts("Try 'rm --help' for more information.");
            return 1;
        }
        
        break;
    }

    var error = false;
    while (i < argc) {
        var file = sys_argv(i);
        if (!frm(file)) {
            if (!force) {
                puts("rm: cannot remove file");
                error = true;
            }
        }
        i = i + 1;
    }

    if (error) return 1;
    return 0;
}

shutdown(main());


--- .\src\utils\coreutils\touch.conf ---
src/utils/coreutils/touch.phs
touch.phsb
phasorcompiler
--no-logo -o %s %s

--- .\src\utils\coreutils\touch.phs ---
#!/usr/bin/env phasor
// Port of touch -- change modification and access times of files for GNU.
// 'touch' file modification program for Phasor.
//   Copyright (C) 2026 Daniel McGuire.
//
//   This program is free software: you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, either version 3 of the License, or
//   (at your option) any later version.
//
//   This program is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.
//
//   You should have received a copy of the GNU General Public License
//   along with this program.  If not, see <https://www.gnu.org/licenses/>.

using("stdio", "stdfile", "stdsys", "stdstr", "stdtype");

// Global variables for options
var g_no_create = false;
var g_no_dereference = false;
var g_update_atime = true;
var g_update_mtime = true;
var g_reference = null;
var g_date = null;
var g_timestamp = null;
var g_error_occurred = false;

fn startsWith(input: string, prefix: string) {
    if (len(input) < len(prefix)) return false;
    return substr(input, 0, len(prefix)) == prefix;
}

// Function to display help message
fn show_help() -> void {
    puts("Usage: touch [OPTION]... FILE");
    puts("Update the access and modification times of FILE to the current time.");
    puts("If FILE does not exist, it is created empty, unless -c is supplied.");
    puts("");
    puts("Options:");
    puts("  -a                  change only the access time");
    puts("  -c, --no-create     do not create any files");
    puts("  -d, --date=STRING   parse STRING and use as time");
    puts("  -h, --no-dereference affect symbolic links directly");
    puts("  -m                  change only the modification time");
    puts("  -r, --reference=FILE use this file's times");
    puts("  --help              display this help and exit");
    puts("  --version           output version information and exit");
}

// Function to display version information
fn show_version() -> void {
    puts("touch (Phasor coreutils) 0.1");
    puts("License GPLv3+: GNU GPL version 3 or later");
    puts("This is free software: you are free to change and redistribute it.");
    puts("There is NO WARRANTY, to the extent permitted by law.");
}

// Function to parse date string
fn parse_date(date_str: string) -> int {
    return time() / 1000;
}

// Function to get time from reference file
fn get_reference_time(ref_file: string) -> int {
    if (!fexists(ref_file)) {
        puts("touch: cannot stat reference file");
        g_error_occurred = true;
        return 0;
    }
    return fpropget(ref_file, "m", 0);
}

// Main touch function
fn touch_file(filename: string) -> void {
    var current_time = time() / 1000;
    var target_time = current_time;
    
    if (g_reference) {
        target_time = get_reference_time(g_reference);
        if (g_error_occurred) return;
    } else if (g_date) {
        target_time = parse_date(g_date);
    } else if (g_timestamp) {
        target_time = to_int(g_timestamp);
    }
    
    var exists = fexists(filename);
    
    if (!exists) {
        if (g_no_create) return;
        if (!fmk(filename)) {
            puts("touch: cannot create file");
            g_error_occurred = true;
            return;
        }
    }
    
    if (g_update_atime && !fpropset(filename, "a", target_time)) {
        puts("touch: cannot update access time");
        g_error_occurred = true;
    }
    
    if (g_update_mtime && !fpropset(filename, "m", target_time)) {
        puts("touch: cannot update modification time");
        g_error_occurred = true;
    }
}

fn main() -> int {
    var arg_count = sys_argc();
    var filename = null;
    
    for (var i = 1; i < arg_count; i = i + 1) {
        var arg = sys_argv(i);
        
        if (arg == "--help") {
            show_help();
            return 0;
        } else if (arg == "--version") {
            show_version();
            return 0;
        } else if (arg == "--") {
            i = i + 1;
            break;
        } else if (arg == "--no-create" || arg == "-c") {
            g_no_create = true;
        } else if (arg == "--no-dereference" || arg == "-h") {
            g_no_dereference = true;
        } else if (arg == "-a") {
            g_update_atime = true;
            g_update_mtime = false;
        } else if (arg == "-m") {
            g_update_atime = false;
            g_update_mtime = true;
        } else if (startsWith(arg, "-") && len(arg) > 1) {
            for (var j = 1; j < len(arg); j = j + 1) {
                var opt = substr(arg, j, 1);
                if (opt == "a") {
                    g_update_atime = true;
                    g_update_mtime = false;
                } else if (opt == "c") {
                    g_no_create = true;
                } else if (opt == "h") {
                    g_no_dereference = true;
                } else if (opt == "m") {
                    g_update_atime = false;
                    g_update_mtime = true;
                } else {
                    puts("touch: invalid option");
                    puts("Try 'touch --help' for more information.");
                    return 1;
                }
            }
        } else {
            filename = arg;
        }
    }
    
    if (filename == null) {
        puts("touch: missing file operand");
        puts("Try 'touch --help' for more information.");
        return 1;
    }
    
    touch_file(filename);
    
    if (g_error_occurred) {
        return 1;
    }
    return 0;
}

shutdown(main());


--- .\src\utils\Shell\license.shell ---
Copyright 2026 Daniel McGuire

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


--- .\src\utils\Shell\pmake.conf ---
src/utils/Shell/Shell.phs
phash.phsb
phasorcompiler
--no-logo -o %s %s


--- .\src\utils\Shell\Shell.dox ---
/**
 * @brief A simple interactive shell implementation for the Phasor VM.
 * * This script provides a basic Command Line Interface (CLI) that allows users 
 * to execute system commands, navigate the file system, and interact with the 
 * Phasor environment. It demonstrates the use of standard library modules 
 * for I/O, string manipulation, and system execution.
 */

/**
 * @brief Removes leading and trailing whitespace from a string.
 * * Iterates through the input string to strip space characters (' ') from both
 * the beginning and the end of the text.
 * * @param s The input string to be trimmed.
 * @return string A new string with whitespace removed.
 */
fn trim(s: string) -> string { ... }

/**
 * @brief Checks if a string starts with a specific prefix.
 * * Performs a length-guarded comparison of the beginning of the input string
 * against the provided prefix string.
 * * @param input The string to search within.
 * @param prefix The substring to look for at the start.
 * @return bool True if input starts with prefix, false otherwise.
 */
fn starts_with(input: string, prefix: string) -> bool { ... }

/**
 * @brief The main execution loop of the Phasor Shell.
 * * 
 * * The main function performs the following steps in an infinite loop:
 * 1. Displays a prompt containing the current working directory (@ref fcd).
 * 2. Reads user input from standard input (@ref gets).
 * 3. Trims the input and checks for the "exit" command.
 * 4. Dispatches the command to the underlying operating system (@ref sys_execute).
 * * @return int Returns 0 on successful termination via 'exit'.
 */
fn main() { ... }

/**
 * @section stdlib_imports Standard Library Dependencies
 * * The shell relies on the following Phasor STDLIB modules:
 * - @b stdio: Provides puts(), printf(), and gets().
 * - @b stdstr: Provides len(), substr(), and concat().
 * - @b stdsys: Provides sys_execute().
 * - @b stdfile: Provides fcd() for directory tracking.
 */

--- .\src\utils\Shell\Shell.phs ---
#!/usr/bin/env phasor
// Simple Shell
// (C) 2026 Daniel McGuire
// This file is licensed under the MIT License

using("stdio", "stdfile", "stdsys", "stdstr");

puts("Phasor Shell\n(C) 2026 Daniel McGuire\n");

fn trim(s: string) -> string {
    var out = "";
    var i = 0;
    var n = len(s);

    while (i < n && substr(s, i, 1) == " ") {
        i = i + 1;
    }

    while (i < n) {
        out = concat(out, substr(s, i, 1));
        i = i + 1;
    }

    var end = len(out) - 1;
    while (end >= 0 && substr(out, end, 1) == " ") {
        end = end - 1;
    }

    if (end < 0) return "";
    return substr(out, 0, end + 1);
}

fn starts_with(input: string, prefix: string) -> bool {
    if (len(input) < len(prefix)) return false;
    return substr(input, 0, len(prefix)) == prefix;
}

fn main() {
    while (true) {
        printf("%s$ ", fcd());

        var line = gets();

        line = trim(line);
        if (line.len() == 0) {
            continue;
        }

        if (starts_with(line, "exit")) {
            line = null;
            return 0;
        }

        if (line == null) {
            line = "";
            continue;
        }

        sys_execute(line);
    }
    return 0;
}

if (!main()) {
    puts_error("Unknown error");
}

--- .\thirdparty\CMakeLists.txt ---
file(GLOB extern RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *)
foreach(mod ${extern})
    if(IS_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/${mod})
        if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${mod}/CMakeLists.txt)
            add_subdirectory(${mod})
        endif()
    endif()
endforeach()


--- .\thirdparty\pmake\CMakeLists.txt ---
add_subdirectory(executable)

--- .\thirdparty\pmake\Executable\CMakeLists.txt ---
add_subdirectory(pmake)

--- .\thirdparty\pmake\Executable\pmake\CMakeLists.txt ---
add_custom_command(
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/pmake.hpp
    COMMAND $<TARGET_FILE:phasor_cxx_transpiler> ${CMAKE_CURRENT_SOURCE_DIR}/../../main.phs -o ${CMAKE_CURRENT_BINARY_DIR}/pmake.hpp -H --nologo
    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/../../main.phs phasor_cxx_transpiler
    COMMENT "Building PHS bytecode pmake.hpp"
)

add_executable(pmake
    pmake.rc
    pmake_main.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/pmake.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/../../main.phs
)
target_include_directories(pmake PRIVATE ${CMAKE_CURRENT_BINARY_DIR} ../../include)
target_link_libraries(pmake phasor_native_runtime_static)
set_target_properties(pmake PROPERTIES EXCLUDE_FROM_ALL TRUE)

--- .\thirdparty\pmake\Executable\pmake\pmake.rc ---
#include <windows.h>
#include <winver.h>

// pmake

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,3,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG 
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS_NT_WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0" // Language: US English, Codepage: Unicode
        BEGIN
            VALUE "CompanyName", "Phasor"
            VALUE "FileDescription", "pmake Build Tool"
            VALUE "FileVersion", "1.0.0.0"
            VALUE "InternalName", "pmake.exe"
            VALUE "LegalCopyright", "© 2026 Daniel McGuire"
            VALUE "OriginalFilename", "pmake.exe"
            VALUE "ProductName", "Phasor Bytecode VM"
            VALUE "ProductVersion", "3.0.0.0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0409, 1200
    END
END




--- .\thirdparty\pmake\Executable\pmake\pmake_main.cpp ---
#include <pmake.hpp>

#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <string>
#include <vector>

#include <Value.hpp>

// Forward declare native runtime entry points (linked in from the runtime library)
extern "C" void exec(const unsigned char embeddedBytecode[], size_t embeddedBytecodeSize, const char *moduleName,
                     const void *nativeFunctionsVector, const int argc, const char **argv);

// Main entry point
int main(int argc, char *argv[], char *envp[])
{
	int exitCode = 1;

	try
	{
		exec(embeddedBytecode, embeddedBytecodeSize, moduleName.c_str(), nullptr, argc, (const char **)argv);
		exitCode = 0;
	}
	catch (const std::exception &e)
	{
		std::cerr << "Runtime Error: " << e.what() << "\n";
		return 1;
	}

	return exitCode;
}


--- .\thirdparty\pmake\include\Value.hpp ---
#pragma once
#include <iostream>
#include <string>
#include <variant>
#include <unordered_map>
#include <memory>
#include <vector>
/// @brief The Phasor Programming Language and Runtime
namespace Phasor
{

/**
 * @brief Runtime value types for the VM
 */
enum class ValueType
{
	Null,
	Bool,
	Int,
	Float,
	String,
	Struct,
	Array
};

/**
 * @brief A value in the Phasor VM
 *
 * Uses std::variant for type-safe union
 */
class Value
{
  public:
	struct StructInstance
	{
		std::string                            structName;
		std::unordered_map<std::string, Value> fields;
	};
	using ArrayInstance = std::vector<Value>;

  private:
	using DataType = std::variant<std::monostate, bool, int64_t, double, std::string, std::shared_ptr<StructInstance>,
	                              std::shared_ptr<ArrayInstance>>;

	DataType data;

  public:
	/// @brief Default constructor
	Value() : data(std::monostate{})
	{
	}
	/// @brief Boolean constructor
	Value(bool b) : data(b)
	{
	}
	/// @brief Integer constructor
	Value(int64_t i) : data(i)
	{
	}
	/// @brief Integer constructor
	Value(int i) : data(static_cast<int64_t>(i))
	{
	}
	/// @brief Double constructor
	Value(double d) : data(d)
	{
	}
	/// @brief String constructor
	Value(const std::string &s) : data(s)
	{
	}
	/// @brief String constructor
	Value(const char *s) : data(std::string(s))
	{
	}
	/// @brief Struct constructor
	Value(std::shared_ptr<StructInstance> s) : data(std::move(s))
	{
	}
	/// @brief Array constructor
	Value(std::shared_ptr<ArrayInstance> a) : data(std::move(a))
	{
	}

	/// @brief Get the type of the value
	ValueType getType() const
	{
		if (std::holds_alternative<std::monostate>(data))
			return ValueType::Null;
		if (std::holds_alternative<bool>(data))
			return ValueType::Bool;
		if (std::holds_alternative<int64_t>(data))
			return ValueType::Int;
		if (std::holds_alternative<double>(data))
			return ValueType::Float;
		if (std::holds_alternative<std::string>(data))
			return ValueType::String;
		if (std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			return ValueType::Struct;
		if (std::holds_alternative<std::shared_ptr<ArrayInstance>>(data))
			return ValueType::Array;
		return ValueType::Null; // Should not be reached if default constructed
	}

	/// @brief Check if the value is null
	bool isNull() const
	{
		return getType() == ValueType::Null;
	}
	/// @brief Check if the value is a boolean
	bool isBool() const
	{
		return getType() == ValueType::Bool;
	}
	/// @brief Check if the value is an integer
	bool isInt() const
	{
		return getType() == ValueType::Int;
	}
	/// @brief Check if the value is a double
	bool isFloat() const
	{
		return getType() == ValueType::Float;
	}
	/// @brief Check if the value is a string
	bool isString() const
	{
		return getType() == ValueType::String;
	}
	/// @brief Check if the value is a number
	bool isNumber() const
	{
		return isInt() || isFloat();
	}
	/// @brief Check if the value is an array
	bool isArray() const
	{
		return std::holds_alternative<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Get the value as a boolean
	bool asBool() const
	{
		return std::get<bool>(data);
	}
	/// @brief Get the value as an integer
	int64_t asInt() const
	{
		if (isInt())
			return std::get<int64_t>(data);
		if (isFloat())
			return static_cast<int64_t>(std::get<double>(data));
		return 0;
	}
	/// @brief Get the value as a double
	double asFloat() const
	{
		if (isFloat())
			return std::get<double>(data);
		if (isInt())
			return static_cast<double>(std::get<int64_t>(data));
		return 0.0;
	}
	/// @brief Get the value as a string
	std::string asString() const
	{
		if (isString())
			return std::get<std::string>(data);
		return toString();
	}
	/// @brief Get the value as an array
	std::shared_ptr<ArrayInstance> asArray()
	{
		return std::get<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Get the value as an array (const)
	const std::shared_ptr<const ArrayInstance> asArray() const
	{
		return std::get<std::shared_ptr<ArrayInstance>>(data);
	}

	/// @brief Add two values
	Value operator+(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() + other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() + other.asFloat());
		if (isString() && other.isString())
			return Value(asString() + other.asString());
		throw std::runtime_error("Cannot add these value types");
	}

	/// @brief Subtract two values
	Value operator-(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() - other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() - other.asFloat());
		throw std::runtime_error("Cannot subtract these value types");
	}

	/// @brief Multiply two values
	Value operator*(const Value &other) const
	{
		if (isInt() && other.isInt())
			return Value(asInt() * other.asInt());
		if (isNumber() && other.isNumber())
			return Value(asFloat() * other.asFloat());
		throw std::runtime_error("Cannot multiply these value types");
	}

	/// @brief Divide two values
	Value operator/(const Value &other) const
	{
		if (isInt() && other.isInt())
		{
			if (other.asInt() == 0)
				throw std::runtime_error("Division by zero");
			return Value(asInt() / other.asInt());
		}
		if (isNumber() && other.isNumber())
		{
			if (other.asFloat() == 0.0)
				throw std::runtime_error("Division by zero");
			return Value(asFloat() / other.asFloat());
		}
		throw std::runtime_error("Cannot divide these value types");
	}

	/// @brief Modulo two values
	Value operator%(const Value &other) const
	{
		if (isInt() && other.isInt())
		{
			if (other.asInt() == 0)
				throw std::runtime_error("Modulo by zero");
			return Value(asInt() % other.asInt());
		}
		throw std::runtime_error("Modulo requires integer operands");
	}

	/// @brief Unary negation
	Value operator-() const
	{
		if (isInt())
			return Value(-asInt());
		if (isFloat())
			return Value(-asFloat());
		throw std::runtime_error("Cannot negate this value type");
	}

	/// @brief Logical negation
	Value operator!() const
	{
		return Value(!isTruthy());
	}

	/// @brief Logical AND
	Value logicalAnd(const Value &other) const
	{
		return Value(isTruthy() && other.isTruthy());
	}

	/// @brief Logical OR
	Value logicalOr(const Value &other) const
	{
		return Value(isTruthy() || other.isTruthy());
	}

	/// @brief Helper to determine truthiness
	bool isTruthy() const
	{
		if (isNull())
			return false;
		if (isBool())
			return asBool();
		if (isInt())
			return asInt() != 0;
		if (isFloat())
			return asFloat() != 0.0;
		if (isString())
		{
			if (asString() == "true" || asString() == "1")
				return true;
			else if (asString() == "false" || asString() == "0")
				return false;
			return !asString().empty();
		}
		return false;
	}

	/// @brief Comparison operations
	bool operator==(const Value &other) const
	{
		if (getType() != other.getType())
			return false;
		if (isNull())
			return true;
		if (isBool())
			return asBool() == other.asBool();
		if (isInt())
			return asInt() == other.asInt();
		if (isFloat())
			return asFloat() == other.asFloat();
		if (isString())
			return asString() == other.asString();
		if (isArray())
		{
			if (!other.isArray())
				return false;
			const auto &self_arr = *asArray();
			const auto &other_arr = *other.asArray();
			return self_arr == other_arr;
		}
		return false;
	}

	/// @brief Inequality comparison
	bool operator!=(const Value &other) const
	{
		return !(*this == other);
	}

	/// @brief Less than comparison
	bool operator<(const Value &other) const
	{
		if (isInt() && other.isInt())
			return asInt() < other.asInt();
		if (isNumber() && other.isNumber())
			return asFloat() < other.asFloat();
		if (isString() && other.isString())
			return asString() < other.asString();
		throw std::runtime_error("Cannot compare these value types ");
	}

	/// @brief Greater than comparison
	bool operator>(const Value &other) const
	{
		if (isInt() && other.isInt())
			return asInt() > other.asInt();
		if (isNumber() && other.isNumber())
			return asFloat() > other.asFloat();
		if (isString() && other.isString())
			return asString() > other.asString();
		throw std::runtime_error("Cannot compare these value types ");
	}

	/// @brief Less than or equal to comparison
	bool operator<=(const Value &other) const
	{
		return !(*this > other);
	}
	/// @brief Greater than or equal to comparison
	bool operator>=(const Value &other) const
	{
		return !(*this < other);
	}

	/// @brief Convert to string for printing
	std::string toString() const
	{
		if (isNull())
			return "null";
		if (isBool())
			return asBool() ? "true" : "false";
		if (isInt())
			return std::to_string(asInt());
		if (isFloat())
			return std::to_string(asFloat());
		if (isString())
			return asString();
		if (isArray())
		{
			std::string result = "[";
			const auto &arr = *asArray();
			for (size_t i = 0; i < arr.size(); ++i)
			{
				result += arr[i].toString();
				if (i < arr.size() - 1)
				{
					result += ", ";
				}
			}
			result += "]";
			return result;
		}
		return "unknown";
	}

	/// @brief Convert to C Style String
	const char *c_str() const
	{
		if (!isString())
			throw std::runtime_error("c_str() can only be called on string values");
		return std::get<std::string>(data).c_str();
	}

	/// @brief Print to output stream
	friend std::ostream &operator<<(std::ostream &os, const Value &v)
	{
		os << v.toString();
		return os;
	}

	bool isStruct() const
	{
		return std::holds_alternative<std::shared_ptr<StructInstance>>(data);
	}

	std::shared_ptr<StructInstance> asStruct()
	{
		return std::get<std::shared_ptr<StructInstance>>(data);
	}

	const std::shared_ptr<const StructInstance> asStruct() const
	{
		return std::get<std::shared_ptr<StructInstance>>(data);
	}

	static Value createStruct(const std::string &name)
	{
		return Value(std::make_shared<StructInstance>(StructInstance{name}));
	}

	static Value createArray(std::vector<Value> elements = {})
	{
		return Value(std::make_shared<ArrayInstance>(std::move(elements)));
	}

	Value getField(const std::string &name) const
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			throw std::runtime_error("getField() called on non-struct value");
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		auto it = s->fields.find(name);
		if (it == s->fields.end())
			return Value();
		return it->second;
	}

	void setField(const std::string &name, Value value)
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			throw std::runtime_error("setField() called on non-struct value");
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		s->fields[name] = std::move(value);
	}

	bool hasField(const std::string &name) const
	{
		if (!std::holds_alternative<std::shared_ptr<StructInstance>>(data))
			return false;
		auto s = std::get<std::shared_ptr<StructInstance>>(data);
		return s->fields.find(name) != s->fields.end();
	}
};
} // namespace Phasor


--- .\thirdparty\pmake\main.phs ---
#!/usr/bin/env phasor
using("stdsys", "stdtype", "stdio", "stdfile", "stdstr");

var project = "<project>";
var version = "0.0.0";
var subver;
var installFolder = "out";
var srcFolder = fcd();
var cacheFolder = ".pmake";
var cacheFile = c_fmt("%s/%%s.cache", cacheFolder);
var lockFile = c_fmt("%s/%%s.lock", cacheFolder);
var pid = sys_pid();

if (fexists("project.pmake")) {
    project = freadln("project.pmake", 0); // Line 1 - Name
    version = freadln("project.pmake", 1); // Line 2 - Version
    subver = freadln("project.pmake", 2); // Line 3 - Sub-version command
    installFolder = fabsolute(freadln("project.pmake", 3)); // Line 4 - Install folder
    srcFolder = fabsolute(freadln("project.pmake", 4)); // Line 5 - Source folder
    cacheFolder = fabsolute(freadln("project.pmake", 5)); // Line 6 - Cache folder
    cacheFile = c_fmt("%s/%%s.cache", cacheFolder);
    lockFile = c_fmt("%s/%%s.lock", cacheFolder);
} else {
    puts_error("project.pmake file not found, using defaults");
}

fn printHelp(program: string, configured: bool) {
    var presetMsg = "preset_message";
    if (configured) {
        putf("Usage: [runtime] %s [preset] [options]", program);
        presetMsg = "required only if regenerating";
    } else {
        putf("Usage: [runtime] %s <preset> [options]\n", program);
        sys_fork("cmake", "--list-presets"); 
        presetMsg = "required to generate build files";
    }
    printf(`
Options:
  preset           The CMake preset to use for configuration (%s)
  -h, --help       Show this help message
  -i, --install    Install the built files to the specified prefix (default: out)
  -b, --build      Build the project to the specified output folder (default: .pmake/CMakeBuild)
  -s, --src        Specify the source folder (default: current directory)
  -c, --clean      Clean the build and cache folders before building`, presetMsg);
}

fn configure(srcFolder: string, buildFolder: string, preset: string) -> bool {
    if (sys_fork("cmake", "-S", srcFolder, "-B", buildFolder, "--preset", preset) == 0) {
        return true;
    }
    return false;
}

fn build(buildFolder: string) -> bool {
    if (sys_fork("ninja", "-C", buildFolder) == 0) {
        return true;
    }
    return false;
}

fn install(buildFolder: string, prefixFolder: string) -> bool {
    if (sys_fork("cmake", "--install", buildFolder, "--prefix", prefixFolder) == 0) {
        return true;
    }
    return false;
}

fn writeCache(text: string, cacheName: string) -> bool {
    var fileName = c_fmt(cacheFile, cacheName);
    if (fexists(fileName)) {
        if (!frm(fileName)) {
            puts_error("Failed to delete old cache file");
            return false;
        }
    }
    if (!fwrite(fileName, text)) {
        puts_error("Failed to write cache file");
        return false;
    }
    return true;
}

fn readCache(cacheName: string) -> string {
    var fileName = c_fmt(cacheFile, cacheName);
    if (!fexists(fileName)) {
        return "";
    }
    return fread(fileName);
}

fn writeStatus(text: string) -> bool {
    var fileName = c_fmt(lockFile, project);
    var tmpFile = c_fmt("%s.tmp", fileName);
    var finalText = c_fmt("%s\nPID: %d", text, pid);
    if (fexists(fileName)) {
        if (!frm(fileName)) {
            puts_error("Failed to delete old status file");
            return false;
        }
    }
    if (!fwrite(tmpFile, finalText)) {
        puts_error("Failed to write temp status file");
        return false;
    } else {
        if (!fmv(tmpFile, fileName)) {
            puts_error("Failed to move status file");
            return false;
        }
    }
    return true;
}

fn clearStatus() -> bool {
    var fileName = c_fmt(lockFile, project);
    if (fexists(fileName)) {
        if (!frm(fileName)) {
            puts_error("Failed to delete status file");
            return false;
        }
    }
    return true;
}

fn main() -> int {
    printf("pmake - Portable CMake Wrapper (%s)\n%s %s", project, project, version);
    if (subver) { 
        print("-");
        sys_shell(subver);
    }
    else puts("");
    var preset;
    var doConfigure = false;
    var doBuild = false;
    var doInstall = false;
    var doClean = false;
    var outFolder = ".pmake/CMakeBuild";
    var l_statusFile = c_fmt(lockFile, project);
    var i = 1;

    if (!fexists(cacheFolder)) {
        if (!fmkdir(cacheFolder)) {
            puts_error("Failed to create cache directory");
            return -1;
        }
    }

    if (sys_argc() > 1 && !starts_with(sys_argv(1), "-")) {
        preset = to_string(sys_argv(1));
        i = 2;
        doConfigure = true;
    } else {
        if (fexists(c_fmt(cacheFile, "preset"))) {
            preset = readCache("preset");
            putf("Using cached preset: %s\n", preset);
        } else {
            puts("");
            printHelp(sys_argv(0), false);
            frmdir(cacheFolder, true);
            return -1;
        }
    }

    if (fexists(c_fmt(cacheFile, "install")))
        installFolder = readCache("install");
    if (fexists(c_fmt(cacheFile, "build")))
        outFolder = readCache("build");
    if (fexists(c_fmt(cacheFile, "src")))
        srcFolder = readCache("src");

    while (i < sys_argc()) {
        var arg = to_string(sys_argv(i));

        if (arg == "-s" || arg == "--src") {
            if (i + 1 < sys_argc() && !starts_with(sys_argv(i + 1), "-")) {
                srcFolder = to_string(sys_argv(i + 1));
                i = i + 1;
            } else {
                putf_error("Expected source folder after %s", arg);
                return 1;
            }
            writeCache(fabsolute(srcFolder), "src");
        } else if (arg == "-c" || arg == "--clean") {
            doClean = true;
        } else if (arg == "-i" || arg == "--install") {
            doInstall = true;

            if (i + 1 < sys_argc() && !starts_with(sys_argv(i + 1), "-")) {
                installFolder = to_string(sys_argv(i + 1));
                i = i + 1;
            }

            writeCache(fabsolute(installFolder), "install");
        } else if (arg == "-b" || arg == "--build") {
            doBuild = true;

            if (i + 1 < sys_argc() && !starts_with(sys_argv(i + 1), "-")) {
                outFolder = to_string(sys_argv(i + 1));
                i = i + 1;
            }

            writeCache(fabsolute(outFolder), "build");
        } else if (arg == "-h" || arg == "--help") {
            printHelp(sys_argv(0), true);
            return 0;
        } else if (arg == "-f" || arg == "--force") {
            clearStatus();
            frmdir(outFolder, true);
        } else {
            putf_error("Unknown argument: %s", arg);
            printHelp(sys_argv(0), true);
            return 1;
        }

        i = i + 1;
    }

    if (fexists(l_statusFile)) {
        var pid = to_int(substr(freadln(l_statusFile, "1"), 5));
        if (pid != sys_pid()) {
            putf_error("pmake locked by another process %d", l_statusFile);
            return 2;
        }
    }
    if (!doClean) writeStatus("init");

    if (!doClean) writeCache(preset, "preset");

    if (doClean && fexists(cacheFolder)) {
        if (fexists(c_fmt(cacheFile, "configure") || fexists(outFolder))) {
            doConfigure = false;
            if (!frmdir(outFolder, true)) {
                putf_error("Failed to clean output folder %s", outFolder);
                return 1;
            }
        }
        clearStatus();
        frmdir(cacheFolder, true);
        if (!doBuild && !doInstall) {
            puts("Cleaned build and cache folders");
            return 0;
        }
    }

    if (!doClean && !doConfigure && !doBuild && !doInstall) {
        doBuild = true;
    }

    if (!doClean && !doConfigure && !fexists(outFolder)) 
    { 
        puts("Output missing, configuring...");
        doConfigure = true;
    }

    if (doConfigure || !fexists(c_fmt(cacheFile, "configure"))) {
        writeStatus("config");
    	putf("Configuring %s...", project);
        if (!configure(srcFolder, outFolder, preset)) {
            puts_error("Configuration failed");
            return 1;
        }
        writeCache(fabsolute(outFolder), "build");
        writeCache(fabsolute(srcFolder), "src");
        writeCache(preset, "preset");
        writeCache(fabsolute(installFolder), "install");
        writeCache("", "configure");
        writeStatus("idle");
    }

    if (doBuild) {
        writeStatus("build");
        putf("Building %s...", project);
        if (!build(outFolder)) {
            puts_error("Build failed");
            return 1;
        }
        writeStatus("idle");
    }

    if (doInstall) {
    writeStatus("install");
	putf("Installing %s...", project);
        if (!install(outFolder, installFolder)) {
            puts_error("Installation failed");
            return 1;
        }
        writeStatus("idle");
    }
    return 0;
}

var stat = main();
clearStatus();
shutdown(stat);


--- .\thirdparty\pmake\pmake.conf ---
src/utils/pmake/main.phs
pmake.phsb
phasorcompiler
--no-logo -o %s %s


#pragma once
#include "../AST/AST.hpp"
#include <Value.hpp>
#include "../ISA/ISA.hpp"
#include <cstdint>
#include <map>
#include <string>
#include <vector>

namespace Phasor
{
/// @brief Instruction with up to 5 operands
/// Format: instruction operand1, operand2, operand3, operand4, operand5
/// Each instruction uses only the operands it needs
struct Instruction
{
	OpCode  op;       ///< Operation code
	int32_t operand1; ///< First operand
	int32_t operand2; ///< Second operand
	int32_t operand3; ///< Third operand
	int32_t operand4; ///< Fourth operand
	int32_t operand5; ///< Fifth operand

	// Default constructor
	Instruction() : op(OpCode::HALT), operand1(0), operand2(0), operand3(0), operand4(0), operand5(0)
	{
	}

	// Full constructor
	Instruction(OpCode op, int32_t op1 = 0, int32_t op2 = 0, int32_t op3 = 0, int32_t op4 = 0, int32_t op5 = 0)
	    : op(op), operand1(op1), operand2(op2), operand3(op3), operand4(op4), operand5(op5)
	{
	}
};

/// @brief Struct metadata stored alongside bytecode (struct section)
struct StructInfo
{
	std::string              name;            ///< Struct name
	int                      firstConstIndex; ///< Index into constants for the first default value
	int                      fieldCount;      ///< Number of fields in this struct
	std::vector<std::string> fieldNames;      ///< Field names in declaration order
};

/// @brief Complete bytecode structure
struct Bytecode
{
	std::vector<Instruction>   instructions;     ///< List of instructions
	std::vector<Value>         constants;        ///< Constant pool
	std::map<std::string, int> variables;        ///< Variable name -> index mapping
	std::map<std::string, int> functionEntries;  ///< Function name -> instruction index mapping
	std::map<std::string, int> functionParamCounts; ///< Function name -> parameter count
	int                        nextVarIndex = 0; ///< Next available variable index

	// Struct section (planned usage by future struct codegen)
	std::vector<StructInfo>    structs;       ///< List of struct descriptors
	std::map<std::string, int> structEntries; ///< Struct name -> index in structs

	/// @brief Add a constant to the pool and return its index
	int addConstant(const Value &value)
	{
		constants.push_back(value);
		return static_cast<int>(constants.size()) - 1;
	}

	/// @brief Get or create a variable index
	int getOrCreateVar(const std::string &name)
	{
		auto it = variables.find(name);
		if (it != variables.end())
		{
			return it->second;
		}
		int index = nextVarIndex++;
		variables[name] = index;
		return index;
	}

	/// @brief Emit an instruction with operands
	void emit(OpCode op, int32_t op1 = 0, int32_t op2 = 0, int32_t op3 = 0, int32_t op4 = 0, int32_t op5 = 0)
	{
		instructions.push_back(Instruction(op, op1, op2, op3, op4, op5));
	}
};

/**
 * @brief Code generator for Phasor VM
 */
class CodeGenerator
{
  public:
	/**
	 * @brief Generate bytecode from program
	 *
	 * @param program Program to generate bytecode for
	 * @param existingVars Existing variables to use
	 * @param nextVarIdx Next available variable index
	 * @param replMode REPL mode
	 * @return Bytecode Generated bytecode
	 */
	Bytecode generate(const AST::Program &program, const std::map<std::string, int> &existingVars = {},
	                  int nextVarIdx = 0, bool replMode = false);

  private:
	Bytecode bytecode;       ///< Generated bytecode
	bool     isRepl = false; ///< REPL mode
	// Inferred types for variables (simple, flow-insensitive mapping)
	std::map<std::string, ValueType> inferredTypes;

	// Register allocation for v2.0
	uint8_t           nextRegister = 0; ///< Next available register
	std::vector<bool> registerInUse;    ///< Track which registers are in use

	/// @brief Allocate a new register
	uint8_t allocateRegister()
	{
		for (size_t i = 0; i < 32; i++)
		{
			if (i >= registerInUse.size())
			{
				registerInUse.resize(i + 1, false);
			}
			if (!registerInUse[i])
			{
				registerInUse[i] = true;
				return static_cast<uint8_t>(i);
			}
		}
		throw std::runtime_error("Out of registers: exceeded 32 per frame");
	}

	/// @brief Free a register
	void freeRegister(uint8_t reg)
	{
		if (reg < registerInUse.size())
		{
			registerInUse[reg] = false;
		}
	}

	/// @brief Reset register allocator
	void resetRegisters()
	{
		registerInUse.clear();
		nextRegister = 0;
	}

	/// @brief Check if expression is a compile-time literal
	bool isLiteralExpression(const AST::Expression *expr, Value &outValue);

	/// @brief Simple expression type inference (conservative)
	/// @param expr expression to inspect
	/// @param known set to true when a type is known
	/// @return inferred ValueType (valid only when known == true)
	ValueType inferExpressionType(const AST::Expression *expr, bool &known);

	void generateStatement(const AST::Statement *stmt);                ///< Generate bytecode from Statement
	void generateExpression(const AST::Expression *expr);              ///< Generate bytecode from Expression
	void generateVarDecl(const AST::VarDecl *varDecl);                 ///< Generate bytecode from Variable Declaration
	void generateExpressionStmt(const AST::ExpressionStmt *exprStmt);  ///< Generate bytecode from Expression Statement
	void generatePrintStmt(const AST::PrintStmt *printStmt);           ///< Generate bytecode from Print Statement
	void generateImportStmt(const AST::ImportStmt *importStmt);        ///< Generate bytecode from Import Statement
	void generateExportStmt(const AST::ExportStmt *exportStmt);        ///< Generate bytecode from Export Statement
	void generateNumberExpr(const AST::NumberExpr *numExpr);           ///< Generate bytecode from Numeral Expression
	void generateStringExpr(const AST::StringExpr *strExpr);           ///< Generate bytecode from String Expression
	void generateIdentifierExpr(const AST::IdentifierExpr *identExpr); ///< Generate bytecode from Identifier Expression
	void generateUnaryExpr(const AST::UnaryExpr *unaryExpr);           ///< Generate bytecode from Unary Expression
	void generateCallExpr(const AST::CallExpr *callExpr);              ///< Generate bytecode from Call Expression
	void generateBinaryExpr(const AST::BinaryExpr *binExpr);           ///< Generate bytecode from Binary Expression
	void generateBlockStmt(const AST::BlockStmt *blockStmt);           ///< Generate bytecode from Block Statement
	void generateIfStmt(const AST::IfStmt *ifStmt);                    ///< Generate bytecode from If Statement
	void generateWhileStmt(const AST::WhileStmt *whileStmt);           ///< Generate bytecode from While Statement
	void generateForStmt(const AST::ForStmt *forStmt);                 ///< Generate bytecode from For Statement
	void generateReturnStmt(const AST::ReturnStmt *returnStmt);        ///< Generate bytecode from Return Statement
	void generateUnsafeBlockStmt(
	    const AST::UnsafeBlockStmt *unsafeStmt);                  ///< Generate bytecode from Unsafe Block Statement
	void generateFunctionDecl(const AST::FunctionDecl *funcDecl); ///< Generate bytecode from Function Declaration
	void generateBooleanExpr(const AST::BooleanExpr *boolExpr);   ///< Generate bytecode from Boolean Expression
	void generateNullExpr(const AST::NullExpr *nullExpr);         ///< Generate bytecode from Null Expression
	void generateAssignmentExpr(
	    const AST::AssignmentExpr *assignExpr); ///< Generate bytecode from Assignment Expression
	void generateStructDecl(const AST::StructDecl *decl);
	void generateStructInstanceExpr(const AST::StructInstanceExpr *expr);
	void generateFieldAccessExpr(const AST::FieldAccessExpr *expr);
	void generatePostfixExpr(const AST::PostfixExpr *expr);
	void generateBreakStmt();
	void generateContinueStmt();
	void generateSwitchStmt(const AST::SwitchStmt *switchStmt);

	// Loop context for break/continue
	std::vector<int>              loopStartStack;     // Stack of loop start positions
	std::vector<std::vector<int>> breakJumpsStack;    // Stack of break jump positions to patch
	std::vector<std::vector<int>> continueJumpsStack; // Stack of continue jump positions to patch
};

} // namespace Phasor